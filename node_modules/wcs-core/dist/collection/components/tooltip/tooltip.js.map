{"version":3,"file":"tooltip.js","sourceRoot":"","sources":["../../../src/components/tooltip/tooltip.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, ComponentInterface, h, Host, Prop, Element, Watch, Method, Listen } from '@stencil/core';\nimport { WcsTooltipAppendTo, WcsTooltipPosition } from './tooltip-interface';\n\n// We use the Tippy.js library for the tooltip. At first by using directly the styles of tippy because\n// the design system does not specify any spec for the tooltips.\n//\n// In a second time, if a need of customization is felt, it will be possible to use the lib in a\n// \"Headless\" mode where the rendering of the tooltip will be entirely in our charge, without\n// modifications in the API : https://atomiks.github.io/tippyjs/v6/headless-tippy/\nimport tippy, { Instance, Props } from 'tippy.js';\nimport { isEscapeKey } from \"../../utils/helpers\";\nimport { isMutableAriaAttribute } from \"../../utils/mutable-aria-attribute\";\n\n/**\n * List of components that require special ARIA attribute delegation handling.\n * These components have their own internal elements (like native button inside wcs-button)\n * that need to receive ARIA attributes for proper accessibility.\n * \n * Another solution we take into account is to @Watch the ARIA attributes on the component and set them on the internal element.\n * But this solution was not centralized and can be forgotten.\n */\nconst DELEGATED_ARIA_COMPONENTS  = ['WCS-BUTTON'];\n\n/**\n * Tooltips are used to provide additional information for features available on the website. These can improve the user\n * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them\n * (for longer content).\n *\n * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/\n * \n * ## Accessibility guidelines 💡\n * \n * The problem is that impaired users may not be able to see what is the information provided by the tooltip. To solve\n * this problem, the tooltip should be served with some aria attributes to make it accessible.\n *\n * Aria-features `wcs-tooltip` respect:\n * - dismiss when the user presses the `Escape` key\n * - has a `role=tooltip`\n * - when set to `interactive` mode\n *  - `aria-expanded` on the targeted element: set to true when popover is open, false when it is closed\n *\n * Aria-features `wcs-tooltip` **does not respect with `wcs-button`**:\n * - aria-controls => we cannot do it yet, we need to wait for Cross root ARIA - export ID (https://github.com/WICG/aom/blob/gh-pages/exportid-explainer.md)\n * \n * But you have to provide the \"link\" between the element you want to describe and the tooltip. To do this, you have to\n * provide the \"visual description\" you add on the `wcs-tooltip` to the `aria-label` attribute or the `aria-description` as soon as the attribute will be available \n * of the element you want to describe .\n * \n * Example:\n * \n * ```html\n * <wcs-tooltip for=\"my-button\">Trashed items</wcs-tooltip>\n * <wcs-button id=\"my-button\" aria-label=\"Trashed items\">Trash</wcs-button>\n * ```\n * \n * @cssprop --wcs-tooltip-background-color - Background color of the tooltip\n * @cssprop --wcs-tooltip-text-color - Text color of the tooltip\n * @cssprop --wcs-tooltip-padding - Padding of the tooltip\n */\n@Component({\n    tag: 'wcs-tooltip',\n    shadow: true,\n    // Tippy stylesheet and specific styles are imported in the global tooltip.scss file\n    styleUrl: 'tooltip.scss'\n})\nexport class Tooltip implements ComponentInterface {\n    /**\n     * The **id** of the element the tooltip's going to describe.\n     *\n     * This property cannot be modified after initialization.\n     *\n     * @example\n     * ```html\n     * <span id=\"tooltiped\">Some content</span>\n     * <wcs-tooltip for=\"tooltiped\">A tooltip!</wcs-tooltip>\n     * ```\n     */\n    @Prop({mutable: false})\n    for: string;\n\n    /**\n     * Where the tooltip is going to show relative to the element it's describing.\n     */\n    @Prop({reflect: true})\n    position: WcsTooltipPosition = 'bottom';\n\n    /**\n     * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside\n     * without hiding.\n     */\n    @Prop({ reflect: true })\n    interactive: boolean = false;\n\n    /**\n     * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.\n     *\n     * If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.\n     * \n     * To test it on WCS documentation page, add 'px' to the control value (string type in this case).\n     */\n    @Prop()\n    maxWidth: string | number = 350;\n\n    /**\n     * Delay in ms once a trigger event is fired before the tooltip shows or hides.\n     *\n     * You can provide an array with two values to define a different duration for show and hide.\n     *\n     * `[showDelay, hideDelay]`\n     *\n     * Use null to use default value.\n     */\n    @Prop()\n    delay: number | [number, number] = 0;\n\n    /**\n     * Duration in ms of the transition animation.\n     */\n    @Prop()\n    duration: number | [number, number] = [300, 250];\n\n    /**\n     * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.\n     *\n     * See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger\n     */\n    @Prop()\n    trigger: string = 'mouseenter focus';\n\n    /**\n     * Allows you to change the theme used by tippy.\n     *\n     * The WCS theme 'dark' is used by default and uses the WCS CSS variables.\n     *\n     * You can create a theme by following this documentation and choosing a custom name :\n     * https://atomiks.github.io/tippyjs/v6/themes/\n     */\n    @Prop()\n    theme: 'dark' | 'light' = 'dark';\n\n    /**\n     * You can use this property instead of the slot API to affect content in the tooltip.\n     *\n     * This makes it easier to manage the update if the tooltip contains elements that are not mutated when their\n     * content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM\n     * changes (the DOM must be mutated).\n     *\n     * The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first\n     * display the content of this property and then the slotted elements.\n     */\n    @Prop()\n    content: string;\n\n    /**\n     * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true,\n     * the default behavior is appendTo: \"parent\"\n     *\n     * See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto\n     */\n    @Prop()\n    appendTo: WcsTooltipAppendTo;\n\n    @Element()\n    private el: HTMLWcsTooltipElement;\n\n    private tippyInstance: Instance<Props>;\n    private forElement?: HTMLElement;\n\n    componentWillLoad(): Promise<void> | void {\n        this.forElement = document.getElementById(this.for);\n        \n        if(!this.forElement) {\n            console.error('[wcs-tooltip]: The element with the id provided in the \"for\" property does not exist');\n            return\n        }\n        \n        this.tippyInstance = tippy(this.forElement, {\n            appendTo: this.appendTo || (() => document.body),\n            theme: this.theme,\n            allowHTML: true,\n            content: this.getTooltipContentFromPropAndSlot(),\n            maxWidth: this.maxWidth,\n            placement: this.position,\n            delay: this.delay,\n            duration: this.duration,\n            interactive: this.interactive,\n            trigger: this.trigger,\n            onShow: () => this.onShow(),\n            onHide: () => this.onHide()\n        });\n    }\n\n    // region Tippy.js events\n    \n    // ARIA attributes management 🔍\n    //\n    // While tippy.js automatically handles aria-expanded on the target element, we manage it ourselves for two main reasons:\n    // 1. Some of our components (like wcs-button) have an internal structure where the accessible/focusable element\n    //    is not the root element. We need to ensure the aria-expanded is set on the correct internal element.\n    // 2. We want to maintain consistent control over our ARIA attributes across all components and ensure\n    //    they work with our custom MutableAriaAttribute interface.\n    \n    private onShow() {\n        if (!this.forElement) {\n            return;\n        }\n\n        if (this.forElement.tagName && DELEGATED_ARIA_COMPONENTS.indexOf(this.forElement.tagName) !== -1) {\n            if(isMutableAriaAttribute(this.forElement)) {\n                if(this.interactive) {\n                    this.forElement.setAriaAttribute('aria-expanded', 'true');\n                }\n            }\n        }\n    }\n    \n    private onHide() {\n        if (!this.forElement) {\n            return;\n        }\n\n        if (this.forElement.tagName && DELEGATED_ARIA_COMPONENTS.indexOf(this.forElement.tagName) !== -1) {\n            if(isMutableAriaAttribute(this.forElement)) {\n                if(this.interactive) {\n                    this.forElement.setAriaAttribute('aria-expanded', 'false');\n                }\n            }\n        }\n    }\n    \n    // endregion\n    \n    @Listen('keydown', { target: 'window' })\n    async handleKeyDown(ev: KeyboardEvent) {\n        if (isEscapeKey(ev)) {\n            if(this.tippyInstance.state.isShown) {\n                await this.hide();\n            }\n        }\n    }\n\n    private getTooltipContentFromPropAndSlot() {\n        if (this.content) {\n            return this.content + this.el.innerHTML;\n        }\n        return this.el.innerHTML;\n    }\n\n    @Watch('interactive')\n    @Watch('position')\n    @Watch('maxWidth')\n    @Watch('theme')\n    @Watch('delay')\n    @Watch('duration')\n    @Watch('trigger')\n    // @ts-ignore\n    private updateProps() {\n        this.tippyInstance?.setProps({\n            interactive: this.interactive,\n            placement: this.position,\n            maxWidth: this.maxWidth,\n            theme: this.theme,\n            delay: this.delay,\n            duration: this.duration,\n            trigger: this.trigger\n        })\n    }\n\n    @Watch('content')\n    private updateTippyContent() {\n        this.tippyInstance?.setProps({\n            content: this.getTooltipContentFromPropAndSlot()\n        })\n    }\n\n    /**\n     * Programmatically hide the tooltip\n     */\n    @Method()\n    async hide() {\n        this.tippyInstance.hide();\n    }\n\n    /**\n     * Programmatically show the tooltip\n     */\n    @Method()\n    async show() {\n        this.tippyInstance.show();\n    }\n\n    /**\n     * Temporarily prevent the tooltip from showing or hiding\n     */\n    @Method()\n    async disable() {\n        this.tippyInstance.disable();\n    }\n\n    /**\n     * Re-enable a disabled tooltip\n     */\n    @Method()\n    async enable() {\n        this.tippyInstance.enable();\n    }\n\n    disconnectedCallback() {\n        this.tippyInstance?.destroy();\n    }\n\n    render() {\n        return (\n            <Host role=\"tooltip\">\n                <slot onSlotchange={_ => this.updateTippyContent()}/>\n            </Host>\n        );\n    }\n\n\n}\n"]}