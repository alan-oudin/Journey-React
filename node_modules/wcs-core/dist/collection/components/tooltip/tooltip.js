import { h, Host } from "@stencil/core";
// We use the Tippy.js library for the tooltip. At first by using directly the styles of tippy because
// the design system does not specify any spec for the tooltips.
//
// In a second time, if a need of customization is felt, it will be possible to use the lib in a
// "Headless" mode where the rendering of the tooltip will be entirely in our charge, without
// modifications in the API : https://atomiks.github.io/tippyjs/v6/headless-tippy/
import tippy from "tippy.js";
import { isEscapeKey } from "../../utils/helpers";
import { isMutableAriaAttribute } from "../../utils/mutable-aria-attribute";
/**
 * List of components that require special ARIA attribute delegation handling.
 * These components have their own internal elements (like native button inside wcs-button)
 * that need to receive ARIA attributes for proper accessibility.
 *
 * Another solution we take into account is to @Watch the ARIA attributes on the component and set them on the internal element.
 * But this solution was not centralized and can be forgotten.
 */
const DELEGATED_ARIA_COMPONENTS = ['WCS-BUTTON'];
/**
 * Tooltips are used to provide additional information for features available on the website. These can improve the user
 * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
 * (for longer content).
 *
 * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
 *
 * ## Accessibility guidelines ðŸ’¡
 *
 * The problem is that impaired users may not be able to see what is the information provided by the tooltip. To solve
 * this problem, the tooltip should be served with some aria attributes to make it accessible.
 *
 * Aria-features `wcs-tooltip` respect:
 * - dismiss when the user presses the `Escape` key
 * - has a `role=tooltip`
 * - when set to `interactive` mode
 *  - `aria-expanded` on the targeted element: set to true when popover is open, false when it is closed
 *
 * Aria-features `wcs-tooltip` **does not respect with `wcs-button`**:
 * - aria-controls => we cannot do it yet, we need to wait for Cross root ARIA - export ID (https://github.com/WICG/aom/blob/gh-pages/exportid-explainer.md)
 *
 * But you have to provide the "link" between the element you want to describe and the tooltip. To do this, you have to
 * provide the "visual description" you add on the `wcs-tooltip` to the `aria-label` attribute or the `aria-description` as soon as the attribute will be available
 * of the element you want to describe .
 *
 * Example:
 *
 * ```html
 * <wcs-tooltip for="my-button">Trashed items</wcs-tooltip>
 * <wcs-button id="my-button" aria-label="Trashed items">Trash</wcs-button>
 * ```
 *
 * @cssprop --wcs-tooltip-background-color - Background color of the tooltip
 * @cssprop --wcs-tooltip-text-color - Text color of the tooltip
 * @cssprop --wcs-tooltip-padding - Padding of the tooltip
 */
export class Tooltip {
    constructor() {
        this.for = undefined;
        this.position = 'bottom';
        this.interactive = false;
        this.maxWidth = 350;
        this.delay = 0;
        this.duration = [300, 250];
        this.trigger = 'mouseenter focus';
        this.theme = 'dark';
        this.content = undefined;
        this.appendTo = undefined;
    }
    componentWillLoad() {
        this.forElement = document.getElementById(this.for);
        if (!this.forElement) {
            console.error('[wcs-tooltip]: The element with the id provided in the "for" property does not exist');
            return;
        }
        this.tippyInstance = tippy(this.forElement, {
            appendTo: this.appendTo || (() => document.body),
            theme: this.theme,
            allowHTML: true,
            content: this.getTooltipContentFromPropAndSlot(),
            maxWidth: this.maxWidth,
            placement: this.position,
            delay: this.delay,
            duration: this.duration,
            interactive: this.interactive,
            trigger: this.trigger,
            onShow: () => this.onShow(),
            onHide: () => this.onHide()
        });
    }
    // region Tippy.js events
    // ARIA attributes management ðŸ”
    //
    // While tippy.js automatically handles aria-expanded on the target element, we manage it ourselves for two main reasons:
    // 1. Some of our components (like wcs-button) have an internal structure where the accessible/focusable element
    //    is not the root element. We need to ensure the aria-expanded is set on the correct internal element.
    // 2. We want to maintain consistent control over our ARIA attributes across all components and ensure
    //    they work with our custom MutableAriaAttribute interface.
    onShow() {
        if (!this.forElement) {
            return;
        }
        if (this.forElement.tagName && DELEGATED_ARIA_COMPONENTS.indexOf(this.forElement.tagName) !== -1) {
            if (isMutableAriaAttribute(this.forElement)) {
                if (this.interactive) {
                    this.forElement.setAriaAttribute('aria-expanded', 'true');
                }
            }
        }
    }
    onHide() {
        if (!this.forElement) {
            return;
        }
        if (this.forElement.tagName && DELEGATED_ARIA_COMPONENTS.indexOf(this.forElement.tagName) !== -1) {
            if (isMutableAriaAttribute(this.forElement)) {
                if (this.interactive) {
                    this.forElement.setAriaAttribute('aria-expanded', 'false');
                }
            }
        }
    }
    // endregion
    async handleKeyDown(ev) {
        if (isEscapeKey(ev)) {
            if (this.tippyInstance.state.isShown) {
                await this.hide();
            }
        }
    }
    getTooltipContentFromPropAndSlot() {
        if (this.content) {
            return this.content + this.el.innerHTML;
        }
        return this.el.innerHTML;
    }
    updateProps() {
        var _a;
        (_a = this.tippyInstance) === null || _a === void 0 ? void 0 : _a.setProps({
            interactive: this.interactive,
            placement: this.position,
            maxWidth: this.maxWidth,
            theme: this.theme,
            delay: this.delay,
            duration: this.duration,
            trigger: this.trigger
        });
    }
    updateTippyContent() {
        var _a;
        (_a = this.tippyInstance) === null || _a === void 0 ? void 0 : _a.setProps({
            content: this.getTooltipContentFromPropAndSlot()
        });
    }
    /**
     * Programmatically hide the tooltip
     */
    async hide() {
        this.tippyInstance.hide();
    }
    /**
     * Programmatically show the tooltip
     */
    async show() {
        this.tippyInstance.show();
    }
    /**
     * Temporarily prevent the tooltip from showing or hiding
     */
    async disable() {
        this.tippyInstance.disable();
    }
    /**
     * Re-enable a disabled tooltip
     */
    async enable() {
        this.tippyInstance.enable();
    }
    disconnectedCallback() {
        var _a;
        (_a = this.tippyInstance) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    render() {
        return (h(Host, { key: '34f019e113250ce19d69186080c932f838ac5c86', role: "tooltip" }, h("slot", { key: '7edce2cfc96d454177668c81d615231369600977', onSlotchange: _ => this.updateTippyContent() })));
    }
    static get is() { return "wcs-tooltip"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["tooltip.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["tooltip.css"]
        };
    }
    static get properties() {
        return {
            "for": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "example",
                            "text": "```html\n<span id=\"tooltiped\">Some content</span>\n<wcs-tooltip for=\"tooltiped\">A tooltip!</wcs-tooltip>\n```"
                        }],
                    "text": "The **id** of the element the tooltip's going to describe.\n\nThis property cannot be modified after initialization."
                },
                "attribute": "for",
                "reflect": false
            },
            "position": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsTooltipPosition",
                    "resolved": "\"bottom\" | \"left\" | \"right\" | \"top\"",
                    "references": {
                        "WcsTooltipPosition": {
                            "location": "import",
                            "path": "./tooltip-interface",
                            "id": "src/components/tooltip/tooltip-interface.ts::WcsTooltipPosition"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Where the tooltip is going to show relative to the element it's describing."
                },
                "attribute": "position",
                "reflect": true,
                "defaultValue": "'bottom'"
            },
            "interactive": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside\nwithout hiding."
                },
                "attribute": "interactive",
                "reflect": true,
                "defaultValue": "false"
            },
            "maxWidth": {
                "type": "any",
                "mutable": false,
                "complexType": {
                    "original": "string | number",
                    "resolved": "number | string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.\n\nIf the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.\n\nTo test it on WCS documentation page, add 'px' to the control value (string type in this case)."
                },
                "attribute": "max-width",
                "reflect": false,
                "defaultValue": "350"
            },
            "delay": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number | [number, number]",
                    "resolved": "[number, number] | number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Delay in ms once a trigger event is fired before the tooltip shows or hides.\n\nYou can provide an array with two values to define a different duration for show and hide.\n\n`[showDelay, hideDelay]`\n\nUse null to use default value."
                },
                "attribute": "delay",
                "reflect": false,
                "defaultValue": "0"
            },
            "duration": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number | [number, number]",
                    "resolved": "[number, number] | number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Duration in ms of the transition animation."
                },
                "attribute": "duration",
                "reflect": false,
                "defaultValue": "[300, 250]"
            },
            "trigger": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.\n\nSee: https://atomiks.github.io/tippyjs/v6/all-props/#trigger"
                },
                "attribute": "trigger",
                "reflect": false,
                "defaultValue": "'mouseenter focus'"
            },
            "theme": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "'dark' | 'light'",
                    "resolved": "\"dark\" | \"light\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Allows you to change the theme used by tippy.\n\nThe WCS theme 'dark' is used by default and uses the WCS CSS variables.\n\nYou can create a theme by following this documentation and choosing a custom name :\nhttps://atomiks.github.io/tippyjs/v6/themes/"
                },
                "attribute": "theme",
                "reflect": false,
                "defaultValue": "'dark'"
            },
            "content": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "You can use this property instead of the slot API to affect content in the tooltip.\n\nThis makes it easier to manage the update if the tooltip contains elements that are not mutated when their\ncontent changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM\nchanges (the DOM must be mutated).\n\nThe two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first\ndisplay the content of this property and then the slotted elements."
                },
                "attribute": "content",
                "reflect": false
            },
            "appendTo": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsTooltipAppendTo",
                    "resolved": "\"parent\" | ((ref: Element) => Element) | Element",
                    "references": {
                        "WcsTooltipAppendTo": {
                            "location": "import",
                            "path": "./tooltip-interface",
                            "id": "src/components/tooltip/tooltip-interface.ts::WcsTooltipAppendTo"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true,\nthe default behavior is appendTo: \"parent\"\n\nSee: https://atomiks.github.io/tippyjs/v6/all-props/#appendto"
                },
                "attribute": "append-to",
                "reflect": false
            }
        };
    }
    static get methods() {
        return {
            "hide": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Programmatically hide the tooltip",
                    "tags": []
                }
            },
            "show": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Programmatically show the tooltip",
                    "tags": []
                }
            },
            "disable": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Temporarily prevent the tooltip from showing or hiding",
                    "tags": []
                }
            },
            "enable": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Re-enable a disabled tooltip",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "interactive",
                "methodName": "updateProps"
            }, {
                "propName": "position",
                "methodName": "updateProps"
            }, {
                "propName": "maxWidth",
                "methodName": "updateProps"
            }, {
                "propName": "theme",
                "methodName": "updateProps"
            }, {
                "propName": "delay",
                "methodName": "updateProps"
            }, {
                "propName": "duration",
                "methodName": "updateProps"
            }, {
                "propName": "trigger",
                "methodName": "updateProps"
            }, {
                "propName": "content",
                "methodName": "updateTippyContent"
            }];
    }
    static get listeners() {
        return [{
                "name": "keydown",
                "method": "handleKeyDown",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=tooltip.js.map
