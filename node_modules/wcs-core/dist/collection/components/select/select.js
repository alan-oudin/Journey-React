import { h, Host } from "@stencil/core";
import { interpret, Machine } from "xstate";
import { isWcsSelectSize, WcsDefaultSelectFilterFn, WcsSelectSizeValue } from "./select-interface";
import { SelectArrow } from "./select-arrow";
import { isElement, generateUniqueId, findItemLabel, inheritAriaAttributes, inheritAttributes, setOrRemoveAttribute, compareLists } from "../../utils/helpers";
import { SelectChips } from "./select-chips";
import { createPopper } from "@popperjs/core";
import { isEqual } from "lodash-es";
import { getActionForKeyboardEvent } from "./select-keyboard-event";
import { isFocusable } from "../../utils/accessibility";
const SELECT_MACHINE_CONFIG = {
    key: 'select',
    initial: 'closed',
    states: {
        closed: {
            entry: ['close'],
            on: {
                CLICK: 'opened',
                OPEN: 'opened',
                OPTION_SELECTED: { actions: ['selectOption'] }
            },
        },
        opened: {
            entry: ['open'],
            on: {
                CLICK: 'closed',
                CLOSE: 'closed',
                OPTION_SELECTED: { actions: ['selectOption'] }
            },
        },
    }
};
const SELECT_INHERITED_ATTRS = ['tabindex', 'title'];
/**
 * The select component (also named combobox) is a form component that allows users to select one or more options
 * from a list.
 * Use it with several slotted `wcs-select-option` inside.
 *
 * @slot filter-no-result Contains the customizable "No result found" div (autocomplete mode only).
 *
 * @cssprop --wcs-select-control-arrow-color - Color of the select arrow
 * @cssprop --wcs-select-control-arrow-color-disabled - Color of the select arrow when disabled
 *
 * @cssprop --wcs-select-control-background-color - Background color of the select control
 *
 * @cssprop --wcs-select-control-line-height - Line height of the select control
 *
 * @cssprop --wcs-select-options-padding - Padding of the select options container
 *
 * @cssprop --wcs-select-control-border-radius - Border radius of the select control
 * @cssprop --wcs-select-control-border-width-default - Border width of the select control when not focused
 * @cssprop --wcs-select-control-border-width-focus - Border width of the select control when focused
 *
 * @cssprop --wcs-select-control-border-color-default - Border color of the select control when not focused
 * @cssprop --wcs-select-control-border-color-disabled - Border color of the select control when disabled
 * @cssprop --wcs-select-control-border-color-error - Border color of the select control when error
 * @cssprop --wcs-select-control-border-color-focus - Border color of the select control when focused (not opened, but the control is focused)
 *
 * @cssprop --wcs-select-value-color - Text color of the select value when not focused
 * @cssprop --wcs-select-value-font-weight - Font weight of the select value
 *
 * @cssprop --wcs-select-placeholder-color - Text color of the select placeholder
 * @cssprop --wcs-select-placeholder-font-weight - Font weight of the select placeholder
 * @cssprop --wcs-select-placeholder-font-style - Font style of the select placeholder
 *
 * @cssprop --wcs-select-text-color-disabled - Text color of the select when disabled
 *
 * @cssprop --wcs-select-control-border-style-default - Border style of the select control when not focused
 * @cssprop --wcs-select-control-border-style-focus - Border style of the select control when focused
 * @cssprop --wcs-select-control-border-style-error - Border style of the select control when error
 *
 * @cssprop --wcs-select-control-chips-gap - Gap between chips (only in multiple mode)
 *
 * @cssprop --wcs-select-control-height-m - Height of the select control in medium size
 * @cssprop --wcs-select-control-height-l - Height of the select control in large size
 *
 * @cssprop --wcs-select-control-autocomplete-padding-vertical-m - Padding vertical (top - bottom) of the select control in size m
 * @cssprop --wcs-select-control-autocomplete-padding-vertical-l - Padding vertical (top - bottom) of the select control in size l
 * @cssprop --wcs-select-control-padding-horizontal-m - Padding horizontal (left - right) in medium size
 * @cssprop --wcs-select-control-padding-horizontal-l - Padding horizontal (left - right) in large size
 *
 * @cssprop --wcs-select-control-font-size-m - Font size of the select in size m
 * @cssprop --wcs-select-control-font-size-l - Font size of the select in size m
 *
 *
 * @cssprop --wcs-select-control-chip-color-default - Color default of the select chip
 * @cssprop --wcs-select-control-chip-color-disabled - Color disabled of the select chip
 * @cssprop --wcs-select-control-chip-background-color-default - Background color default of the select chip
 * @cssprop --wcs-select-control-chip-background-color-disabled - Disabled background color of the select chip
 * @cssprop --wcs-select-control-chip-padding-vertical - Padding vertical (top - bottom) of the select chip
 * @cssprop --wcs-select-control-chip-padding-horizontal - Padding horizontal (left - right) of the select chip
 * @cssprop --wcs-select-control-chip-line-height - Line height of the select chip
 * @cssprop --wcs-select-control-chip-border-radius - Border radius of the select chip
 *
 * @cssprop --wcs-select-overlay-max-height - Max height of the select overlay
 * @cssprop --wcs-select-overlay-background-color - Background color of the select overlay
 * @cssprop --wcs-select-overlay-border-width - Border width of the select overlay
 * @cssprop --wcs-select-overlay-border-color - Border color of the select overlay
 * @cssprop --wcs-select-overlay-border-radius - Border radius of the overlay
 */
export class Select {
    constructor() {
        this.inheritedAttributes = {};
        this.selectId = `wcs-select-${selectIds++}`;
        this.optionsId = generateUniqueId("OPTIONS");
        this.expanded = false;
        this.size = 'm';
        this.displayText = undefined;
        this.focused = undefined;
        this.value = undefined;
        this.placeholder = undefined;
        this.disabled = false;
        this.required = false;
        this.multiple = false;
        this.autocomplete = false;
        this.serverMode = false;
        this.filterFn = undefined;
        this.chips = false;
        this.name = undefined;
        this.compareWith = (optionValue, selectedValue) => isEqual(optionValue, selectedValue);
        this.showNoResultFoundLabel = false;
        this.autocompleteValue = undefined;
        this.overlayDirection = 'bottom';
    }
    /** Open the component. */
    async open() {
        this.stateService.send('OPEN');
    }
    /** Close the component. */
    async close() {
        this.stateService.send('CLOSE');
    }
    onValueChangeHandler(newValue) {
        this.updateSelectedValue(newValue);
    }
    /**
     * Updates the selected value(s) of the component and manages the internal state accordingly
     *
     * @param value - The value(s) to be selected in the component
     *                For single selection mode: any value that matches an option's value
     *                For multiple selection mode: a single value or an array of values
     * @param resetIfNoValue - When true and no value is provided, the select component will be reset
     *                        Defaults to true
     */
    updateSelectedValue(value, resetIfNoValue = true) {
        var _a;
        // If no value is passed, the select is reset.
        if (!value && resetIfNoValue) {
            this.reset();
        }
        if (this.multiple) {
            // If user don't give an array, we provide one
            if (!Array.isArray(value)) {
                value = [value];
            }
            // We assume that the last modified option in multiple mode is the last one in the array
            this.lastModifiedOptionElement = value.length > 0 ? (_a = Array.from(this.options).find(opt => this.compareWith(opt.value, value[value.length - 1]))) !== null && _a !== void 0 ? _a : null : null;
            if (this.serverMode) {
                // in server mode, we don't know all the possible select options, so we assume the value is correct,
                // and we just sync the displayText and current available options
                const compareResult = compareLists(this.values.map(v => v.value), value, this.compareWith);
                compareResult.added.forEach(addedOption => {
                    const option = Array.from(this.options).find(opt => this.compareWith(opt.value, addedOption));
                    if (option) {
                        this.values.push({
                            value: option.value,
                            displayText: option.innerText,
                            chipColor: option.chipColor,
                            chipBackgroundColor: option.chipBackgroundColor
                        });
                        option.selected = true;
                    }
                });
                // We update the selected options when the slot changes to keep the selected options in sync with the current value
                compareResult.kept.forEach((keptOption) => {
                    const option = Array.from(this.options).find(opt => this.compareWith(opt.value, keptOption));
                    if (option) {
                        option.selected = true;
                    }
                });
                compareResult.removed.forEach(removedOption => {
                    this.values = this.values.filter(v => !this.compareWith(v.value, removedOption));
                    const removedOptionElement = Array.from(this.options).find(opt => this.compareWith(opt.value, removedOption));
                    if (removedOptionElement) {
                        removedOptionElement.selected = false;
                    }
                });
            }
            else {
                this.values = [];
                this.options.forEach((opt) => {
                    const isSelected = value ?
                        value.findIndex(v => this.compareWith(opt.value, v)) !== -1
                        : false;
                    if (isSelected) {
                        this.values.push({
                            value: opt.value,
                            displayText: opt.innerText,
                            chipColor: opt.chipColor,
                            chipBackgroundColor: opt.chipBackgroundColor
                        });
                    }
                    opt.selected = isSelected;
                });
            }
            // update select placeholder text
            this.displayText = this.values.length !== 0
                ? this.values.map(v => v.displayText).join(', ')
                : undefined;
        }
        else {
            this.options.forEach((opt) => {
                const isSelected = this.compareWith(opt.value, value);
                if (isSelected) {
                    this.displayText = opt.innerText;
                    this.lastModifiedOptionElement = opt;
                    if (this.autocomplete) {
                        this.setAutocompleteValue(opt.innerText);
                    }
                }
                opt.selected = isSelected;
            });
        }
    }
    /**
     * Reset the select: unselects all options for multiple mode and displays the placeholder
     * @private
     */
    reset() {
        this.values = [];
        this.displayText = undefined;
        if (this.autocomplete) {
            // When need to reset the internal filter state of the component as the mutation of 
            // autocompleteValue from the code doesn't call onAutocompleteInputEvent method.
            this.setAutocompleteValue('', true);
        }
        this.options.forEach((opt) => {
            opt.selected = false;
        });
    }
    componentDidLoad() {
        this.optionsEl = this.el.shadowRoot.querySelector('.wcs-select-options');
        this.controlEl = this.el.shadowRoot.querySelector('.wcs-select-control');
        const stateMachine = Machine(SELECT_MACHINE_CONFIG, this.initMachineOptions());
        // FIXME: type checking failed...
        // @ts-ignore
        this.stateService = interpret(stateMachine);
        if (this.multiple) {
            this.values = [];
        }
        this.stateService.start();
        if (this.optionsEl.querySelector('slot') === null) {
            this.replaceOptions_firefoxBefore63();
            this.listenDomUpdate_firefoxBefore63();
        }
        if (this.value !== undefined) {
            this.updateSelectedValue(this.value);
        }
        this.popper = this.createPopperInstance();
        // if the select is inside a wcs-form-field, we set an id to the wcs-label if present
        // the wcs-label element reference is kept to compute aria-label value during the rendering
        this.labelElement = findItemLabel(this.el);
        if (this.labelElement) {
            this.labelElement.id = this.selectId + "-lbl";
        }
    }
    createPopperInstance() {
        return createPopper(this.controlEl, this.optionsEl, {
            placement: "bottom",
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 4] // we want 4px between select control and select options
                    }
                }
            ]
        });
    }
    emitChange(newValue) {
        this.wcsChange.emit({
            value: newValue
        });
    }
    replaceOptions_firefoxBefore63() {
        Array.from(this.el.querySelectorAll('wcs-select-option'))
            .forEach(option => {
            if (option.parentNode === this.el) {
                this.el.removeChild(option);
                this.optionsEl.appendChild(option);
            }
        });
    }
    listenDomUpdate_firefoxBefore63() {
        const observer = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    this.replaceOptions_firefoxBefore63();
                }
            }
        });
        observer.observe(this.el, { childList: true });
    }
    componentWillRender() {
        if (this.multiple) {
            this.options
                .forEach((opt) => opt.multiple = true);
        }
    }
    componentWillLoad() {
        if (!isWcsSelectSize(this.size)) {
            console.warn(`Invalid size value for wcs-select : "${this.size}". Must be one of "${WcsSelectSizeValue.join(', ')}"`);
            this.size = "m"; // Default fallback value
        }
        // XXX : special case on this component for attribute inheritance
        // We only move attributes on the native input when autocomplete is true.
        // Otherwise, all attributes are on the Host, so we do not need to inherit those.
        if (this.autocomplete) {
            this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, SELECT_INHERITED_ATTRS));
        }
    }
    async setAriaAttribute(attr, value) {
        if (this.autocomplete === false) {
            setOrRemoveAttribute(this.el, attr, value);
        }
        else {
            setOrRemoveAttribute(this.autocompleteInput, attr, value);
        }
    }
    get options() {
        var _a;
        const opts = (_a = this.el) === null || _a === void 0 ? void 0 : _a.querySelectorAll('wcs-select-option');
        if (opts && opts.length !== 0) {
            return opts;
        }
        return [];
    }
    get notDisabledOptions() {
        var _a;
        const opts = (_a = this.el) === null || _a === void 0 ? void 0 : _a.querySelectorAll('wcs-select-option:not([disabled]):not([aria-hidden])');
        if (opts && opts.length !== 0) {
            return opts;
        }
        return [];
    }
    initMachineOptions() {
        return {
            actions: {
                open: () => {
                    var _a;
                    if (!this.disabled) {
                        this.expanded = true;
                        this.focused = false;
                        if (this.multiple === false && this.autocomplete && this.hasValue === false) {
                            // If we open the select in single autocomplete mode, we update the autocomplete value at 
                            // the blur event so that the displayed value reflect the current select value. 
                            // Indeed, we have to tell the component to take the current filter state manually at the 
                            // opening (because the input event of the autocomplete field is not fired at this point).
                            if (this.autocompleteValue && this.autocompleteValue !== '') {
                                this.setAutocompleteValue(this.autocompleteValue);
                            }
                        }
                        this.clearHighlightOnLastHighlightedOption();
                        if (this.notDisabledOptions.length > 0) {
                            this.lastFocusedOptionElement = (_a = this.lastModifiedOptionElement) !== null && _a !== void 0 ? _a : this.notDisabledOptions[0];
                            requestAnimationFrame(() => {
                                var _a, _b;
                                this.autocomplete
                                    ? (_a = this.autocompleteInput) === null || _a === void 0 ? void 0 : _a.focus()
                                    : (_b = this.lastFocusedOptionElement) === null || _b === void 0 ? void 0 : _b.focus();
                            });
                        }
                    }
                },
                close: (_, event) => {
                    var _a, _b;
                    if (event.type === 'CLOSE') {
                        this.clearHighlightOnLastHighlightedOption();
                        if ((_a = event.value) === null || _a === void 0 ? void 0 : _a.shouldBlur) {
                            this.focused = false;
                        }
                        else {
                            if (this.autocomplete && ((_b = event.value) === null || _b === void 0 ? void 0 : _b.fromKeyboard)) {
                                // If we're in autocomplete mode, a keyboard event (e.g. escape) doesn't change the 
                                // focus (so this.el.focus() aren't called because the select was already focused)
                                // but you still have to go back to the autocomplete input.
                                this.focusAutocompleteInput();
                            }
                            else {
                                // Otherwise, we focus the select element
                                this.el.focus();
                            }
                            this.focused = true;
                        }
                    }
                    this.expanded = false;
                },
                selectOption: (_, event) => {
                    if (event.type === 'OPTION_SELECTED') {
                        if (this.multiple) {
                            this.handleOptionSelectedOnMultiple(event.value.option);
                        }
                        else {
                            this.handleOptionSelectedOnSingle(event.value.option);
                            this.stateService.send('CLOSE', { value: { fromKeyboard: event.value.fromKeyboard } });
                        }
                        if (this.autocomplete) {
                            if (this.multiple) {
                                requestAnimationFrame(() => {
                                    this.autocompleteInput.focus();
                                });
                            }
                            else {
                                this.autocompleteValue = event.value.option.displayText;
                            }
                        }
                        this.emitChange(this.value);
                    }
                }
            },
            guards: {
                enabled: () => !this.disabled
            }
        };
    }
    handleOptionSelectedOnMultiple(event) {
        const index = this.values.findIndex(v => this.compareWith(v.value, event.value));
        if (index === -1) {
            // this will trigger the watch on value and update the values model
            this.value = [...this.values.map(v => v.value), event.value];
        }
        else {
            // this will trigger the watch on value and update the values model
            this.value = this.values.filter(v => !this.compareWith(v.value, event.value)).map(v => v.value);
        }
    }
    handleOptionSelectedOnSingle(event) {
        this.value = event.value;
    }
    disconnectedCallback() {
        var _a;
        (_a = this.stateService) === null || _a === void 0 ? void 0 : _a.stop();
    }
    get hasValue() {
        // TODO: change this behavior.
        return this.displayText !== undefined;
    }
    onMouseUp(event) {
        const clickOnScroll = isElement(event.target)
            && (event.offsetX > event.target.clientWidth
                || event.offsetY > event.target.clientHeight // If the click il located bellow the component height the click happen in the overlay
                || event.offsetY < 0); // If the click is made above the component
        const clickOnRemoveChip = event.composedPath()
            .filter(x => {
            const el = x;
            return el.nodeName === 'svg' && el.classList.contains('chip');
        })
            .length > 0;
        if (!clickOnScroll && !clickOnRemoveChip) {
            this.stateService.send('CLICK');
        }
    }
    onWindowClickEvent(event) {
        const firstSelectInEventPath = event.composedPath().filter(x => x.nodeName === 'WCS-SELECT')[0];
        const clickOnCurrentSelect = firstSelectInEventPath === this.el;
        // TODO: Move this logic in the state machine
        // FIXME: Doesnt work with single + disabled option
        if (this.expanded && !clickOnCurrentSelect) {
            this.stateService.send({ type: 'CLOSE', value: { shouldBlur: true, fromKeyboard: false } });
        }
    }
    onKeyDown(_event) {
        const currentState = this.stateService.getSnapshot().matches("closed") ? 'closed' : 'opened';
        let type;
        if (this.autocomplete) {
            type = this.multiple ? 'autocomplete_multiple' : 'autocomplete_unique';
        }
        else {
            type = this.multiple ? 'multiple' : 'unique';
        }
        const actionsFromKeyboardEvents = getActionForKeyboardEvent(_event, currentState, type);
        // If we have at least one associated actions, we prevent the default behavior of the event. 
        // Except if the action is a focus move (we have to handle the preventDefault behavior ourselves in the action implementation)
        if (actionsFromKeyboardEvents.length != 0 && actionsFromKeyboardEvents.filter(a => a.kind === 'MoveFocus').length === 0) {
            _event.preventDefault();
        }
        for (const actionFromKeyboardEvent of actionsFromKeyboardEvents) {
            this.doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent, _event);
        }
    }
    doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent, event) {
        var _a, _b;
        switch (actionFromKeyboardEvent.kind) {
            case "CloseSelect":
                this.stateService.send({
                    type: 'CLOSE',
                    value: { shouldBlur: actionFromKeyboardEvent.shouldBlur, fromKeyboard: true }
                });
                break;
            case "OpenSelect":
                this.stateService.send('OPEN');
                break;
            case "SelectOption":
                switch (actionFromKeyboardEvent.target) {
                    case "next":
                        this.selectClosestOption('next');
                        break;
                    case "previous":
                        this.selectClosestOption('previous');
                        break;
                    case "first":
                        this.selectFirstOption();
                        break;
                    case "last":
                        this.selectLastOption();
                        break;
                    case "lastHighlighted": {
                        // We have to handle enterKey here because with autocomplete mode, a wcs-select-option
                        // is only highlighted, therefore the event is not fired
                        const indexToSelect = Array.from(this.notDisabledOptions).indexOf(this.lastHighlightedOptionElement);
                        if (indexToSelect !== -1) {
                            this.lastModifiedOptionElement = this.lastHighlightedOptionElement;
                            this.selectOption(indexToSelect, true);
                        }
                        break;
                    }
                }
                break;
            case "ClearAutocompleteInput":
                this.autocompleteValue = '';
                break;
            case "ClearHighlight":
                this.clearHighlightOnLastHighlightedOption();
                break;
            case "HighlightOption":
                switch (actionFromKeyboardEvent.target) {
                    case "next":
                        this.highlightClosestOption('next');
                        break;
                    case "previous":
                        this.highlightClosestOption('previous');
                        break;
                    case "first":
                        this.highlightFirstOption();
                        break;
                    case "last":
                        this.highlightLastOption();
                        break;
                    default:
                        break;
                }
                break;
            case "FocusOption":
                switch (actionFromKeyboardEvent.target) {
                    case "next":
                        this.focusClosestOption('next');
                        break;
                    case "previous":
                        this.focusClosestOption('previous');
                        break;
                    case "first":
                        this.focusFirstOption();
                        break;
                    case "last":
                        this.focusLastOption();
                        break;
                    case "lastFocused":
                        if (this.lastFocusedOptionElement != null) {
                            this.focusOption(Array.from(this.notDisabledOptions).indexOf(this.lastFocusedOptionElement));
                        }
                        break;
                    default:
                        break;
                }
                break;
            case "MoveFocus":
                switch (actionFromKeyboardEvent.target) {
                    case "previous": {
                        let elementToFocus = (_a = this.el.previousElementSibling) !== null && _a !== void 0 ? _a : this.el.parentElement;
                        while (elementToFocus) {
                            if (isFocusable(elementToFocus))
                                break;
                            elementToFocus = (_b = elementToFocus.previousElementSibling) !== null && _b !== void 0 ? _b : elementToFocus.parentElement;
                        }
                        if (elementToFocus) {
                            event.preventDefault();
                            elementToFocus.focus();
                        }
                        break;
                    }
                    default:
                        break;
                }
                break;
            default:
                throw new Error("Internal error");
        }
    }
    getClosestActiveOptionIndexForState(direction, state) {
        let concernedOption;
        switch (state) {
            case 'focused':
                concernedOption = this.lastFocusedOptionElement;
                break;
            case 'modified':
                concernedOption = this.lastModifiedOptionElement;
                break;
            case 'highlighted':
                concernedOption = this.lastHighlightedOptionElement;
                break;
            default:
                concernedOption = null;
        }
        let currentIndex = Array.from(this.notDisabledOptions).indexOf(concernedOption);
        const MIN_INDEX = 0;
        const MAX_INDEX = this.notDisabledOptions.length - 1;
        if (direction === 'next' && currentIndex < MAX_INDEX) {
            currentIndex++;
        }
        else if (direction === 'previous' && currentIndex > MIN_INDEX) {
            currentIndex--;
        }
        else {
            if (!this.autocomplete)
                return 'nothing';
            // Used to scroll options infinitely with keyboard (autocomplete mode only)
            if (direction === 'next' && currentIndex >= MAX_INDEX) {
                currentIndex = 0;
            }
            if (direction === 'previous' && currentIndex === MIN_INDEX) {
                currentIndex = MAX_INDEX;
            }
        }
        return currentIndex;
    }
    /**
     * Selects the non-disabled option with the index passed as a parameter.
     * The method sends an event to the state machine (the same as when clicking on an option with the mouse)
     * @param indexToSelect Option index within non-deactivated options list
     * @param fromKeyboard
     * @private
     */
    selectOption(indexToSelect, fromKeyboard = false) {
        const optionToSelect = this.notDisabledOptions[indexToSelect];
        if (!optionToSelect)
            return;
        this.sendOptionSelectedToStateMachine({
            source: optionToSelect,
            value: optionToSelect.value,
            displayText: optionToSelect.innerText
        }, fromKeyboard);
    }
    selectClosestOption(direction) {
        const indexToSelect = this.getClosestActiveOptionIndexForState(direction, 'modified');
        if (indexToSelect === 'nothing')
            return;
        this.selectOption(indexToSelect, true);
    }
    selectFirstOption() {
        if (this.notDisabledOptions.length < 1) {
            return;
        }
        this.selectOption(0, true);
    }
    selectLastOption() {
        if (this.notDisabledOptions.length < 1) {
            return;
        }
        this.selectOption(this.notDisabledOptions.length - 1, true);
    }
    focusOption(indexToFocus) {
        var _a;
        this.lastFocusedOptionElement = this.notDisabledOptions[indexToFocus];
        (_a = this.lastFocusedOptionElement) === null || _a === void 0 ? void 0 : _a.focus();
        this.el.setAttribute("aria-activedescendant", this.lastFocusedOptionElement.id);
    }
    focusClosestOption(direction) {
        const indexToFocus = this.getClosestActiveOptionIndexForState(direction, 'focused');
        if (indexToFocus === 'nothing')
            return;
        this.focusOption(indexToFocus);
    }
    focusFirstOption() {
        this.focusOption(0);
    }
    focusLastOption() {
        this.focusOption(this.notDisabledOptions.length - 1);
    }
    selectedOptionChanged(event) {
        this.sendOptionSelectedToStateMachine(event.detail);
    }
    sendOptionSelectedToStateMachine(event, fromKeyboard = false) {
        this.stateService.send({ type: 'OPTION_SELECTED', value: { option: event, fromKeyboard } });
    }
    onSlotchange() {
        // We call updateSelectedValue to update the selected options when the slot changes to keep the selected options in sync with the current value.
        // This also update the displayText value according to the options data.
        // Finally, this update the internal models for multiple mode and handle the server mode correctly.
        this.updateSelectedValue(this.value, false);
        // Server-mode only : "no result" slot should be visible dynamically if no option is present in the slot
        if (this.autocomplete && this.serverMode) {
            this.showNoResultFoundLabel = this.options.length < 1;
        }
        if (this.multiple) {
            this.options
                .forEach((opt) => opt.multiple = true);
        }
    }
    removeChip(v) {
        this.options
            .forEach(opt => {
            if (opt.value === v.value) {
                this.sendOptionSelectedToStateMachine(Object.assign(Object.assign({}, v), { source: opt }));
            }
        });
    }
    //region Autocomplete mode
    highlightOption(indexToHighlight) {
        this.clearHighlightOnLastHighlightedOption();
        this.lastHighlightedOptionElement = this.notDisabledOptions[indexToHighlight];
        if (this.lastHighlightedOptionElement) {
            this.lastHighlightedOptionElement.highlighted = true;
            this.autocompleteInput.setAttribute("aria-activedescendant", this.lastHighlightedOptionElement.id);
            requestAnimationFrame(() => {
                this.lastHighlightedOptionElement.scrollIntoView({ block: "nearest", inline: "nearest" });
            });
        }
    }
    highlightFirstOption() {
        this.highlightOption(0);
    }
    highlightLastOption() {
        this.highlightOption(this.notDisabledOptions.length - 1);
    }
    highlightClosestOption(direction) {
        const indexToHighlight = this.getClosestActiveOptionIndexForState(direction, 'highlighted');
        if (indexToHighlight === 'nothing')
            return;
        this.highlightOption(indexToHighlight);
    }
    /**
     * This method removes the highlight that applies to the last highlighted option if any.
     * This is used only for accessibility of autocomplete mode.
     * @private
     */
    clearHighlightOnLastHighlightedOption() {
        if (this.lastHighlightedOptionElement) {
            this.lastHighlightedOptionElement.highlighted = false;
            this.lastHighlightedOptionElement = null;
        }
    }
    onAutocompleteInputEvent(e) {
        var _a;
        const filter = (_a = this.autocompleteInput.value) !== null && _a !== void 0 ? _a : '';
        this.setAutocompleteValue(filter, false, true); // fromUserInteraction = true
        // Avoid the inputEvent event to bubble and be emitted, we rather use wcsFilterChange in this case :
        e.stopPropagation();
    }
    /**
     * Set the autocomplete value and open the select if needed.
     * @param filter - The new filter value
     * @param isReset - If true, the filter is reset and the select is closed
     * @param fromUserInteraction - If true, the change comes from user interaction (typing), if false it's programmatic
     * @private
     */
    setAutocompleteValue(filter, isReset = false, fromUserInteraction = false) {
        var _a, _b;
        this.clearHighlightOnLastHighlightedOption();
        const newValueIsDifferentFromLastModifiedOption = this.lastModifiedOptionElement == null || ((_a = this.lastModifiedOptionElement) === null || _a === void 0 ? void 0 : _a.textContent) !== this.autocompleteValue;
        // Only open the select automatically when the change comes from user interaction
        if (!this.expanded && newValueIsDifferentFromLastModifiedOption && !isReset && fromUserInteraction) {
            this.open();
        }
        // Prevents client-side filtering logic from being applied when serverMode is enabled.
        if (!this.serverMode) {
            if (filter.length) {
                const [matchingOptions, optionsToHide] = [[], []];
                const filteringFunction = (_b = this.filterFn) !== null && _b !== void 0 ? _b : WcsDefaultSelectFilterFn;
                this.options.forEach((optionEl) => (filteringFunction(optionEl, filter) ? matchingOptions : optionsToHide).push(optionEl));
                this.showNoResultFoundLabel = matchingOptions.length === 0;
                matchingOptions.forEach(o => {
                    o.hidden = false;
                    o.removeAttribute("aria-hidden");
                });
                optionsToHide.forEach(o => {
                    o.hidden = true;
                    o.setAttribute("aria-hidden", "true");
                });
            }
            else {
                this.showNoResultFoundLabel = false;
                this.options.forEach(o => {
                    o.hidden = false;
                    o.removeAttribute("aria-hidden");
                });
            }
        }
        if (this.autocompleteValue !== filter) {
            this.autocompleteValue = filter !== null && filter !== void 0 ? filter : '';
            this.wcsFilterChange.emit({
                value: filter,
            });
        }
    }
    onFocus(event) {
        if (this.autocomplete) {
            this.focusAutocompleteInput();
        }
        this.wcsFocus.emit(event);
    }
    focusAutocompleteInput() {
        var _a;
        (_a = this.autocompleteInput) === null || _a === void 0 ? void 0 : _a.focus();
    }
    //endregion
    onBlur(event) {
        // Avoid emitting a wcsBlur event when the relatedTarget of the blur event is a child or the select itself
        const target = event.relatedTarget;
        if (this.el.contains(target)) {
            return;
        }
        this.wcsBlur.emit(event);
    }
    componentDidRender() {
        var _a;
        (_a = this.popper) === null || _a === void 0 ? void 0 : _a.update();
    }
    focusedAttributes() {
        return !this.disabled ? { tabIndex: 0 } : {};
    }
    onAutocompleteFieldBlur(_e) {
        if (this.multiple === false && this.autocomplete === true && this.hasValue) {
            this.autocompleteValue = this.displayText;
        }
    }
    render() {
        var _a;
        const ariaLabelValue = `${this.labelElement ? this.labelElement.innerText : ''} ${this.hasValue ? this.displayText : ''}`.trimEnd();
        const noResultContainerId = 'no-result-container';
        return (h(Host, Object.assign({ key: '71154caab9c0b2244716f5c5626cc0de3ed7d327', class: this.expanded ? 'expanded ' : '', overlayDirection: this.overlayDirection }, this.focusedAttributes(), { role: !this.autocomplete ? "combobox" : null, "aria-haspopup": !this.autocomplete ? "listbox" : null, "aria-owns": !this.autocomplete ? this.optionsId : null, "aria-controls": !this.autocomplete ? this.optionsId : null, "aria-disabled": !this.autocomplete ? (this.disabled ? 'true' : null) : null, "aria-required": !this.autocomplete ? (this.required ? 'true' : 'false') : null, "aria-expanded": !this.autocomplete ? (this.expanded ? 'true' : 'false') : null, "aria-multiselectable": !this.autocomplete ? (this.multiple ? 'true' : 'false') : null, "aria-label": !this.autocomplete ? ariaLabelValue : null }), h("div", { key: '2dff342eb864a28ac960583102de88cfd7f63d98', class: "wcs-select-control" }, h("div", { key: '0f2028f2eb8245fa08da06ccebbfbac880d0e090', class: "wcs-select-value-container" }, this.hasValue
            ?
                (this.chips ?
                    this.values.map((option) => h(SelectChips, { disabled: this.disabled, option: option, onRemove: this.removeChip.bind(this) }))
                    : (!this.autocomplete || this.autocomplete && this.multiple) &&
                        h("label", { class: "wcs-select-value" }, this.displayText))
            : !this.autocomplete && h("label", { class: "wcs-select-placeholder" }, this.placeholder), this.autocomplete && h("input", Object.assign({ key: '000f05300690b402f77b210b4e6808e73647d607', class: "autocomplete-field", value: this.autocompleteValue, role: "combobox", "aria-haspopup": "listbox", "aria-label": ariaLabelValue, "aria-describedby": noResultContainerId, "aria-disabled": this.disabled ? 'true' : null, "aria-expanded": this.expanded ? 'true' : 'false', "aria-controls": this.optionsId, "aria-owns": this.optionsId, "aria-multiselectable": this.multiple ? 'true' : 'false', "aria-autocomplete": "list", autocomplete: "off", disabled: this.disabled, required: this.required, onBlur: (e) => this.onAutocompleteFieldBlur(e), placeholder: ((_a = this.values) === null || _a === void 0 ? void 0 : _a.length) ? null : this.placeholder, onInput: (e) => this.onAutocompleteInputEvent(e), ref: el => this.autocompleteInput = el }, this.inheritedAttributes))), h(SelectArrow, { key: 'cbbb2ef8b0c49b69c2a3509e6444f52d114efd23', up: this.expanded })), h("div", { key: '9330811ed0b8e0a2380692cdca34f2196b087466', class: "wcs-select-options", id: this.optionsId, role: "listbox" }, h("slot", { key: '9efd1b1d83e7bc1af1733909060854025c21df07', name: "options", onSlotchange: this.onSlotchange.bind(this) }), (this.autocomplete && this.showNoResultFoundLabel) &&
            h("div", { key: 'a8438df62c26f1d4cfcd25c43d5636031138c71f', role: "alert", id: noResultContainerId, class: "noresult-container" }, h("slot", { key: '95397947cdef93512fec2c168ca42893500950ba', name: "filter-no-result" }, h("span", { key: 'd5fc78e9ba099a017f6ed3116b23aa929c34dcb9' }, "Aucun r\u00E9sultat"))))));
    }
    static get is() { return "wcs-select"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["select.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["select.css"]
        };
    }
    static get properties() {
        return {
            "size": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsSelectSize",
                    "resolved": "\"l\" | \"m\"",
                    "references": {
                        "WcsSelectSize": {
                            "location": "import",
                            "path": "./select-interface",
                            "id": "src/components/select/select-interface.ts::WcsSelectSize"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify the size (height) of the select."
                },
                "attribute": "size",
                "reflect": true,
                "defaultValue": "'m'"
            },
            "value": {
                "type": "any",
                "mutable": true,
                "complexType": {
                    "original": "any | null",
                    "resolved": "any",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The currently selected value."
                },
                "attribute": "value",
                "reflect": false
            },
            "placeholder": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "string | null",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The text to display when the select is empty."
                },
                "attribute": "placeholder",
                "reflect": true
            },
            "disabled": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, the user cannot interact with the select."
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            },
            "required": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, the user must fill in a value before submitting a form."
                },
                "attribute": "required",
                "reflect": true,
                "defaultValue": "false"
            },
            "multiple": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, the user can select multiple values at once."
                },
                "attribute": "multiple",
                "reflect": true,
                "defaultValue": "false"
            },
            "autocomplete": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, the select acts as an autocomplete field to filter your results."
                },
                "attribute": "autocomplete",
                "reflect": true,
                "defaultValue": "false"
            },
            "serverMode": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "**Only works with `autocomplete` mode.**  \nIf `true`, the server mode disables the client-side filtering on your select and allows you to handle\nwhich options should be present in your DOM."
                },
                "attribute": "server-mode",
                "reflect": true,
                "defaultValue": "false"
            },
            "filterFn": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "WcsSelectFilterFn",
                    "resolved": "(optionEl: HTMLWcsSelectOptionElement, filter: string) => boolean",
                    "references": {
                        "WcsSelectFilterFn": {
                            "location": "import",
                            "path": "./select-interface",
                            "id": "src/components/select/select-interface.ts::WcsSelectFilterFn"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "**Only works with `autocomplete` mode.**  \nCustomizable sort function to change the comparison of values. If not provided, uses the default behavior :\n`option.textContent.toLowerCase().startsWith(filter.toLowerCase())`"
                }
            },
            "chips": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, selected items are shown in chips mode."
                },
                "attribute": "chips",
                "reflect": true,
                "defaultValue": "false"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The name of the control, which is submitted with the form data."
                },
                "attribute": "name",
                "reflect": false
            },
            "compareWith": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "(optionValue: any, selectedValue: any) => boolean",
                    "resolved": "(optionValue: any, selectedValue: any) => boolean",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Function used to compare options, default : deep comparison."
                },
                "defaultValue": "(optionValue, selectedValue) => isEqual(optionValue, selectedValue)"
            }
        };
    }
    static get states() {
        return {
            "expanded": {},
            "displayText": {},
            "focused": {},
            "showNoResultFoundLabel": {},
            "autocompleteValue": {},
            "overlayDirection": {}
        };
    }
    static get events() {
        return [{
                "method": "wcsChange",
                "name": "wcsChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the value has changed."
                },
                "complexType": {
                    "original": "SelectChangeEventDetail",
                    "resolved": "SelectChangeEventDetail",
                    "references": {
                        "SelectChangeEventDetail": {
                            "location": "import",
                            "path": "./select-interface",
                            "id": "src/components/select/select-interface.ts::SelectChangeEventDetail"
                        }
                    }
                }
            }, {
                "method": "wcsFocus",
                "name": "wcsFocus",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the select has focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }, {
                "method": "wcsBlur",
                "name": "wcsBlur",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the select loses focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }, {
                "method": "wcsFilterChange",
                "name": "wcsFilterChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the autocomplete filter has changed."
                },
                "complexType": {
                    "original": "SelectFilterChangeEventDetail",
                    "resolved": "SelectFilterChangeEventDetail",
                    "references": {
                        "SelectFilterChangeEventDetail": {
                            "location": "import",
                            "path": "./select-interface",
                            "id": "src/components/select/select-interface.ts::SelectFilterChangeEventDetail"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "open": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Open the component.",
                    "tags": []
                }
            },
            "close": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Close the component.",
                    "tags": []
                }
            },
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "value",
                "methodName": "onValueChangeHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "mouseup",
                "method": "onMouseUp",
                "target": undefined,
                "capture": false,
                "passive": true
            }, {
                "name": "click",
                "method": "onWindowClickEvent",
                "target": "window",
                "capture": false,
                "passive": false
            }, {
                "name": "keydown",
                "method": "onKeyDown",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "wcsSelectOptionClick",
                "method": "selectedOptionChanged",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "focus",
                "method": "onFocus",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "blur",
                "method": "onBlur",
                "target": undefined,
                "capture": true,
                "passive": false
            }];
    }
}
let selectIds = 0;
//# sourceMappingURL=select.js.map
