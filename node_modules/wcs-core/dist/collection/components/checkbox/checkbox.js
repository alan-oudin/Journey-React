import { h, Host } from "@stencil/core";
import { inheritAriaAttributes, inheritAttributes, setOrRemoveAttribute } from "../../utils/helpers";
import { getSlottedContentText } from "../../utils/control-component-interface";
const CHECKBOX_INHERITED_ATTRS = ['tabindex', 'title'];
/**
 * The checkbox component is an input for choosing one or more items from a set by checking / unchecking it.
 *
 * @cssprop --wcs-checkbox-border-color-default - Default color of the border
 * @cssprop --wcs-checkbox-border-color-hover - Color of the border when hovered
 * @cssprop --wcs-checkbox-border-color-disabled - Color of the border when disabled
 * @cssprop --wcs-checkbox-border-color-selected - Color of the border when selected
 * @cssprop --wcs-checkbox-border-color-indeterminate - Color of the border when indeterminate
 *
 * @cssprop --wcs-checkbox-border-radius - Border radius of the checkbox
 * @cssprop --wcs-checkbox-border-width - Width of the border of the checkbox
 *
 * @cssprop --wcs-checkbox-size - Size of the checkbox
 *
 * @cssprop --wcs-checkbox-text-color-default - Color of the text when the checkbox is not selected
 * @cssprop --wcs-checkbox-text-color-disabled - Color of the text when the checkbox is disabled
 * @cssprop --wcs-checkbox-text-color-hover - Color of the text when the checkbox is hovered
 * @cssprop --wcs-checkbox-text-color-selected - Color of the text when the checkbox is selected
 *
 * @cssprop --wcs-checkbox-text-font-size - Font size of the text
 * @cssprop --wcs-checkbox-text-font-weight - Font weight of the text
 *
 * @cssprop --wcs-checkbox-background-color-default - Default background color of the checkbox
 * @cssprop --wcs-checkbox-background-color-hover - Background color of the checkbox when hovered
 * @cssprop --wcs-checkbox-background-color-disabled - Background color of the checkbox when disabled
 * @cssprop --wcs-checkbox-background-color-selected - Background color of the checkbox when selected
 * @cssprop --wcs-checkbox-background-color-indeterminate - Background color of the checkbox when indeterminate
 *
 * @cssprop --wcs-checkbox-outline-radius-focus - Border radius of the focus outline
 * @cssprop --wcs-checkbox-outline-color-focus - Color of the focus outline
 *
 * @cssprop --wcs-checkbox-gap - Gap between the checkbox and the label
 * @cssprop --wcs-checkmark-color - Color of the checkmark
 * @cssprop --wcs-checkmark-height - Height of the checkmark (From the bottom left to the top right of the checkmark)
 * @cssprop --wcs-checkmark-width - Width of the checkmark (From the bottom right to the top left of the checkmark)
 * @cssprop --wcs-checkmark-border-width - Width of the border of the checkmark
 *
 * @cssprop --wcs-indeterminate-bar-width - Width of the indeterminate bar
 * @cssprop --wcs-indeterminate-bar-height - Height of the indeterminate bar
 * @cssprop --wcs-indeterminate-bar-border-radius - Border-radius of the indeterminate bar
 * @cssprop --wcs-indeterminate-bar-background-color - Color of the indeterminate bar
 *
 * @cssprop --wcs-checkbox-transition-duration - Duration of the transition
 */
export class Checkbox {
    constructor() {
        this.inheritedAttributes = {};
        this.checkboxId = `wcs-checkbox-${checkboxIds++}`;
        this.name = this.checkboxId;
        this.indeterminate = false;
        this.checked = false;
        this.labelAlignment = 'center';
        this.disabled = false;
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, CHECKBOX_INHERITED_ATTRS));
    }
    componentDidLoad() {
        this.onSlotChange();
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.nativeInput, attr, value);
    }
    async getLabel() {
        return getSlottedContentText(this.el);
    }
    handleChange(e) {
        e.stopImmediatePropagation();
        e.preventDefault();
        this.toggleCheckboxState();
    }
    async handleHostClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.toggleCheckboxState();
    }
    handleInputClick(ev) {
        // If the click event is coming from the mouse we ignore it.
        // We only want to handle the keyboard interactions as it is the only purpose of this native input
        if (ev.detail) {
            ev.stopImmediatePropagation();
            ev.preventDefault();
        }
    }
    toggleCheckboxState() {
        if (this.disabled)
            return;
        this.indeterminate = false;
        this.checked = !this.checked;
        this.wcsChange.emit({
            checked: this.checked,
        });
    }
    handleFocus(event) {
        this.wcsFocus.emit(event);
    }
    handleBlur(event) {
        this.wcsBlur.emit(event);
    }
    onSlotChange() {
        const slot = this.el.shadowRoot.querySelector('slot');
        if (slot) {
            // TODO: remove when pseudo-class that indicate a slot has content is supported in all major browsers 
            //  (https://github.com/w3c/csswg-drafts/issues/6867)
            // https://developer.mozilla.org/en-US/docs/Web/CSS/:empty
            const assignedNodes = slot.assignedNodes();
            if (assignedNodes.length > 0) {
                this.el.shadowRoot.querySelector('.text').classList.remove('hidden');
            }
            else {
                this.el.shadowRoot.querySelector('.text').classList.add('hidden');
            }
        }
    }
    render() {
        return (h(Host, { key: 'a2215c880bbe8e2751505e44275e5cd085266baa' }, h("label", { key: 'ce09cb611a5e40695e2c2a8734501b28a04fe581', htmlFor: this.name, class: "wcs-container", "aria-disabled": this.disabled }, h("input", Object.assign({ key: 'ac1a253cfe304ed08e83383137f83e3bcc2403b9', onBlur: this.handleBlur.bind(this), onChange: this.handleChange.bind(this), onFocus: this.handleFocus.bind(this), onClick: this.handleInputClick.bind(this), checked: this.checked, class: "wcs-checkbox", type: "checkbox", ref: (el) => (this.nativeInput = el), name: this.name, disabled: this.disabled, id: this.name }, this.inheritedAttributes)), h("span", { key: '04814a8a11514ee090d04b708095553c73aea6f8', class: "wcs-checkmark" }), h("span", { key: '8a2894a93d030a2854b39a47cad63066d0b6904a', class: "text" }, h("slot", { key: '40d804d00c1e3ba9eff5aa510b252a95a089e416', onSlotchange: (_) => this.onSlotChange() })))));
    }
    static get is() { return "wcs-checkbox"; }
    static get encapsulation() { return "shadow"; }
    static get delegatesFocus() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["checkbox.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["checkbox.css"]
        };
    }
    static get properties() {
        return {
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "this.checkboxId"
            },
            "indeterminate": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true` the checkbox is in indeterminate state."
                },
                "attribute": "indeterminate",
                "reflect": true,
                "defaultValue": "false"
            },
            "checked": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, the checkbox is selected."
                },
                "attribute": "checked",
                "reflect": true,
                "defaultValue": "false"
            },
            "labelAlignment": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "CheckboxLabelAlignment",
                    "resolved": "\"bottom\" | \"center\" | \"top\"",
                    "references": {
                        "CheckboxLabelAlignment": {
                            "location": "import",
                            "path": "./checkbox-interface",
                            "id": "src/components/checkbox/checkbox-interface.ts::CheckboxLabelAlignment"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifie the alignment of the checkbox with the label content"
                },
                "attribute": "label-alignment",
                "reflect": true,
                "defaultValue": "'center'"
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify whether the checkbox is disabled or not."
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            }
        };
    }
    static get events() {
        return [{
                "method": "wcsChange",
                "name": "wcsChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the checked property has changed."
                },
                "complexType": {
                    "original": "CheckboxChangeEventDetail",
                    "resolved": "CheckboxChangeEventDetail",
                    "references": {
                        "CheckboxChangeEventDetail": {
                            "location": "import",
                            "path": "./checkbox-interface",
                            "id": "src/components/checkbox/checkbox-interface.ts::CheckboxChangeEventDetail"
                        }
                    }
                }
            }, {
                "method": "wcsFocus",
                "name": "wcsFocus",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the checkbox has focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }, {
                "method": "wcsBlur",
                "name": "wcsBlur",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the checkbox loses focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getLabel": {
                "complexType": {
                    "signature": "() => Promise<string>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<string>"
                },
                "docs": {
                    "text": "Get the label text",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get listeners() {
        return [{
                "name": "click",
                "method": "handleHostClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
let checkboxIds = 0;
//# sourceMappingURL=checkbox.js.map
