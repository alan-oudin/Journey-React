import { forceUpdate, h, Host } from "@stencil/core";
import { inheritAttributes, inheritAriaAttributes, setOrRemoveAttribute } from "../../utils/helpers";
import { ICONS_FONT_CHEVRON_UNICODE, NAV_ARIA_LABEL_DEFAULT, EXPAND_BTN_ARIA_LABEL_DEFAULT } from "./breadcrumb-constants";
const BREADCRUMB_INHERITED_ATTRS = [];
/**
 * A breadcrumb trail consists of a list of links to the parent pages of the current page in hierarchical order.
 * It helps users find their place within a website or web application. Breadcrumbs are often placed horizontally before a page's main content.
 *
 * ## Accessibility guidelines ðŸ’¡
 * > - If the last item is a link to the current page, you must set the `aria-current` attribute to `page` on `wcs-breadcrumb-item`.
 * > - If the element representing the current page is not a link, `aria-current` is optional.
 * > - You can set the attribute `aria-label` on `wcs-breadcrumb`, it will be passed to the native `nav` element located inside its shadow DOM.
 * >   You can find the `aria-label` default value in the table below. If your application is in English, you can set it to `Breadcrumb`.
 * > - You can do the same thing for the `aria-label` of the expand button when the breadcrumb is collapsed. You can find its default value
 * >   in the table below too.
 * > - If you need to **dynamically change the `aria-label` attribute of `wcs-breadcrumb` after the first render**, you can use the
 * >   `setAriaAttribute` JS method (example below). For the expand button however, you can update the prop `ariaLabelExpandButton`.
 * >   Note: we're working on updating the component automatically when attributes change.
 *
 * > ```javascript
 * > const wcsButton = document.querySelector('wcs-button');
 * > await wcsButton.setAriaAttribute('aria-label', 'new label');
 * > ```
 *
 * @cssprop --wcs-breadcrumb-icon-color - Icon color
 * @cssprop --wcs-breadcrumb-icon-font-size - Icon font size
 * @cssprop --wcs-breadcrumb-gap - Gap between breadcrumb items
 */
export class Breadcrumb {
    constructor() {
        this.inheritedAttributes = {};
        this.maxItems = undefined;
        this.itemsBeforeCollapse = 1;
        this.itemsAfterCollapse = 2;
        this.ariaLabelExpandButton = EXPAND_BTN_ARIA_LABEL_DEFAULT;
        this.showHiddenItems = false;
    }
    handleCollapsePropsChange() {
        this.updateCollapsedViewMode();
    }
    handleAriaLabelExpandBtnChange(newValue) {
        var _a;
        (_a = this.expandBtnEl) === null || _a === void 0 ? void 0 : _a.setAriaAttribute('aria-label', newValue);
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, BREADCRUMB_INHERITED_ATTRS));
        this.updateCollapsedViewMode();
    }
    componentDidLoad() {
        var _a;
        (_a = this.expandBtnEl) === null || _a === void 0 ? void 0 : _a.setAriaAttribute('aria-label', this.ariaLabelExpandButton);
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.navEl, attr, value);
    }
    getBreadcrumbItems() {
        return Array.from(this.el.querySelectorAll('wcs-breadcrumb-item'));
    }
    shouldCollapseItems() {
        return (!!this.maxItems &&
            this.getBreadcrumbItems().length > this.maxItems &&
            this.itemsBeforeCollapse + this.itemsAfterCollapse <= this.maxItems);
    }
    updateCollapsedViewMode() {
        if (this.shouldCollapseItems()) {
            this.assignSlotNamesForCollapsedViewMode();
        }
        else {
            this.assignSlotNamesForNonCollapsedViewMode();
        }
    }
    /**
     * Setting slot names on breadcrumb items allows to leverage JSX in the render method.
     */
    assignSlotNamesForCollapsedViewMode() {
        const breadcrumbItems = this.getBreadcrumbItems();
        const itemBeforeExpandBtnIndex = this.itemsBeforeCollapse - 1;
        const itemAfterExpandBtnIndex = breadcrumbItems.length - this.itemsAfterCollapse;
        breadcrumbItems.forEach((breadcrumbItem, index) => {
            if (index <= itemBeforeExpandBtnIndex) {
                breadcrumbItem.slot = 'items-before-expand-btn';
                breadcrumbItem.last = false;
            }
            else if (index > itemBeforeExpandBtnIndex && index < itemAfterExpandBtnIndex) {
                breadcrumbItem.slot = 'hidden-items';
                breadcrumbItem.last = false;
            }
            else {
                breadcrumbItem.slot = 'items-after-expand-btn';
                breadcrumbItem.last = index === breadcrumbItems.length - 1;
            }
        });
    }
    assignSlotNamesForNonCollapsedViewMode() {
        const breadcrumbItems = this.getBreadcrumbItems();
        breadcrumbItems.forEach((breadcrumbItem, index) => {
            breadcrumbItem.slot = 'non-collapsed';
            breadcrumbItem.last = index === breadcrumbItems.length - 1;
        });
    }
    handleSlotChange() {
        this.updateCollapsedViewMode();
        this.showHiddenItems = false;
        forceUpdate(this);
    }
    handleOnExpandBtnClick() {
        // We leave the breadcrumb items in the hidden-items slot, without passing them to
        // the non-collapsed slot, so that we know which items to hide again later if needed.
        // For future implementations, the expand button could show or hide hidden items on click,
        // with a wcs-dropdown for example.
        this.showHiddenItems = true;
        // We wait for the first hidden item to be visible in the DOM again
        // to be able to focus it.
        requestAnimationFrame(() => this.setFocusToFirstHiddenItem());
    }
    /**
     * Avoid losing focus after clicking the expand button.
     * We need to give focus back to the first breadcrumb item link that was hidden before.
     */
    setFocusToFirstHiddenItem() {
        const breadcrumbItems = this.getBreadcrumbItems();
        const firstHiddenItemIndex = this.itemsBeforeCollapse;
        const firstHiddenItem = breadcrumbItems[firstHiddenItemIndex];
        const firstHiddenItemSlot = firstHiddenItem.shadowRoot.querySelector('slot');
        const breadcrumbItemLinkToFocus = firstHiddenItemSlot.assignedElements()[0];
        breadcrumbItemLinkToFocus === null || breadcrumbItemLinkToFocus === void 0 ? void 0 : breadcrumbItemLinkToFocus.focus();
    }
    renderExpandAllButton() {
        const expandBtnIsLastItem = this.itemsAfterCollapse === 0;
        return (h("div", { role: "listitem", class: "item-not-slotted" }, h("wcs-button", { mode: "clear", shape: "square", size: "s", onClick: this.handleOnExpandBtnClick.bind(this), ref: (el) => this.expandBtnEl = el }, h("wcs-mat-icon", { icon: "more_horiz" })), !expandBtnIsLastItem && (h("span", { class: "item-icon", "aria-hidden": "true" }, ICONS_FONT_CHEVRON_UNICODE))));
    }
    render() {
        const showExpandBtn = this.shouldCollapseItems() && !this.showHiddenItems;
        return (h(Host, { key: 'f1c0ed14b8806df5c1ba717f6354d2e4c201dcd1' }, h("nav", Object.assign({ key: 'ae39ce6d5af6868105c1cb349d70d04da9931274', class: `wcs-breadcrumb-container${this.showHiddenItems ? ' show-hidden-items' : ''}`, "aria-label": NAV_ARIA_LABEL_DEFAULT }, this.inheritedAttributes, { ref: (el) => this.navEl = el }), h("div", { key: '82f4a76da057076e5d7299df7972bb918220b6ac', role: "list" }, h("slot", { key: 'e3180e059e1467c9821e5d10b0694f39194ce4f4', onSlotchange: this.handleSlotChange.bind(this) }), h("slot", { key: 'e865695a1082a503321d519193f47c54f2d86ba5', name: "non-collapsed" }), h("slot", { key: '53a846e67fe320236a8f0b80216c72fa676304bb', name: "items-before-expand-btn" }), h("slot", { key: 'a6f9243e94d5f4e05e6e3ca89a574ac37128689a', name: "hidden-items" }), showExpandBtn && this.renderExpandAllButton(), h("slot", { key: '0ca62fc184565b82a12d1314bdfb51161934775b', name: "items-after-expand-btn" })))));
    }
    static get is() { return "wcs-breadcrumb"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["breadcrumb.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["breadcrumb.css"]
        };
    }
    static get properties() {
        return {
            "maxItems": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "If the number of breadcrumb items exceeds this maximum,\nthe breadcrumb will collapse and show an expand button.  \nIf this prop is `undefined`, breadcrumb items will never collapse."
                },
                "attribute": "max-items",
                "reflect": false
            },
            "itemsBeforeCollapse": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The number of breadcrumb items to show before the expand button.\nIf `itemsBeforeCollapse` + `itemsAfterCollapse` is greater than `maxItems`,\nthe breadcrumb will not be collapsed."
                },
                "attribute": "items-before-collapse",
                "reflect": false,
                "defaultValue": "1"
            },
            "itemsAfterCollapse": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The number of breadcrumb items to show after the expand button.\nIf `itemsBeforeCollapse` + `itemsAfterCollapse` is greater than `maxItems`,\nthe breadcrumb will not be collapsed."
                },
                "attribute": "items-after-collapse",
                "reflect": false,
                "defaultValue": "2"
            },
            "ariaLabelExpandButton": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Set `aria-label` for the expand button when the breadcrumb is collapsed."
                },
                "attribute": "aria-label-expand-button",
                "reflect": false,
                "defaultValue": "EXPAND_BTN_ARIA_LABEL_DEFAULT"
            }
        };
    }
    static get states() {
        return {
            "showHiddenItems": {}
        };
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "maxItems",
                "methodName": "handleCollapsePropsChange"
            }, {
                "propName": "itemsBeforeCollapse",
                "methodName": "handleCollapsePropsChange"
            }, {
                "propName": "itemsAfterCollapse",
                "methodName": "handleCollapsePropsChange"
            }, {
                "propName": "ariaLabelExpandButton",
                "methodName": "handleAriaLabelExpandBtnChange"
            }];
    }
}
//# sourceMappingURL=breadcrumb.js.map
