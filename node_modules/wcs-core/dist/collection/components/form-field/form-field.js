import { h, Host } from "@stencil/core";
import { isMutableAriaAttribute } from "../../utils/mutable-aria-attribute";
import { normalizeWhitespace } from "../../utils/helpers";
import { isControlComponentWithLabel } from "../../utils/control-component-interface";
/**
 * Form field component wraps the native input element and add some more functionality on top of it.
 *
 * You can use the `wcs-form-field` to wrap any of these components :
 * - `wcs-input`
 * - `wcs-textarea`
 * - `wcs-radio-group`
 * - `wcs-switch`
 * - `wcs-checkbox`
 * - `wcs-native-select`
 * - `wcs-select`
 * - `wcs-counter`
 *
 * For non-supported slotted component, you can use the `required` attribute on the wrapped component to tell the
 * form-field that it is required. It will add a red star after the label of the form field.
 *
 * ## Accessibility guidelines ðŸ’¡
 * - Each form control should be identified with a unique `wcs-label`
 * - Don't forget to add form validation to make sure the data is correctly formatted
 * - If the `wcs-label` is required, the form control must have the `required` HTML attribute and vice-versa (this is normally automatically set)
 * - The form should not be submittable if at least one required form control is not filled
 * - Hints are optional and should only be used to add extra information
 * - Additional aria attributes put on `<wcs-form-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
 *
 * @slot label - Automatically filled when a `wcs-label` is provided
 * @slot <no-name> - The main slot containing the wrapped component
 * @slot prefix - (Optional) Display a component as prefix. See "Prefix Suffix Group" story for more info.
 * @slot suffix - (Optional) Display a component as suffix. See "Prefix Suffix Group" story for more info.
 * @slot error - Automatically filled when a `wcs-error` is provided
 * @slot messages - Automatically filled when a `wcs-hint` is provided
 *
 * @cssprop --wcs-form-field-gap - Defines the spacing between the label, input control, and hint messages.
 * @cssprop --wcs-form-field-prefix-suffix-border-radius - Sets the border radius for both prefix and suffix elements.
 *
 * @cssprop --wcs-form-field-prefix-background-color-default - Background color default for prefix elements
 * @cssprop --wcs-form-field-prefix-background-color-disabled - Background color for prefix elements when disabled
 * @cssprop --wcs-form-field-prefix-background-color-hover - Background color for prefix elements when hovered
 * @cssprop --wcs-form-field-prefix-border-color-default - Defines the default border color for prefix
 * @cssprop --wcs-form-field-prefix-border-color-focus - Sets the border color for prefix elements when focused.
 * @cssprop --wcs-form-field-prefix-border-color-disabled - Determines the border color for prefix elements when disabled.
 *
 * @cssprop --wcs-form-field-prefix-icon-color - Specifies the color of icons within prefix elements.
 * @cssprop --wcs-form-field-prefix-value-color - Sets the color of values within prefix elements.
 * @cssprop --wcs-form-field-prefix-placeholder-color - Defines the placeholder text color within prefix elements.
 * @cssprop --wcs-form-field-prefix-color-disabled - Determines the text color for prefix elements when disabled.
 */
export class FormField {
    constructor() {
        this.isError = false;
        this.hasPrefix = false;
        this.hasSuffix = false;
        this.spiedElement = undefined;
    }
    componentWillLoad() {
        this.hasSuffix = this.el.querySelector('[slot=suffix]') !== null;
        this.hasPrefix = this.el.querySelector('[slot=prefix]') !== null;
    }
    componentDidLoad() {
        this.initSpiedElement();
        this.addRequiredMarkerToLabel();
        this.updateErrorStateOnInput(this.isError);
    }
    isErrorChange(newValue) {
        this.updateErrorStateOnInput(newValue);
        this.updateAriaAttributes();
    }
    updateErrorStateOnInput(newValue) {
        if (this.spiedElementIsOfType('wcs-input', 'wcs-textarea')) {
            if (newValue) {
                this.spiedElement.setAttribute('state', 'error');
            }
            else {
                this.spiedElement.setAttribute('state', 'initial');
            }
        }
    }
    /**
     * This function return true if the form field contains an element with tagName matches a value of the types param
     * @param types
     * @private
     */
    spiedElementIsOfType(...types) {
        var _a;
        for (const type of types) {
            if (((_a = this.spiedElement) === null || _a === void 0 ? void 0 : _a.tagName) === type.toUpperCase())
                return true;
        }
        return false;
    }
    addRequiredMarkerToLabel() {
        var _a;
        // TODO: deprecate this in favor of the 'required' component attribute
        const label = this.el.querySelector('wcs-label');
        this.observer = new MutationObserver(mutations => {
            var _a;
            const requiredAttMutation = mutations.filter(m => m.attributeName === 'required')[0];
            if (requiredAttMutation) {
                this.updateLabelRequiredFlag((_a = this.spiedElement) === null || _a === void 0 ? void 0 : _a.hasAttribute('required'), label);
            }
        });
        if (this.spiedElement) {
            this.observer.observe(this.spiedElement, { attributes: true });
        }
        const isRequired = (_a = this.spiedElement) === null || _a === void 0 ? void 0 : _a.hasAttribute('required');
        this.updateLabelRequiredFlag(isRequired, label);
    }
    initSpiedElement() {
        var _a, _b;
        const SUPPORTED_COMPONENTS = ['wcs-input', 'wcs-select', 'wcs-native-select', 'wcs-textarea', 'wcs-radio-group', 'wcs-switch', 'wcs-checkbox', 'wcs-native-select', 'wcs-counter'];
        this.spiedElement = (_a = this.el.shadowRoot.querySelector('slot:not([name])')) === null || _a === void 0 ? void 0 : _a.assignedElements().filter(n => [...SUPPORTED_COMPONENTS, 'SLOT'].map(x => x.toUpperCase()).indexOf(n.nodeName) !== -1)[0];
        // If the component is used in another web component
        if (((_b = this.spiedElement) === null || _b === void 0 ? void 0 : _b.tagName) === 'SLOT') {
            this.spiedElement = (this.spiedElement
                .assignedElements()
                .filter(n => SUPPORTED_COMPONENTS.map(x => x.toUpperCase()).indexOf(n.nodeName) !== -1)[0]);
        }
        if (!this.spiedElement) {
            // tslint:disable-next-line:no-console
            console.warn('Form-field component support only ' + SUPPORTED_COMPONENTS.toString() + '. Some features may not work with the provided component.');
            return;
        }
    }
    async updateAriaAttributes() {
        if (isMutableAriaAttribute(this.spiedElement)) {
            const ariaLabelParts = [];
            if (isControlComponentWithLabel(this.spiedElement)) {
                const innerLabel = await this.spiedElement.getLabel();
                const combinedLabel = `${this.label || ''} ${innerLabel || ''}`.trim();
                if (combinedLabel) {
                    ariaLabelParts.push(normalizeWhitespace(combinedLabel));
                }
            }
            else {
                if (this.label) {
                    ariaLabelParts.push(normalizeWhitespace(this.label));
                }
            }
            if (this.description) {
                ariaLabelParts.push(normalizeWhitespace(this.description));
            }
            // Sur les autres DS, gÃ©nÃ©ralement seul l'erreur est affichÃ©e et pas avec la description
            if (this.isError) {
                this.spiedElement.setAriaAttribute('aria-invalid', 'true');
                if (this.error) {
                    ariaLabelParts.push(normalizeWhitespace(this.error));
                }
            }
            else {
                this.spiedElement.setAriaAttribute('aria-invalid', 'false');
            }
            this.spiedElement.setAriaAttribute('aria-label', ariaLabelParts.length > 0 ? ariaLabelParts.join(' ') : null);
        }
    }
    get label() {
        var _a;
        return ((_a = this.el.querySelector('wcs-label')) === null || _a === void 0 ? void 0 : _a.textContent) || null;
    }
    get description() {
        var _a;
        return ((_a = this.el.querySelector('wcs-hint')) === null || _a === void 0 ? void 0 : _a.textContent) || null;
    }
    get error() {
        var _a;
        return ((_a = this.el.querySelector('wcs-error')) === null || _a === void 0 ? void 0 : _a.textContent) || null;
    }
    updateLabelRequiredFlag(isRequired, label) {
        if (isRequired && label) {
            label.setAttribute('required', 'true');
        }
        else if (!isRequired && label) {
            label.removeAttribute('required');
        }
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    render() {
        let classes = '';
        const isError = this.isError;
        if (this.hasSuffix) {
            classes += ' has-suffix';
        }
        if (this.hasPrefix) {
            classes += ' has-prefix';
        }
        return (h(Host, { key: 'd8a5d2023add393b0a31173351a3d16d9fa0b1a6', class: classes }, h("slot", { key: '3f347f4dce239c0106fbbe52bdc217fa37c05d01', name: "label" }), h("div", { key: 'd6cb92104d72530059ecb9a383ff832afb0c2141', class: "input-container" }, h("slot", { key: '8be28f721ff351d41dced80c97c0e34337703d0e', name: "prefix" }), h("slot", { key: 'cc58d463877a1e8513736a987286e965870e096d', onSlotchange: () => this.onFormInputSlotChange() }), h("slot", { key: '898709cfcf0ae1cd43dabd55547d62199d6230c9', name: "suffix" })), isError ? (h("slot", { name: "error" })) : '', h("slot", { key: 'aaf2d35dfbdfda47b440f96d7f9aa22cb09f6a06', name: "messages" })));
    }
    onFormInputSlotChange() {
        this.initSpiedElement();
        this.updateAriaAttributes();
        this.addRequiredMarkerToLabel();
        this.updateErrorStateOnInput(this.isError);
    }
    static get is() { return "wcs-form-field"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["form-field.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["form-field.css"]
        };
    }
    static get properties() {
        return {
            "isError": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component"
                },
                "attribute": "is-error",
                "reflect": true,
                "defaultValue": "false"
            }
        };
    }
    static get states() {
        return {
            "hasPrefix": {},
            "hasSuffix": {},
            "spiedElement": {}
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "isError",
                "methodName": "isErrorChange"
            }];
    }
}
//# sourceMappingURL=form-field.js.map
