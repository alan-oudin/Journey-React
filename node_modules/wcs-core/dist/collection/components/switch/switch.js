import { h, Host } from "@stencil/core";
import { inheritAriaAttributes, inheritAttributes, setOrRemoveAttribute } from "../../utils/helpers";
import { getSlottedContentText } from "../../utils/control-component-interface";
const SWITCH_INHERITED_ATTRS = ['tabindex'];
/**
 * The switch component is a control used to switch between on and off state.
 *
 * @cssprop --wcs-switch-outline-color-focus - Color of the focus outline
 *
 * @cssprop --wcs-switch-text-color-default - Color of the text when the switch is not selected
 * @cssprop --wcs-switch-text-color-selected - Color of the text when the switch is selected
 * @cssprop --wcs-switch-text-color-disabled - Color of the text when the switch is disabled

 *
 * @cssprop --wcs-switch-background-color-initial - Background color of the switch when not selected
 * @cssprop --wcs-switch-background-color-final - Background color of the switch when selected
 * @cssprop --wcs-switch-background-color-disabled - Background color of the switch when disabled
 * @cssprop --wcs-switch-background-color-disabled-selected - Background color of the switch when disabled and selected
 * @cssprop --wcs-switch-background-color-hover-selected - Background color of the switch when hovered and selected
 *
 * @cssprop --wcs-switch-height - Height of the switch
 * @cssprop --wcs-switch-width - Width of the switch
 * @cssprop --wcs-switch-border-radius - Border radius of the switch
 * @cssprop --wcs-switch-padding-horizontal - Horizontal padding of the switch
 * @cssprop --wcs-switch-padding-vertical - Vertical padding of the switch
 *
 * @cssprop --wcs-switch-dot-color-default - Color of the dot when not selected
 * @cssprop --wcs-switch-dot-color-selected - Color of the dot when selected
 * @cssprop --wcs-switch-dot-color-disabled - Color of the dot when disabled
 *
 * @cssprop --wcs-switch-dot-translate-x - Horizontal translation of the dot (from left to right = right to left)
 * @cssprop --wcs-switch-dot-size - Size of the dot
 *
 * @cssprop --wcs-switch-gap - Gap between the switch and the text
 */
export class Switch {
    constructor() {
        this.switchId = `wcs-switch-${switchIds++}`;
        this.inheritedAttributes = {};
        this.name = this.switchId;
        this.checked = false;
        this.labelAlignment = 'center';
        this.disabled = false;
    }
    handleChange(ev) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
        this.toggleSwitchState();
    }
    async handleHostClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.toggleSwitchState();
    }
    handleInputClick(ev) {
        // If the click event is coming from the mouse we ignore it.
        // We only want to handle the keyboard interactions as it is the only purpose of this native input
        if (ev.detail) {
            ev.stopImmediatePropagation();
            ev.preventDefault();
        }
    }
    toggleSwitchState() {
        if (this.disabled)
            return;
        this.checked = !this.checked;
        this.wcsChange.emit({
            checked: this.checked,
        });
    }
    handleFocus(event) {
        this.wcsFocus.emit(event);
    }
    handleBlur(event) {
        this.wcsBlur.emit(event);
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, SWITCH_INHERITED_ATTRS));
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.nativeInput, attr, value);
    }
    async getLabel() {
        return getSlottedContentText(this.el);
    }
    render() {
        return (h(Host, { key: 'cedd87377ee17731f5422f42117321f23d944281' }, h("label", { key: '1bb8e511921d30ccf6153738eb6a0844ea3f4082', htmlFor: this.name, class: "wcs-container", "aria-disabled": this.disabled }, h("input", Object.assign({ key: 'b05af8decb4cd3c23b2c814fd849612370c896e6', onBlur: this.handleBlur.bind(this), onChange: this.handleChange.bind(this), onClick: this.handleInputClick.bind(this), onFocus: this.handleFocus.bind(this), checked: this.checked, id: this.name, class: "wcs-switch", type: "checkbox", name: this.name, disabled: this.disabled, ref: el => { this.nativeInput = el; } }, this.inheritedAttributes)), h("span", { key: 'fcc0664435cb4d40d6fd95571ff233ae44806f58', class: "wcs-checkmark" }), h("span", { key: '67a951e606c537e911352799de289e4eefc87e23', class: "text" }, h("slot", { key: 'dbe2ced66c88f5184144661215c9332d464c01fc' })))));
    }
    static get is() { return "wcs-switch"; }
    static get encapsulation() { return "shadow"; }
    static get delegatesFocus() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["switch.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["switch.css"]
        };
    }
    static get properties() {
        return {
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "this.switchId"
            },
            "checked": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If `true`, the switch is selected."
                },
                "attribute": "checked",
                "reflect": true,
                "defaultValue": "false"
            },
            "labelAlignment": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "SwitchLabelAlignment",
                    "resolved": "\"bottom\" | \"center\" | \"top\"",
                    "references": {
                        "SwitchLabelAlignment": {
                            "location": "import",
                            "path": "./switch-interface",
                            "id": "src/components/switch/switch-interface.ts::SwitchLabelAlignment"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifie the alignment of the switch with the label content"
                },
                "attribute": "label-alignment",
                "reflect": true,
                "defaultValue": "'center'"
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify whether the switch is disabled or not."
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            }
        };
    }
    static get events() {
        return [{
                "method": "wcsChange",
                "name": "wcsChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the checked property has changed."
                },
                "complexType": {
                    "original": "SwitchChangeEventDetail",
                    "resolved": "SwitchChangeEventDetail",
                    "references": {
                        "SwitchChangeEventDetail": {
                            "location": "import",
                            "path": "./switch-interface",
                            "id": "src/components/switch/switch-interface.ts::SwitchChangeEventDetail"
                        }
                    }
                }
            }, {
                "method": "wcsFocus",
                "name": "wcsFocus",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the switch has focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }, {
                "method": "wcsBlur",
                "name": "wcsBlur",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the switch loses focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getLabel": {
                "complexType": {
                    "signature": "() => Promise<string>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<string>"
                },
                "docs": {
                    "text": "Get the label text",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get listeners() {
        return [{
                "name": "click",
                "method": "handleHostClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
let switchIds = 0;
//# sourceMappingURL=switch.js.map
