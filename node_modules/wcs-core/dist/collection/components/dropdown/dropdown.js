import { h, Host } from "@stencil/core";
import { SelectArrow } from "../select/select-arrow";
import { createPopper } from "@popperjs/core";
import { clickTargetIsElementOrChildren, inheritAriaAttributes, inheritAttributes, setOrRemoveAttribute } from "../../utils/helpers";
import { getActionForKeyboardEvent } from "./dropdown-keyboard-event";
const DROPDOWN_INHERITED_ATTRS = ['tabindex'];
/**
 * The dropdown component use a wcs-button under the hood, so you can use the same css classes as the button to style the
 * dropdown.
 *
 * @slot placeholder - The slot containing the placeholder displayed in button
 * @slot item - The slot container the list of `wcs-dropdown-item` elements
 *
 * @cssprop --wcs-dropdown-outline-color-focus - Outline color of dropdown when focus it
 *
 * @cssprop --wcs-dropdown-plain-arrow-color - Color of the arrow indicator when the dropdown is plain
 * @cssprop --wcs-dropdown-stroked-arrow-color - Color of the arrow indicator when the dropdown is stroked
 * @cssprop --wcs-dropdown-clear-arrow-color - Color of the arrow indicator when the dropdown is not filled
 * @cssprop --wcs-dropdown-arrow-color-disabled - Base color of the arrow indicator when the dropdown is disabled
 *
 * @cssprop --wcs-dropdown-padding-empty - Padding of and empty dropdown
 *
 * @cssprop --wcs-dropdown-overlay-padding - Defines the vertical padding inside the dropdown overlay
 * @cssprop --wcs-dropdown-overlay-max-height - Specifies the maximum height of the dropdown overlay
 * @cssprop --wcs-dropdown-overlay-background-color - Determines the background color of the dropdown overlay
 * @cssprop --wcs-dropdown-overlay-border-width - Sets the border width of the dropdown overlay
 * @cssprop --wcs-dropdown-overlay-border-radius - Defines the border radius of the dropdown overlay
 * @cssprop --wcs-dropdown-overlay-border-color - Specifies the border color of the dropdown overlay
 */
export class Dropdown {
    constructor() {
        this.inheritedAttributes = {};
        this.noArrow = false;
        this.mode = 'stroked';
        this.shape = 'normal';
        this.size = 'm';
        this.disabled = false;
        this.placement = 'bottom-end';
        this.expanded = false;
    }
    get items() {
        return Array.from(this.el.querySelectorAll('wcs-dropdown-item'));
    }
    placementChange() {
        this.popper.setOptions(Object.assign(Object.assign({}, this.popper.state.options), { placement: this.placement })).then(_ => this.popper.update());
    }
    onBlur() {
        this.clearLastFocusedItem();
        this.expanded = false;
    }
    componentDidLoad() {
        this.popper = createPopper(this.wcsButton, this.popoverDiv, {
            placement: this.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8]
                    }
                }
            ]
        });
        this.fixForFirefoxBelow63();
    }
    fixForFirefoxBelow63() {
        // If the items appear out of the slot we place them back
        const items = this.el.querySelectorAll('wcs-dropdown-item');
        const container = this.el.querySelector('.container');
        if (items.length > 0 && container) {
            items.forEach(i => {
                this.el.removeChild(i);
                container.appendChild(i);
            });
        }
    }
    onButtonClick(_) {
        this.clearLastFocusedItem();
        this.expanded = !this.expanded;
        if (this.expanded) {
            this.focusItem(0);
        }
    }
    onWindowClickEvent(event) {
        const clickedOnDropdownOrChildren = clickTargetIsElementOrChildren(event, this.el);
        if (this.expanded && !clickedOnDropdownOrChildren) {
            this.expanded = false;
        }
    }
    dropdownItemClick(_) {
        this.expanded = false;
        this.nativeButton.focus();
    }
    onKeyDown(_event) {
        const currentState = this.expanded ? 'opened' : 'closed';
        const actionsFromKeyboardEvents = getActionForKeyboardEvent(_event, currentState);
        // If we have at least one associated actions, we prevent the default behavior of the event. 
        // Except if the action is a focus move (we have to handle the preventDefault behavior ourselves in the action implementation)
        if (actionsFromKeyboardEvents.length != 0) {
            _event.preventDefault();
        }
        for (const actionFromKeyboardEvent of actionsFromKeyboardEvents) {
            this.doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent);
        }
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.nativeButton, attr, value);
    }
    doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent) {
        switch (actionFromKeyboardEvent.kind) {
            case 'OpenMenu':
                this.expanded = true;
                this.focusItem(0);
                break;
            case 'CloseMenu':
                this.expanded = false;
                this.nativeButton.focus();
                break;
            case 'ClearFocus':
                this.clearLastFocusedItem();
                break;
            case 'FocusItem':
                switch (actionFromKeyboardEvent.target) {
                    case 'previous':
                        this.focusClosestItem('previous');
                        break;
                    case 'next':
                        this.focusClosestItem('next');
                        break;
                    case 'first':
                        this.focusItem(0);
                        break;
                    case 'last':
                        this.focusItem(this.items.length - 1);
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    }
    /**
     * Removes the focus and tabindex 0 of the last focused item if any.
     * @private
     */
    clearLastFocusedItem() {
        if (this.lastFocusedItemElement) {
            this.lastFocusedItemElement.tabIndex = -1;
            this.lastFocusedItemElement = null;
        }
    }
    focusItem(indexToFocus) {
        this.clearLastFocusedItem();
        this.lastFocusedItemElement = this.items[indexToFocus];
        if (this.lastFocusedItemElement) {
            this.lastFocusedItemElement.tabIndex = 0;
            requestAnimationFrame(() => {
                var _a;
                (_a = this.lastFocusedItemElement) === null || _a === void 0 ? void 0 : _a.focus();
            });
        }
    }
    focusClosestItem(direction) {
        const indexToFocus = this.getClosestActiveItemIndexForDirection(direction);
        if (indexToFocus === -1)
            return;
        this.focusItem(indexToFocus);
    }
    getClosestActiveItemIndexForDirection(direction) {
        const items = this.items;
        let currentIndex = Array.from(items).indexOf(this.lastFocusedItemElement);
        const MIN_INDEX = 0;
        const MAX_INDEX = items.length - 1;
        if (direction === 'next' && currentIndex < MAX_INDEX) {
            currentIndex++;
        }
        else if (direction === 'previous' && currentIndex > MIN_INDEX) {
            currentIndex--;
        }
        else {
            // Used to scroll through items infinitely with keyboard
            if (direction === 'next' && currentIndex >= MAX_INDEX) {
                currentIndex = 0;
            }
            if (direction === 'previous' && currentIndex === MIN_INDEX) {
                currentIndex = MAX_INDEX;
            }
        }
        return currentIndex;
    }
    componentDidRender() {
        if (this.popper) {
            this.popper.update();
        }
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, DROPDOWN_INHERITED_ATTRS));
    }
    render() {
        return (h(Host, { key: '96be2f9df0a80b4d6c88cf15419ff29cb001c695' }, h("button", Object.assign({ key: '562456822837e6ff61ed23569335e42ad4e36df9', id: "dropdown-button", "aria-controls": "menu", disabled: this.disabled, "aria-haspopup": "true", role: "button", "aria-expanded": this.expanded ? 'true' : 'false', ref: el => this.nativeButton = el, onClick: ($event) => this.onButtonClick($event), onBlur: ($event) => $event.stopImmediatePropagation() }, this.inheritedAttributes), "Dropdown"), h("wcs-button", { key: '66348725409b810219dd1bd4658611c63bbb5eb8', mode: this.mode, shape: this.shape, disabled: this.disabled, size: this.size, ref: el => this.wcsButton = el, "aria-hidden": "true", tabindex: -1, onClick: ($event) => this.onButtonClick($event), onBlur: (e) => e.stopImmediatePropagation() }, h("div", { key: '028e06637e35ecc14b66cf74fba32dc59d58121a', class: "wcs-button-content-wrapper" }, h("slot", { key: '7f7e2db54f9b5d3a20588c48c1d3fd6750187017', name: "placeholder" }), this.noArrow ? null : (h(SelectArrow, { up: this.expanded })))), h("div", { key: '7f6f4efe22cab63033b3e7775791856ed8e1b921', class: (this.expanded ? 'show ' : '') + 'popover', id: "menu", role: "menu", "aria-labelledby": "dropdown-button", tabindex: -1, ref: el => this.popoverDiv = el }, h("div", { key: 'ca7ce6adea1005d7126d4ae060ada55e9d3b6d70', role: "presentation", id: "arrow", "data-popper-arrow": true }), h("div", { key: '0f2a9e15df898550117743f855e7ee0746157ab1', role: "presentation", class: "container" }, h("slot", { key: '688fd29a894bae8aee4c848a9b07380c95302ca2', name: "item" }, h("span", { key: 'a80c902d26d7afed58e8a17646dac92473042fa4', id: "is-empty" }))))));
    }
    static get is() { return "wcs-dropdown"; }
    static get encapsulation() { return "shadow"; }
    static get delegatesFocus() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["dropdown.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["dropdown.css"]
        };
    }
    static get properties() {
        return {
            "noArrow": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Hides the arrow in the button"
                },
                "attribute": "no-arrow",
                "reflect": true,
                "defaultValue": "false"
            },
            "mode": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsButtonMode",
                    "resolved": "\"clear\" | \"plain\" | \"stroked\"",
                    "references": {
                        "WcsButtonMode": {
                            "location": "import",
                            "path": "../button/button-interface",
                            "id": "src/components/button/button-interface.ts::WcsButtonMode"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Dropdown's button mode"
                },
                "attribute": "mode",
                "reflect": false,
                "defaultValue": "'stroked'"
            },
            "shape": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsButtonShape",
                    "resolved": "\"normal\" | \"round\" | \"square\"",
                    "references": {
                        "WcsButtonShape": {
                            "location": "import",
                            "path": "../button/button-interface",
                            "id": "src/components/button/button-interface.ts::WcsButtonShape"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Dropdown's button shape"
                },
                "attribute": "shape",
                "reflect": false,
                "defaultValue": "'normal'"
            },
            "size": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsButtonSize",
                    "resolved": "\"l\" | \"m\" | \"s\"",
                    "references": {
                        "WcsButtonSize": {
                            "location": "import",
                            "path": "../button/button-interface",
                            "id": "src/components/button/button-interface.ts::WcsButtonSize"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Dropdown's button size"
                },
                "attribute": "size",
                "reflect": false,
                "defaultValue": "'m'"
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies whether the dropdown button is clickable or not"
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            },
            "placement": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsDropdownPlacement",
                    "resolved": "\"auto\" | \"auto-end\" | \"auto-start\" | \"bottom\" | \"bottom-end\" | \"bottom-start\" | \"left\" | \"left-end\" | \"left-start\" | \"right\" | \"right-end\" | \"right-start\" | \"top\" | \"top-end\" | \"top-start\"",
                    "references": {
                        "WcsDropdownPlacement": {
                            "location": "import",
                            "path": "./dropdown-interface",
                            "id": "src/components/dropdown/dropdown-interface.ts::WcsDropdownPlacement"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "placement of the dropdown's popover"
                },
                "attribute": "placement",
                "reflect": false,
                "defaultValue": "'bottom-end'"
            }
        };
    }
    static get states() {
        return {
            "expanded": {}
        };
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "placement",
                "methodName": "placementChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "blur",
                "method": "onBlur",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "click",
                "method": "onWindowClickEvent",
                "target": "window",
                "capture": false,
                "passive": false
            }, {
                "name": "wcsDropdownItemClick",
                "method": "dropdownItemClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "keydown",
                "method": "onKeyDown",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=dropdown.js.map
