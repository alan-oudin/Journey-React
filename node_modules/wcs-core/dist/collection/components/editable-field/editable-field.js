import { h, Host } from "@stencil/core";
import { isWcsEditableFieldSize, WcsEditableFieldSizeValues } from "./editable-field-interface";
import { clickInsideElement, isEnterKey, isEscapeKey, isMouseEvent } from "../../utils/helpers";
var EditableComponentState;
(function (EditableComponentState) {
    EditableComponentState[EditableComponentState["DISPLAY"] = 0] = "DISPLAY";
    EditableComponentState[EditableComponentState["EDIT"] = 1] = "EDIT";
    EditableComponentState[EditableComponentState["LOAD"] = 2] = "LOAD";
})(EditableComponentState || (EditableComponentState = {}));
/**
 * Aria-label of the display button
 */
const EDIT_ARIA_LABEL = "Éditer";
// We wait until the element is displayed on the page otherwise the focus does not work.
// 20ms is a little more than a 16ms frame at 60fps.
const DELAY_BEFORE_FOCUS = 20;
/**
 * The editable-field component can be used to simplify the user experience, avoiding the use of a redirection to a form
 * to edit the data of an entity. You can use it with these wrapped components : `wcs-input`, `wcs-textarea`, `wcs-select`.
 *
 * This component is not present in the SNCF design system specifications, so we tried to build it in the most
 * "discoverable" way possible (for users who interact with), but it's a first version.
 *
 * **How to use ❓**
 * This component is mostly used with a server that returns a response to the input sent through the `wcsChange` event.
 * It has 3 internal states :
 * - DISPLAY = the default state of the editable-field
 * - EDIT = the editable-field is editable, the user should input the data
 * - LOADING = the data is submitted and the editable-field is waiting for a **response**
 *
 * A **response** is needed to get the component out of the LOADING state. You can either :
 * - Set the `value` property to a different value to tell the component to refresh and go back into DISPLAY state
 * - Use the `successHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
 * - Use the `errorHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
 *
 * **Accessibility guidelines 💡**
 *
 * > - Aria attributes are put on the native component on the first rendering with the `label` and `errorMsg` you provided
 * > - Additional aria attributes put on `<wcs-editable-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
 *
 * @cssprop --wcs-editable-field-label-color - Color of the label text
 * @cssprop --wcs-editable-field-label-font-weight - Font weight of the label text
 * @cssprop --wcs-editable-field-label-gap - Gap between the label and the field
 * @cssprop --wcs-editable-field-label-font-size - Font size of the label text
 *
 * @cssprop --wcs-editable-field-background-color - Background color of the editable field
 * @cssprop --wcs-editable-field-value-font-weight - Font weight of the field value text
 * @cssprop --wcs-editable-field-value-color-default - Default color of the field value text
 * @cssprop --wcs-editable-field-value-color-hover - Color of the field value text on hover
 * @cssprop --wcs-editable-field-value-color-readonly - Color of the field value text when readonly
 *
 * @cssprop --wcs-editable-field-height-m - Height of the editable field in medium size
 * @cssprop --wcs-editable-field-height-l - Height of the editable field in large size
 * @cssprop --wcs-editable-field-font-size-m - Font size of the field value text in medium size
 * @cssprop --wcs-editable-field-font-size-l - Font size of the field value text in large size
 *
 * @cssprop --wcs-editable-field-border-radius - Border radius of the editable field
 * @cssprop --wcs-editable-field-border-width - Border width of the editable field
 * @cssprop --wcs-editable-field-border-width-focus - Border width of the editable field when focused
 * @cssprop --wcs-editable-field-border-width-hover - Border width of the editable field on hover
 * @cssprop --wcs-editable-field-border-color-default - Default border color of the editable field
 * @cssprop --wcs-editable-field-border-color-hover - Border color of the editable field on hover
 * @cssprop --wcs-editable-field-border-color-focus - Border color of the editable field on focus
 * @cssprop --wcs-editable-field-border-style - Border style of the editable field
 *
 * @cssprop --wcs-editable-field-padding-vertical-m - Vertical padding of the editable field in medium size
 * @cssprop --wcs-editable-field-padding-vertical-l - Vertical padding of the editable field in large size
 * @cssprop --wcs-editable-field-padding-horizontal-m - Horizontal padding of the editable field in medium size
 * @cssprop --wcs-editable-field-padding-horizontal-l - Horizontal padding of the editable field in large size
 *
 * @cssprop --wcs-editable-field-icon-color-readonly - Color of the icon when the field is readonly
 */
export class EditableField {
    constructor() {
        this.spiedElement = null;
        this.currentValue = null;
        this.currentState = EditableComponentState.DISPLAY;
        this.type = 'input';
        this.label = undefined;
        this.readonly = false;
        this.value = undefined;
        this.validateFn = undefined;
        this.formatFn = undefined;
        this.errorMsg = null;
        this.size = 'm';
        this.isError = false;
    }
    componentWillLoad() {
        if (!isWcsEditableFieldSize(this.size)) {
            console.warn(`Invalid size value for wcs-editable-field : "${this.size}". Must be one of "${WcsEditableFieldSizeValues.join(', ')}"`);
            this.size = "m"; // Default fallback value
        }
        this.currentValue = this.value;
    }
    componentDidLoad() {
        const assignedElements = this.el.shadowRoot.querySelector('slot').assignedElements();
        switch (this.type) {
            case 'input':
                this.initWithInput(assignedElements);
                break;
            case 'textarea':
                this.initWithTextArea(assignedElements);
                break;
            case 'select':
                this.initWithSelect(assignedElements);
                break;
        }
    }
    disconnectedCallback() {
        this.cleanUpSpiedElementEventListeners();
    }
    keyboardSubmitHandler(event) {
        const shouldValidateOnEnterKey = (this.type === 'textarea' || this.type === 'select')
            ? (isEnterKey(event) && event.ctrlKey)
            : isEnterKey(event);
        if (shouldValidateOnEnterKey) {
            this.sendCurrentValue();
        }
        if (isEscapeKey(event)) {
            this.discardChanges();
        }
    }
    onWcsInputOrChange(event) {
        event.stopImmediatePropagation();
        const value = this.type === 'select' ? event.detail.value : event.detail.target.value;
        this.currentValue = value;
        if (this.validateFn) {
            this.isError = !this.validateFn(this.currentValue);
        }
    }
    cleanUpSpiedElementEventListeners() {
        var _a, _b, _c;
        (_a = this.spiedElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onInputKeydownCallback);
        (_b = this.spiedElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('wcsInput', this.onWcsInputOrChangeCallback);
        (_c = this.spiedElement) === null || _c === void 0 ? void 0 : _c.removeEventListener('wcsChange', this.onWcsInputOrChangeCallback);
    }
    initWithInput(assignedElements) {
        const element = assignedElements.filter(x => {
            return x.tagName === 'WCS-INPUT';
        })[0];
        if (!element)
            throw new Error('You must provide a slotted input element to handle edition');
        this.spiedElement = element;
        this.addWcsInputEventHandler(this.spiedElement);
        this.addKeyDownHandler(this.spiedElement);
    }
    initWithTextArea(assignedElements) {
        const element = assignedElements.filter(x => {
            return x.tagName === 'WCS-TEXTAREA';
        })[0];
        if (!element)
            throw new Error('You must provide a slotted textarea element to handle edition');
        this.spiedElement = element;
        this.addWcsInputEventHandler(this.spiedElement);
        this.addKeyDownHandler(this.spiedElement);
    }
    initWithSelect(assignedElements) {
        const element = assignedElements.filter(x => {
            return x.tagName === 'WCS-SELECT';
        })[0];
        if (!element)
            throw new Error('You must provide a slotted select element to handle edition');
        this.spiedElement = element;
        this.addWcsChangeEventHandler(this.spiedElement);
        this.addKeyDownHandler(this.spiedElement);
    }
    /**
     * This method subscribes the component to the change events produced by the other WCS components
     * (provided by the user in slot)
     * @param elt the element to subscribe to
     * @private
     */
    addWcsChangeEventHandler(elt) {
        this.onWcsInputOrChangeCallback = this.onWcsInputOrChange.bind(this);
        elt.addEventListener('wcsChange', this.onWcsInputOrChangeCallback);
    }
    /**
     * This method subscribes the component to the input events produced by the other WCS components
     * @param elt the element to subscribe to
     * @private
     */
    addWcsInputEventHandler(elt) {
        this.onWcsInputOrChangeCallback = this.onWcsInputOrChange.bind(this);
        elt.addEventListener('wcsInput', this.onWcsInputOrChangeCallback);
    }
    /**
     * This method subscribes the component to the keydown events produced by the other WCS components
     * @param elt the element to subscribe to
     * @private
     */
    addKeyDownHandler(elt) {
        this.onInputKeydownCallback = this.keyboardSubmitHandler.bind(this);
        elt.addEventListener('keydown', this.onInputKeydownCallback);
    }
    focusEditModeBtn() {
        setTimeout(() => {
            var _a;
            (_a = this.editModeBtn) === null || _a === void 0 ? void 0 : _a.focus();
        }, DELAY_BEFORE_FOCUS);
    }
    sendCurrentValue() {
        if (this.currentState === EditableComponentState.EDIT) {
            if (this.value === this.currentValue) {
                this.currentState = EditableComponentState.DISPLAY;
                this.focusEditModeBtn();
            }
            else {
                this.isError = this.validateFn ? !this.validateFn(this.currentValue) : false;
                if (!this.isError) {
                    this.currentState = EditableComponentState.LOAD;
                    this.wcsChange.emit({
                        newValue: this.currentValue,
                        successHandler: () => this.forceDisplayStateAndValidate(),
                        errorHandler: () => this.errorHandler()
                    });
                }
            }
        }
    }
    discardChanges() {
        this.currentValue = this.value;
        this.currentState = EditableComponentState.DISPLAY;
        this.isError = false;
        this.focusEditModeBtn();
    }
    forceDisplayStateAndValidate() {
        if (this.currentState === EditableComponentState.LOAD) {
            this.value = this.currentValue;
            this.currentState = EditableComponentState.DISPLAY;
            this.focusEditModeBtn();
        }
        else {
            throw new Error('You cannot set display state from ' + EditableComponentState[this.currentState] + ' state');
        }
    }
    // Process only mouse clicks, to avoid interfering with keyboard triggered button clicks. 
    // In some browsers, pressing "Enter" or "Space" while focused on a button generates a click event
    // with `event.detail` set to 0. It's a keyboard triggered click, not a real mouse click. 
    onWindowClickEvent(event) {
        // Ensure only true mouse clicks are processed
        if (isMouseEvent(event) && event.detail !== 0 && !clickInsideElement(event, this.el)) {
            if (this.currentState === EditableComponentState.EDIT) {
                if (this.isError) {
                    this.discardChanges();
                }
                else {
                    this.sendCurrentValue();
                }
            }
        }
    }
    /**
     * discard changes and force component state to DISPLAY
     * <br/>
     * This method must be call when component is in LOAD state
     */
    errorHandler() {
        this.discardChanges();
    }
    onValueChange() {
        this.currentState = EditableComponentState.DISPLAY;
    }
    onDisplayContainerClick() {
        if (this.currentState === EditableComponentState.DISPLAY && this.readonly === false) {
            this.currentState = EditableComponentState.EDIT;
            this.spiedElement['value'] = this.currentValue;
            if (this.validateFn) {
                this.isError = !this.validateFn(this.currentValue);
            }
            setTimeout(() => {
                if (this.type === 'input') {
                    this.spiedElement.focus();
                }
                else if (this.type === 'textarea') {
                    this.spiedElement.fitContent();
                    this.spiedElement.focus();
                }
            }, DELAY_BEFORE_FOCUS);
        }
    }
    getReadonlySvgIcon() {
        return h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "26", height: "24", viewBox: "0 0 27 25", class: "readonly-icon" }, h("path", { d: "M26.79,25.05H1.21a.73.73,0,0,0,0,1.45H26.79a.73.73,0,0,0,0-1.45Z", transform: "translate(-0.5 -1.5)" }), h("path", { d: "M19.8,8.87h-.61V6.73a5.23,5.23,0,0,0-10.46,0V8.87H8.2a1.63,1.63,0,0,0-1.63,1.62V21.32A1.62,1.62,0,0,0,8.2,22.94H19.8a1.62,1.62,0,0,0,1.63-1.62V10.49A1.63,1.63,0,0,0,19.8,8.87ZM10.93,6.73a3,3,0,1,1,6.06,0V8.87H10.93Zm3,14.15a5,5,0,1,1,5-5A5,5,0,0,1,14,20.88Z", transform: "translate(-0.5 -1.5)" }), h("path", { d: "M14,12.62a3.29,3.29,0,1,0,3.29,3.29A3.29,3.29,0,0,0,14,12.62Zm0,4.75a1.47,1.47,0,1,1,1.47-1.46A1.46,1.46,0,0,1,14,17.37Z", transform: "translate(-0.5 -1.5)" }));
    }
    formatValues() {
        let formattedValue = this.value;
        let formattedCurrentValue = this.currentValue;
        if (this.formatFn) {
            formattedValue = this.formatFn(this.value);
            formattedCurrentValue = this.formatFn(this.currentValue);
        }
        if (Array.isArray(this.value)) {
            formattedValue = this.value.join(', ');
        }
        if (Array.isArray(this.currentValue)) {
            formattedCurrentValue = this.currentValue.join(', ');
        }
        return {
            formattedValue: (formattedValue ? (h("span", null, formattedValue)) : (h("span", null))),
            formattedValueText: formattedValue,
            formattedCurrentValue: (formattedCurrentValue ? (h("span", null, formattedCurrentValue)) : (h("span", null)))
        };
    }
    render() {
        const { formattedValue, formattedValueText, formattedCurrentValue } = this.formatValues();
        return (h(Host, { key: '81f6b6b92cd0a6f60a0eb4fbdb781a42863d4478' }, h("div", { key: '1278b7794e0127f1f2bc819d246712d55a139abd', class: "label" }, this.label), h("button", { key: '6049a936d198c5ee68db9a29466b82dc0ca55fa2', type: "button", class: 'display-container ' + (this.currentState !== EditableComponentState.DISPLAY ? 'display-none' : ''), onClick: () => this.onDisplayContainerClick(), ref: (el) => this.editModeBtn = el, "aria-label": `${EDIT_ARIA_LABEL} ${this.label} ${formattedValueText}` }, formattedValue, h("wcs-mat-icon", { key: '97020f20f553553b1e3a866d6d2ad274504b1bc9', icon: "edit", size: "s" }), this.readonly ? this.getReadonlySvgIcon() : null), h("div", { key: '17c58773fdaa738eef36c20545815ff10c35c5eb', class: 'load-container ' + (this.currentState !== EditableComponentState.LOAD ? 'display-none' : '') }, formattedCurrentValue, h("wcs-spinner", { key: 'b2ef7dd52a95d0604cd74368a17cf26283a663a9' })), h("wcs-form-field", { key: '38891efe6c9c119ad7d261f31edba4b4e5e3ae71', "is-error": this.isError, class: 'edit-container ' + (this.currentState !== EditableComponentState.EDIT ? 'display-none' : '') }, h("wcs-label", { key: '80ff051b722d175932c4cf56410f8c4081fe4cb8', class: "visually-hidden" }, this.label), h("slot", { key: '4e8592e8283ce75e629f61dafd609c59cd5fbbc0' }), this.isError && this.errorMsg
            ? h("wcs-error", null, this.errorMsg)
            : null)));
    }
    static get is() { return "wcs-editable-field"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["editable-field.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["editable-field.css"]
        };
    }
    static get properties() {
        return {
            "type": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "EditableFieldType",
                    "resolved": "\"input\" | \"select\" | \"textarea\"",
                    "references": {
                        "EditableFieldType": {
                            "location": "import",
                            "path": "./editable-field-interface",
                            "id": "src/components/editable-field/editable-field-interface.tsx::EditableFieldType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies which component is used for editing"
                },
                "attribute": "type",
                "reflect": false,
                "defaultValue": "'input'"
            },
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Label of the field.  \nWill also be part of the edit button `aria-label`."
                },
                "attribute": "label",
                "reflect": false
            },
            "readonly": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify whether the field is editable or not"
                },
                "attribute": "readonly",
                "reflect": true,
                "defaultValue": "false"
            },
            "value": {
                "type": "any",
                "mutable": true,
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Initial value of the field"
                },
                "attribute": "value",
                "reflect": false
            },
            "validateFn": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "ValidateFn<any>",
                    "resolved": "(value: any) => boolean",
                    "references": {
                        "ValidateFn": {
                            "location": "import",
                            "path": "./editable-field-interface",
                            "id": "src/components/editable-field/editable-field-interface.tsx::ValidateFn"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Function to customize the validation of the data during the update"
                }
            },
            "formatFn": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "FormatFn<any>",
                    "resolved": "(value: any) => string",
                    "references": {
                        "FormatFn": {
                            "location": "import",
                            "path": "./editable-field-interface",
                            "id": "src/components/editable-field/editable-field-interface.tsx::FormatFn"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Function used to format the value"
                }
            },
            "errorMsg": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Error message displayed under the field if validation failed."
                },
                "attribute": "error-msg",
                "reflect": false,
                "defaultValue": "null"
            },
            "size": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsEditableFieldSize",
                    "resolved": "\"l\" | \"m\"",
                    "references": {
                        "WcsEditableFieldSize": {
                            "location": "import",
                            "path": "./editable-field-interface",
                            "id": "src/components/editable-field/editable-field-interface.tsx::WcsEditableFieldSize"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify the size (height) of the editable field."
                },
                "attribute": "size",
                "reflect": true,
                "defaultValue": "'m'"
            }
        };
    }
    static get states() {
        return {
            "currentState": {},
            "isError": {}
        };
    }
    static get events() {
        return [{
                "method": "wcsChange",
                "name": "wcsChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event called at each (valid) update of the field."
                },
                "complexType": {
                    "original": "EditableComponentUpdateEvent",
                    "resolved": "EditableComponentUpdateEvent",
                    "references": {
                        "EditableComponentUpdateEvent": {
                            "location": "import",
                            "path": "./editable-field-interface",
                            "id": "src/components/editable-field/editable-field-interface.tsx::EditableComponentUpdateEvent"
                        }
                    }
                }
            }];
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "value",
                "methodName": "onValueChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "click",
                "method": "onWindowClickEvent",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=editable-field.js.map
