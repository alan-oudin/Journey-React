import { h, Host } from "@stencil/core";
import { isDownArrowKey, isEnterKey, isLeftArrowKey, isRightArrowKey, isSpaceKey, isTabKey, isUpArrowKey, setOrRemoveAttribute } from "../../utils/helpers";
/**
 * @cssprop --wcs-radio-group-gap - Gap between each radio (checkmark + label) in horizontal mode
 *
 *
 * @cssprop --wcs-radio-group-option-background-color - Background color of the radio group option
 *
 * @cssprop --wcs-radio-group-option-height - Height of the radio group option
 * @cssprop --wcs-radio-group-option-padding - Padding of the radio group option
 *
 * @cssprop --wcs-radio-group-option-border-radius - Border radius of the radio group option
 *
 * @cssprop --wcs-radio-group-option-gap - Gap between each radio option
 */
export class RadioGroup {
    constructor() {
        this.value = undefined;
        this.name = undefined;
        this.mode = 'radio';
    }
    onValueChangeHandler(value) {
        this.updateRadioTabIndex(value);
        this.updateAllRadioState();
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.el, attr, value);
    }
    componentDidLoad() {
        this.onValueChangeHandler(this.value);
        this.updateAllRadioModeAndName();
    }
    onSlotChange() {
        this.updateRadioTabIndex(this.value);
        this.updateAllRadioModeAndName();
    }
    updateAllRadioState() {
        this.getSlottedRadios().forEach(r => r.updateState());
    }
    updateAllRadioModeAndName() {
        this.getSlottedRadios().forEach(r => {
            r.mode = this.mode;
            r.name = this.name;
        });
    }
    updateRadioTabIndex(value) {
        const radios = this.getSlottedRadios();
        // Get the first radio that is not disabled and the checked one
        const first = radios.find((radio) => !radio.disabled);
        const checked = radios.find((radio) => radio.value === value && !radio.disabled);
        if (!first && !checked) {
            return;
        }
        // If an enabled checked radio exists, set it to be the focusable radio
        // otherwise we default to focus the first radio
        const focusable = checked || first;
        for (const radio of radios) {
            const tabindex = radio === focusable ? 0 : -1;
            radio.setTabIndex(tabindex);
        }
    }
    getSlottedRadios() {
        return Array.from(this.el.querySelectorAll('wcs-radio'));
    }
    getSlottedRadiosNotDisabled() {
        return Array.from(this.getSlottedRadios().filter(radio => !radio.disabled));
    }
    handleRadioClick(event) {
        this.value = event.detail.value;
        this.wcsChange.emit({
            value: event.detail.value
        });
    }
    async handleKeyDown(ev) {
        const radiosNotDisabled = this.getSlottedRadiosNotDisabled();
        const previousSelected = radiosNotDisabled.findIndex(r => r === ev.target);
        let indexToSelect;
        if ((isSpaceKey(ev) || isEnterKey(ev))) {
            ev.preventDefault();
            indexToSelect = previousSelected;
        }
        else if (isDownArrowKey(ev) || isRightArrowKey(ev)) {
            ev.preventDefault();
            // Check the next wcs-radio from the previous selected
            indexToSelect = (previousSelected + 1) % radiosNotDisabled.length; // to return at the beginning on the list when we are on the last index
        }
        else if (isUpArrowKey(ev) || isLeftArrowKey(ev)) {
            ev.preventDefault();
            // Check the previous wcs-radio from the previous selected
            indexToSelect = (previousSelected - 1 + radiosNotDisabled.length) % radiosNotDisabled.length; // To return at the end of the list when we are on index=0
        }
        else if (isTabKey(ev)) {
            return;
        }
        const radioToSelect = radiosNotDisabled[indexToSelect];
        if (radioToSelect) {
            radioToSelect.focus();
            if (this.value !== radioToSelect.value) {
                this.wcsChange.emit({
                    value: radioToSelect.value
                });
            }
            this.value = radioToSelect.value;
        }
    }
    render() {
        return (h(Host, { key: '3179704d2f1ed56f940941c1777b90a49ecd0ffa', role: "radiogroup" }, h("slot", { key: 'f01213b0c89bc04622601447005e24df07fea376', name: "option", onSlotchange: this.onSlotChange.bind(this) })));
    }
    static get is() { return "wcs-radio-group"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["radio-group.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["radio-group.css"]
        };
    }
    static get properties() {
        return {
            "value": {
                "type": "any",
                "mutable": true,
                "complexType": {
                    "original": "any | any[] | undefined | null",
                    "resolved": "any",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The value of the radio-group. Automatically reflects which radio button is selected."
                },
                "attribute": "value",
                "reflect": false
            },
            "name": {
                "type": "any",
                "mutable": false,
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The name of the control to be set on all radio button children"
                },
                "attribute": "name",
                "reflect": true
            },
            "mode": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "RadioGroupMode",
                    "resolved": "\"horizontal\" | \"option\" | \"radio\"",
                    "references": {
                        "RadioGroupMode": {
                            "location": "import",
                            "path": "./radio-group-interface",
                            "id": "src/components/radio-group/radio-group-interface.ts::RadioGroupMode"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The display mode of the control to be set on all radio button children"
                },
                "attribute": "mode",
                "reflect": true,
                "defaultValue": "'radio'"
            }
        };
    }
    static get events() {
        return [{
                "method": "wcsChange",
                "name": "wcsChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the value has changed."
                },
                "complexType": {
                    "original": "RadioGroupChangeEventDetail",
                    "resolved": "RadioGroupChangeEventDetail",
                    "references": {
                        "RadioGroupChangeEventDetail": {
                            "location": "import",
                            "path": "./radio-group-interface",
                            "id": "src/components/radio-group/radio-group-interface.ts::RadioGroupChangeEventDetail"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "value",
                "methodName": "onValueChangeHandler"
            }, {
                "propName": "name",
                "methodName": "updateAllRadioModeAndName"
            }, {
                "propName": "mode",
                "methodName": "updateAllRadioModeAndName"
            }];
    }
    static get listeners() {
        return [{
                "name": "wcsRadioClick",
                "method": "handleRadioClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "keydown",
                "method": "handleKeyDown",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=radio-group.js.map
