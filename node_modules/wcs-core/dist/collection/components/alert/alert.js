import { h, Host } from "@stencil/core";
/**
 * Alerts are used to communicate a state or an action that has been performed.
 * It has to be used conjunction with the `wcs-alert-drawer` component, or you can use it independently by taking care of
 * the alert visibility
 *
 * @cssprop --wcs-alert-background-color - Background color of the alert
 * @cssprop --wcs-alert-icon-background-color - Background color of the icon
 * @cssprop --wcs-alert-title-color - Color of the title
 * @cssprop --wcs-alert-subtitle-color - Color of the subtitle
 * @cssprop --wcs-alert-dismiss-button-color - Color of the dismiss button
 * @cssprop --wcs-alert-title-font-weight - Font weight of the title
 * @cssprop --wcs-alert-subtitle-font-weight - Font weight of the subtitle
 * @cssprop --wcs-alert-title-font-size - Font size of the title
 * @cssprop --wcs-alert-subtitle-font-size - Font size of the subtitle
 * @cssprop --wcs-alert-border-width - Border width of the alert
 * @cssprop --wcs-alert-border-color - Border color of the alert
 * @cssprop --wcs-alert-border-radius - Border radius of the alert
 * @cssprop --wcs-alert-padding - Padding of the alert
 * @cssprop --wcs-alert-gap - Gap between each element of the alert, icon content and close button
 * @cssprop --wcs-alert-min-width - Minimum width of the alert, default to 100% and it is set by alert-drawer component
 * @cssprop --wcs-alert-progress-bar-height - Height of the progress bar if `showProgressBar` is set to true
 * @cssprop --wcs-alert-progress-bar-background-color - Background color of the progress bar
 */
export class Alert {
    constructor() {
        /** Only active if timeout > 0, becomes true when the alert reaches its maximum display time */
        this.isTimedOut = false;
        /** Indicates if the mouse cursor is hovering over the alert */
        this.isMouseHover = false;
        /**
         * ID of the setTimeout used to manage the alert's lifetime
         * https://developer.mozilla.org/en-US/docs/Web/API/Window/clearTimeout#notes
         */
        this.timeoutId = undefined;
        this.show = true;
        this.intent = 'success';
        this.timeout = 5000;
        this.showProgressBar = false;
    }
    mouseOverHandler() {
        this.mouseHover(true);
    }
    mouseOutHandler() {
        this.mouseHover(false);
    }
    /**
     * Handles the mouse hover state of the alert
     * @param hover - true if the mouse is hovering over the alert, false otherwise
     */
    mouseHover(hover) {
        this.isMouseHover = hover;
        // If the timeout has passed (i.e. the user had the mouse on the component when it expired), we close the alert.
        if (this.isTimedOut && !this.isMouseHover) {
            this.close();
        }
    }
    async componentWillLoad() {
        await this.showAlertAndRunTimeout();
    }
    async componentDidLoad() {
        var _a;
        /*
        Because icon serves also to announce the state of the alert based on the type. We set aria-label on the icon based
        on the type
         */
        (_a = this.annoucementIconHtmlElement) === null || _a === void 0 ? void 0 : _a.setAriaAttribute('aria-hidden', 'false');
        if (this.showProgressBar) {
            this.el.style.setProperty('--wcs-alert-internal-progress-bar-animation-duration', this.timeout / 1000 + 's');
        }
        else {
            this.el.style.setProperty('--wcs-alert-internal-progress-bar-animation-duration', '0s');
        }
    }
    async showAlertAndRunTimeout() {
        if (this.timeout === 0)
            return;
        this.show = true;
        this.timeoutId = setTimeout(() => {
            // If the user has the mouse over the alert, we only indicate that the timemout has expired, and the method that handles the mousehover event will close it
            if (!this.isMouseHover) {
                this.close();
            }
            this.isTimedOut = true;
        }, this.timeout);
    }
    onCloseButtonClick(_) {
        this.close();
    }
    close() {
        this.show = false;
        this.wcsAlertDismiss.emit();
    }
    getMaterialIcon() {
        switch (this.intent) {
            case "success":
                return 'check_circle';
            case "information":
                return 'info';
            case "error":
                return 'error';
            case "warning":
                return 'warning';
        }
    }
    getAriaLabel() {
        switch (this.intent) {
            case "success":
                return 'SuccÃ¨s';
            case "information":
                return 'Information';
            case "error":
                return 'Erreur';
            case "warning":
                return 'Attention';
        }
    }
    disconnectedCallback() {
        /*
         https://developer.mozilla.org/en-US/docs/Web/API/Window/clearTimeout#notes
         (Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.)
         */
        clearTimeout(this.timeoutId);
    }
    render() {
        return (h(Host, { key: '82c9f5879eae7adef41c921ef34b2b9d891c0d6b' }, h("div", { key: 'b46424dfb6b620b62767b6bb8048827f83d116a7', class: "icon-content-container" }, h("wcs-mat-icon", { key: 'ff3a0bc91a73e275936bbe8f77c904f397296551', class: "announcement-icon", ref: (el) => this.annoucementIconHtmlElement = el, icon: this.getMaterialIcon(), "aria-label": this.getAriaLabel(), role: "img", "aria-hidden": false }), h("div", { key: 'ea866940416ddaf5eaf73cec83f30c71b01c41d8', class: "content" }, h("slot", { key: 'd14c321ebdb78b646bb4fc19e613dbd2cc61ed31', name: "title" }), h("slot", { key: '569d6556ea823f82e1d6164ac20361e27c85b592', name: "subtitle" }))), h("wcs-button", { key: 'f13afc31116b7b6fe04e0186128d0288725ace98', shape: "round", size: "s", mode: "clear", class: "close-button wcs-dark", "aria-label": "Fermer cette notification", onClick: ($event) => this.onCloseButtonClick($event) }, h("wcs-mat-icon", { key: '02557c896159ec1a7fdab853a07f7c79c17dd5d7', icon: "close" })), h("div", { key: '9e90e95009da575ca693e5ba4e92b3916ad4ee6f', class: 'progress-bar' + (!this.showProgressBar ? ' hidden' : '') }, h("div", { key: 'c8858551592bb0b1622e2ee19c67a662f31ce068', class: "progress-bar-track" }))));
    }
    static get is() { return "wcs-alert"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["alert.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["alert.css"]
        };
    }
    static get properties() {
        return {
            "show": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Controls the visibility state of the alert.\nThis property is exposed to allow control of the alert's display state and animation timing:\n- Used by wcs-alert-drawer to coordinate exit animations when the alert is dismissed\n- Can be used directly for custom implementations (though using wcs-alert-drawer is recommended)\n- When set to false, it triggers the exit animation if implemented\n\nNote: While direct usage is possible for custom implementations, it's recommended to use\nwcs-alert-drawer for consistent alert management and animations."
                },
                "attribute": "show",
                "reflect": true,
                "defaultValue": "true"
            },
            "intent": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsAlertIntent",
                    "resolved": "\"error\" | \"information\" | \"success\" | \"warning\"",
                    "references": {
                        "WcsAlertIntent": {
                            "location": "import",
                            "path": "./alert-interface",
                            "id": "src/components/alert/alert-interface.ts::WcsAlertIntent"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "intent",
                "reflect": true,
                "defaultValue": "'success'"
            },
            "timeout": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Time duration of the alert visibility\n\n5000ms by default\nIf 0, the alert will not emit `wcsAlertDismiss` event automatically"
                },
                "attribute": "timeout",
                "reflect": false,
                "defaultValue": "5000"
            },
            "showProgressBar": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "show-progress-bar",
                "reflect": false,
                "defaultValue": "false"
            }
        };
    }
    static get events() {
        return [{
                "method": "wcsAlertDismiss",
                "name": "wcsAlertDismiss",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event emitted when the alert is dismissed"
                },
                "complexType": {
                    "original": "void",
                    "resolved": "void",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "el"; }
    static get listeners() {
        return [{
                "name": "mouseover",
                "method": "mouseOverHandler",
                "target": undefined,
                "capture": false,
                "passive": true
            }, {
                "name": "mouseout",
                "method": "mouseOutHandler",
                "target": undefined,
                "capture": false,
                "passive": true
            }];
    }
}
//# sourceMappingURL=alert.js.map
