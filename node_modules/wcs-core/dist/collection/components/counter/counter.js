import { h, Host } from "@stencil/core";
import { inheritAriaAttributes, inheritAttributes, isEndKey, isHomeKey, isKeydown, isKeyup, parseCssTimeValueToMilliseconds, setOrRemoveAttribute } from "../../utils/helpers";
const COUNTER_INHERITED_ATTRS = ['tabindex', 'title'];
/**
 * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
 * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
 *
 * @cssprop --wcs-counter-border-radius - Border radius of the counter
 *
 * @cssprop --wcs-counter-value-color-default - Default color of the value
 * @cssprop --wcs-counter-value-color-disabled - Color of the text when the counter is disabled
 * @cssprop --wcs-counter-font-weight - Font weight of the value
 *
 * @cssprop --wcs-counter-height-m - Height medium of the counter
 * @cssprop --wcs-counter-height-l - Height large of the counter
 * @cssprop --wcs-counter-font-size-m - Font size medium of the counter
 * @cssprop --wcs-counter-font-size-l - Font size large of the counter
 * @cssprop --wcs-counter-padding-m - Padding medium of the counter
 * @cssprop --wcs-counter-padding-l - Padding large of the counter
 *
 * @cssprop --wcs-counter-background-color - Background color of the counter
 * @cssprop --wcs-counter-gap - Gap between the buttons and the label
 * @cssprop --wcs-counter-gap-size-m - Gap between the buttons and the label when the size is M
 * @cssprop --wcs-counter-gap-size-l - Gap between the buttons and the label when the size is L
 * @cssprop --wcs-counter-outline-color-focus - Color of the focus outline
 *
 * @cssprop --wcs-counter-transition-duration - Duration of the animation
 *
 */
export class Counter {
    constructor() {
        this.inheritedAttributes = {};
        /**
         * Default animation duration, in milliseconds
         * @private
         */
        this.ANIMATION_DURATION = 150;
        this.animateRunning = false;
        this.handleDecrement = () => {
            if (this.disabled)
                return;
            if (this.min === undefined || this.value > this.min) {
                // we set animateRunning here to prevent the watch method on value prop from affecting the displayed value
                // before the animation runs.
                this.animateRunning = true;
                this.value -= this.step;
                this.notifyChange();
                this.animate('up');
            }
        };
        this.handleIncrement = () => {
            if (this.disabled)
                return;
            if (this.max === undefined || this.value < this.max) {
                // we set animateRunning here to prevent the watch method on value prop from affecting the displayed value
                // before the animation runs.
                this.animateRunning = true;
                this.value += this.step;
                this.notifyChange();
                this.animate('down');
            }
        };
        this.animate = (direction) => {
            // In case someone call animate function, we want ensured that animateRunning is set to true to prevent other 
            // method to mutate the displayedValue.
            this.animateRunning = true;
            const outliers = Array.from(this.counterContainer.children)
                .filter((span) => span.classList.contains('outliers'));
            this.counterContainer.classList.add('animate-' + direction);
            outliers.forEach((span) => {
                span.hidden = false;
            });
            setTimeout(() => {
                this.counterContainer.classList.remove('animate-' + direction);
                outliers.forEach((span) => {
                    span.hidden = true;
                });
                this.displayedValue = this.value;
                this.animateRunning = false;
            }, this.ANIMATION_DURATION - 20);
        };
        this.size = 'm';
        this.label = undefined;
        this.disabled = false;
        this.min = undefined;
        this.max = undefined;
        this.step = 1;
        this.value = undefined;
        this.displayedValue = undefined;
    }
    componentWillLoad() {
        this.handleValueChange();
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, COUNTER_INHERITED_ATTRS));
    }
    componentDidRender() {
        var _a, _b;
        this.ANIMATION_DURATION = (_b = parseCssTimeValueToMilliseconds((_a = window.getComputedStyle(this.el).getPropertyValue('--wcs-counter-transition-duration')) !== null && _a !== void 0 ? _a : '150ms')) !== null && _b !== void 0 ? _b : 150;
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.spinButton, attr, value);
    }
    /**
     * Current value change => handle event and interval
     */
    valueChange(newVal, oldVal) {
        if (oldVal === newVal)
            return;
        this.handleValueChange();
    }
    handleValueChange() {
        this.setMinimumIfValueIsUndefinedOrNull();
        this.ensureValueIsNotOutOfMinMax();
        this.updateDisplayValueIfNoAnimationRunning();
    }
    updateDisplayValueIfNoAnimationRunning() {
        if (!this.animateRunning) {
            this.displayedValue = this.value;
        }
    }
    ensureValueIsNotOutOfMinMax() {
        if (this.max !== undefined && this.value > this.max) {
            this.value = this.max;
        }
        else if (this.min !== undefined && this.value < this.min) {
            this.value = this.min;
        }
    }
    setMinimumIfValueIsUndefinedOrNull() {
        var _a;
        if (this.value === undefined || this.value === null) {
            this.value = (_a = this.min) !== null && _a !== void 0 ? _a : 0;
        }
    }
    onKeyDown(_event) {
        if (this.disabled)
            return;
        if (isKeyup(_event)) {
            _event.preventDefault();
            this.handleIncrement();
        }
        if (isKeydown(_event)) {
            _event.preventDefault();
            this.handleDecrement();
        }
        if (isHomeKey(_event)) {
            _event.preventDefault();
            if (this.min != null) {
                this.value = this.min;
                this.displayedValue = this.value;
                this.notifyChange();
            }
        }
        if (isEndKey(_event)) {
            _event.preventDefault();
            if (this.max != null) {
                this.value = this.max;
                this.displayedValue = this.value;
                this.notifyChange();
            }
        }
    }
    notifyChange() {
        this.wcsChange.emit({
            value: this.value
        });
    }
    render() {
        return (h(Host, { key: '6f1d46e231cc1f88a92a2faa0122e1ed7b9dd834' }, h("div", { key: 'c3ed2c944c2a8f61ab862411b1d503a84ac37ae4', class: "counter" }, h("wcs-button", { key: 'c0d0d41e07a99ef0730b22d029529e629ff2f8d3', class: "wcs-primary", shape: "round", size: "s", tabindex: -1, onClick: () => this.handleDecrement(), onBlur: (event) => this.wcsBlur.emit(event), disabled: this.disabled || this.value === this.min }, h("wcs-mat-icon", { key: '5003db6a007f8ede51d567a76ea18160fdb60949', icon: "remove", size: "s" })), h("div", { key: 'ae3b0ca61a95fe908583df73748b7e7d19242fd0', class: "counter-container", ref: input => this.counterContainer = input }, h("span", { key: '499a0d0ff7f38fcae6664b118991aeb39f5d6034', id: "outlier-down", class: "outliers", hidden: true, "aria-hidden": "true" }, this.displayedValue - this.step), h("span", Object.assign({ key: '62cab421b796106f0b2957e4d8445266bd6ba754', tabindex: this.disabled ? -1 : 0, role: "spinbutton", ref: (el) => this.spinButton = el, class: "current-value", onBlur: (event) => this.wcsBlur.emit(event), onKeyDown: (event) => this.onKeyDown(event), "aria-disabled": this.disabled ? 'true' : null, "aria-valuenow": this.value, "aria-valuetext": this.value, "aria-valuemin": this.min, "aria-valuemax": this.max, "aria-label": this.label }, this.inheritedAttributes), this.displayedValue), h("span", { key: '339b6949d2b64262085f7bda19897f9533166cb4', id: "outlier-up", class: "outliers", hidden: true, "aria-hidden": "true" }, this.displayedValue + this.step)), h("wcs-button", { key: 'ee77cee6c9d08225c1844d1c4703ea6868c054da', class: "wcs-primary", shape: "round", size: "s", tabindex: -1, onClick: () => this.handleIncrement(), onBlur: (event) => this.wcsBlur.emit(event), disabled: this.disabled || this.value === this.max }, h("wcs-mat-icon", { key: 'b1b6cc395186ee871801d47ad2b9b62791f64b29', icon: "add", size: "s" })))));
    }
    static get is() { return "wcs-counter"; }
    static get encapsulation() { return "shadow"; }
    static get delegatesFocus() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["counter.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["counter.css"]
        };
    }
    static get properties() {
        return {
            "size": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsCounterSize",
                    "resolved": "\"l\" | \"m\"",
                    "references": {
                        "WcsCounterSize": {
                            "location": "import",
                            "path": "./counter-interface",
                            "id": "src/components/counter/counter-interface.ts::WcsCounterSize"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify the size (height) of the counter."
                },
                "attribute": "size",
                "reflect": true,
                "defaultValue": "'m'"
            },
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The label of the counter.<br/>\ne.g. Number of passengers, train carriages, railroad tracks..."
                },
                "attribute": "label",
                "reflect": false
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specify whether the counter is disabled or not."
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            },
            "min": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The minimum value of the counter.\nIf the value of the min attribute isn't set, then the element has no minimum value."
                },
                "attribute": "min",
                "reflect": false
            },
            "max": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The maximum value of the counter.\nIf the value of the max attribute isn't set, then the element has no maximum value."
                },
                "attribute": "max",
                "reflect": false
            },
            "step": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Defines by how much the counter will be incremented or decremented."
                },
                "attribute": "step",
                "reflect": false,
                "defaultValue": "1"
            },
            "value": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The current value of the counter."
                },
                "attribute": "value",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "displayedValue": {}
        };
    }
    static get events() {
        return [{
                "method": "wcsChange",
                "name": "wcsChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the value of the counter has changed."
                },
                "complexType": {
                    "original": "CounterChangeEventDetail",
                    "resolved": "CounterChangeEventDetail",
                    "references": {
                        "CounterChangeEventDetail": {
                            "location": "import",
                            "path": "./counter-interface",
                            "id": "src/components/counter/counter-interface.ts::CounterChangeEventDetail"
                        }
                    }
                }
            }, {
                "method": "wcsBlur",
                "name": "wcsBlur",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the counter loses focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "value",
                "methodName": "valueChange"
            }];
    }
}
//# sourceMappingURL=counter.js.map
