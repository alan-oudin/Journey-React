import { h, Host } from "@stencil/core";
import { inheritAriaAttributes, inheritAttributes, setOrRemoveAttribute } from "../../utils/helpers";
import { SelectArrow } from "../select/select-arrow";
import { createPopper } from "@popperjs/core";
const TABS_INHERITED_ATTRS = [];
/**
 * Tabs component to switch between tab content. Use in conjunction with `wcs-tab`.
 *
 * ## Accessibility guidelines ðŸ’¡
 * > - Mobile display should be used for narrower screens (automatically set by default).
 * > - The component respects the W3C [tab pattern](https://www.w3.org/WAI/ARIA/apg/patterns/tabs/)
 *
 * @cssprop --wcs-tabs-indicator-height - Height of the tabs indicator
 * @cssprop --wcs-tabs-indicator-background-color - Background color of the tabs indicator
 * @cssprop --wcs-tabs-indicator-border-radius - Border radius of the tabs indicator
 * @cssprop --wcs-tabs-color-default - Text color of the tabs
 * @cssprop --wcs-tabs-color-hover - Text color of the tabs when hovered
 * @cssprop --wcs-tabs-color-press - Text color of the tabs when pressed
 * @cssprop --wcs-tabs-color-focus - Text color of the tabs when focused
 * @cssprop --wcs-tabs-color-selected - Text color of the tabs when selected
 * @cssprop --wcs-tabs-background-color-focus - Background color of the tabs when focused
 * @cssprop --wcs-tabs-background-color-hover - Background color of the tabs when hovered
 * @cssprop --wcs-tabs-background-color-press - Background color of the tabs when pressed
 * @cssprop --wcs-tabs-border-radius - Border radius of the tabs
 * @cssprop --wcs-tabs-border-color-focus - Outline color on a focused tab
 * @cssprop --wcs-tabs-font-weight-default - Font weight of the tabs
 * @cssprop --wcs-tabs-font-weight-selected - Font weight of the tabs when selected
 * @cssprop --wcs-tabs-padding-top - Padding top of the tabs
 * @cssprop --wcs-tabs-padding-right - Padding right of the tabs
 * @cssprop --wcs-tabs-padding-bottom - Padding bottom of the tabs
 * @cssprop --wcs-tabs-padding-left - Padding left of the tabs
 * @cssprop --wcs-tabs-headers-border-bottom - Border bottom (gutter) below the tabs
 * @cssprop --wcs-tabs-transition-duration - Transition duration of the tabs
 * @cssprop --wcs-tabs-mobile-breakpoint - Breakpoint for mobile display (default: 575px)
 * @cssprop --wcs-tabs-mobile-overlay-border-width - Border width of the mobile overlay
 * @cssprop --wcs-tabs-mobile-overlay-border-color - Border color of the mobile overlay
 * @cssprop --wcs-tabs-mobile-overlay-background-color - Background color of the mobile overlay
 * @cssprop --wcs-tabs-mobile-overlay-padding - Padding of the mobile overlay
 * @cssprop --wcs-tabs-mobile-overlay-border-radius - Border radius of the mobile overlay
 * @cssprop --wcs-tabs-mobile-gap - Gap between the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-padding - Padding of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-height - Height of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-font-weight-default - Default weight of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-font-weight-active - Active font weight of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-font-size - Font size of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-color - Text color of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-background-color-default - Default background color of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-background-color-focus - Focused background color of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-background-color-hover - Hovered background color of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-background-color-press - Pressed background color of the mobile tabs in the overlay
 * @cssprop --wcs-tabs-mobile-border-radius - Border radius of the mobile tabs in the overlay
 */
export class Tabs {
    constructor() {
        this.inheritedAttributes = {};
        this.tabsId = tabsId++;
        this.align = 'start';
        this.selectedIndex = 0;
        this.selectedKey = undefined;
        this.headersOnly = false;
        this.gutter = undefined;
        this.description = undefined;
        this.mobileOverlayExpanded = false;
        this.mobile = false;
        this.headers = [];
        this.currentActiveTabIndex = 0;
    }
    selectedIndexChanged(newValue) {
        this.currentActiveTabIndex = newValue;
    }
    selectedTabkeyChanged(newValue) {
        this.updateCurrentActiveIndexByTabKey(newValue);
    }
    onMobileChange(newValue) {
        // Remove the popper instance when switching from mobile to desktop for performance
        if (!newValue) {
            this.popper.destroy();
            this.popper = null;
        }
    }
    emitActiveTabChange() {
        this.tabChange.emit({
            tabName: this.headers[this.currentActiveTabIndex],
            tabIndex: this.currentActiveTabIndex,
            selectedKey: this.tabs[this.currentActiveTabIndex].itemKey
        });
    }
    updateCurrentActiveIndexByTabKey(newValue) {
        for (let i = 0; i < this.tabs.length; i++) {
            const tab = this.tabs[i];
            if (tab.itemKey === newValue) {
                this.currentActiveTabIndex = i;
            }
        }
    }
    onTabLoaded() {
        this.refreshHeaders();
    }
    onWindowClickEvent(event) {
        if (this.mobile) {
            const clickedOnMobileButtonOrOverlay = event.composedPath().some(el => el === this.mobileButton || el === this.popoverDiv);
            if (this.mobileOverlayExpanded && !clickedOnMobileButtonOrOverlay) {
                this.mobileOverlayExpanded = false;
            }
        }
    }
    /**
     * Init resize observer for mobile
     */
    tabsDidLoadWithResizeObserver() {
        const smallBreakpoint = getComputedStyle(this.el).getPropertyValue('--wcs-tabs-mobile-breakpoint') || '575px';
        const smallBreakpointValue = parseInt(smallBreakpoint, 10);
        return new ResizeObserver(entry => {
            const cr = entry[0].contentRect;
            const paddingRight = cr.right - cr.width;
            const paddingLeft = cr.left;
            // Switch to mobile mode if the screen is smaller than the breakpoint
            this.mobile = cr.width <= smallBreakpointValue - (paddingLeft + paddingRight);
        });
    }
    initMobileOverlay() {
        this.popper = createPopper(this.mobileButton, this.popoverDiv, {
            placement: 'bottom-start',
            strategy: 'fixed',
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8]
                    }
                }
            ]
        });
    }
    componentDidLoad() {
        this.putTabsInCorrectDivIfTheyAreNot();
        this.refreshHeaders();
        if (this.selectedIndex) {
            this.currentActiveTabIndex = this.selectedIndex;
        }
        if (this.selectedKey) {
            this.updateCurrentActiveIndexByTabKey(this.selectedKey);
        }
        if (!this.resizeObserver) {
            this.resizeObserver = this.tabsDidLoadWithResizeObserver();
            this.resizeObserver.observe(document.body);
        }
    }
    componentDidRender() {
        if (this.mobile) {
            if (!this.popper) {
                this.initMobileOverlay();
            }
            else {
                this.popper.update();
            }
        }
    }
    // XXX: Firefox < 63
    putTabsInCorrectDivIfTheyAreNot() {
        const tabDiv = this.el.shadowRoot.querySelector('.wcs-tabs');
        if (tabDiv.querySelector('slot') === null) {
            Array.from(this.el.querySelectorAll('wcs-tab'))
                .filter(node => node.parentNode !== tabDiv)
                .forEach(tab => {
                if (tab.parentElement.isEqualNode(this.el)) {
                    this.el.removeChild(tab);
                    tabDiv.appendChild(tab);
                }
            });
        }
    }
    handleKeyDown(ev, tabIndex) {
        var _a, _b;
        const target = ev.target;
        switch (ev.key) {
            case ' ':
            case 'Enter': {
                this.selectTabAndEmitChangeEvent(tabIndex);
                ev.preventDefault();
                break;
            }
            case 'ArrowLeft': {
                if ((_a = target.previousElementSibling) === null || _a === void 0 ? void 0 : _a.classList.contains('wcs-tab-header')) {
                    target.previousElementSibling.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'ArrowRight': {
                if ((_b = target.nextElementSibling) === null || _b === void 0 ? void 0 : _b.classList.contains('wcs-tab-header')) {
                    target.nextElementSibling.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'Home': {
                const firstTab = this.el.shadowRoot.querySelector('.wcs-tab-header:first-child');
                if (firstTab) {
                    firstTab.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'End': {
                const lastTab = this.el.shadowRoot.querySelector('.wcs-tab-header:last-child');
                if (lastTab) {
                    lastTab.focus();
                    ev.preventDefault();
                }
                break;
            }
        }
    }
    handleKeyDownMobile(ev, tabIndex) {
        var _a, _b;
        const target = ev.target;
        switch (ev.key) {
            case ' ':
            case 'Enter': {
                this.selectTabAndEmitChangeEvent(tabIndex);
                ev.preventDefault();
                break;
            }
            case 'ArrowUp': {
                if ((_a = target.previousElementSibling) === null || _a === void 0 ? void 0 : _a.classList.contains('wcs-tab-header-mobile')) {
                    target.previousElementSibling.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'ArrowDown': {
                if ((_b = target.nextElementSibling) === null || _b === void 0 ? void 0 : _b.classList.contains('wcs-tab-header-mobile')) {
                    target.nextElementSibling.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'Home': {
                const firstTab = this.el.shadowRoot.querySelector('.wcs-tab-header-mobile:first-child');
                if (firstTab) {
                    firstTab.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'End': {
                const lastTab = this.el.shadowRoot.querySelector('.wcs-tab-header-mobile:last-child');
                if (lastTab) {
                    lastTab.focus();
                    ev.preventDefault();
                }
                break;
            }
            case 'Escape': {
                this.mobileOverlayExpanded = false;
                ev.preventDefault();
                break;
            }
        }
    }
    refreshHeaders() {
        this.headers = [];
        this.tabs
            .forEach(x => {
            this.headers.push(x.getAttribute('header'));
        });
    }
    get tabs() {
        var _a;
        const tabsEl = this.el.shadowRoot.querySelector('.wcs-tabs');
        // FIXME: problem with this selector being too greedy in ff < 63
        const tabs = this.el.shadowRoot.querySelectorAll('.wcs-tabs > wcs-tab');
        return tabs.length !== 0
            ? tabs
            : (tabsEl === null || tabsEl === void 0 ? void 0 : tabsEl.querySelector('slot'))
                ? (_a = tabsEl === null || tabsEl === void 0 ? void 0 : tabsEl.querySelector('slot')) === null || _a === void 0 ? void 0 : _a.assignedElements()
                : [];
    }
    selectTabAndEmitChangeEvent(index) {
        var _a;
        this.currentActiveTabIndex = index;
        this.emitActiveTabChange();
        if (this.mobile) {
            this.mobileOverlayExpanded = false;
            (_a = this.mobileButton) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    componentWillUpdate() {
        if (!this.headersOnly) {
            this.updateTabVisibility();
        }
        else {
            this.hideAllTabsContent();
        }
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, TABS_INHERITED_ATTRS));
    }
    disconnectedCallback() {
        var _a;
        if (this.popper) {
            this.popper.destroy();
            this.popper = null;
        }
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.mobile ? this.popoverDiv : this.nativeTablist, attr, value);
    }
    updateTabVisibility() {
        this.tabs.forEach((el, idx) => {
            if (idx !== this.currentActiveTabIndex) {
                el.hidden = true;
            }
            else {
                el.hidden = false;
            }
        });
    }
    hideAllTabsContent() {
        this.tabs.forEach((el) => el.hidden = true);
    }
    onMobileButtonClick() {
        this.mobileOverlayExpanded = !this.mobileOverlayExpanded;
        const tabElementToFocus = this.popoverDiv.querySelectorAll('[role=tab]')[this.currentActiveTabIndex];
        requestAnimationFrame(() => {
            tabElementToFocus === null || tabElementToFocus === void 0 ? void 0 : tabElementToFocus.focus();
        });
    }
    onMobileButtonKeyDown(ev) {
        if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {
            this.onMobileButtonClick();
        }
    }
    mobileLayout() {
        return [
            h("button", { id: "mobile-button", class: "wcs-tab-header active", "aria-controls": "menu", role: "button", "aria-expanded": this.mobileOverlayExpanded ? 'true' : 'false', ref: el => this.mobileButton = el, onClick: () => this.onMobileButtonClick(), onKeyDown: (evt) => this.onMobileButtonKeyDown(evt), onBlur: ($event) => $event.stopImmediatePropagation() }, h("span", null, this.headers[this.currentActiveTabIndex], " ", h(SelectArrow, { up: this.mobileOverlayExpanded }))),
            h("div", Object.assign({ class: (this.mobileOverlayExpanded ? 'show ' : '') + 'popover', role: "tablist", id: "menu", "aria-label": this.description, "aria-orientation": "vertical", ref: el => this.popoverDiv = el, tabIndex: -1 }, this.inheritedAttributes), this.headers.map((header, idx) => h("div", { class: 'wcs-tab-header-mobile ' + (this.currentActiveTabIndex === idx ? 'mobile-active' : ''), onClick: () => this.selectTabAndEmitChangeEvent(idx), onKeyDown: evt => this.handleKeyDownMobile(evt, idx), tabIndex: this.currentActiveTabIndex === idx ? 0 : -1, role: "tab", id: `tabs-id-${this.tabsId}-tab-id-${idx}`, "aria-controls": `tabs-id-${this.tabsId}-tab-panel-${idx}`, "aria-label": header, "aria-selected": this.currentActiveTabIndex === idx ? 'true' : 'false' }, h("span", null, header))))
        ];
    }
    desktopLayout() {
        return (this.headers.map((header, idx) => h("div", { class: 'wcs-tab-header ' + (this.currentActiveTabIndex === idx ? 'active' : ''), onClick: () => this.selectTabAndEmitChangeEvent(idx), onKeyDown: evt => this.handleKeyDown(evt, idx), tabIndex: this.currentActiveTabIndex === idx ? 0 : -1, role: "tab", id: `tabs-id-${this.tabsId}-tab-id-${idx}`, "aria-controls": `tabs-id-${this.tabsId}-tab-panel-${idx}`, "aria-label": header, "aria-selected": this.currentActiveTabIndex === idx ? 'true' : 'false' }, h("span", null, header))));
    }
    render() {
        return (h(Host, { key: '072fa3551b320a6415c20a3107500f2bee2aa690' }, h("div", Object.assign({ key: '294008dc27c2ff694119c3ce136caf866a0802b3', class: "wcs-tabs-headers", role: this.mobile ? null : 'tablist', ref: (el) => (this.nativeTablist = el), "aria-orientation": this.mobile ? null : 'horizontal', "aria-label": this.mobile ? null : this.description }, (!this.mobile && this.inheritedAttributes)), this.mobile ? this.mobileLayout() : this.desktopLayout()), h("div", { key: 'd20bb48fe80434a6797c86d206a86d11081b92ea', class: "wcs-tabs" }, h("slot", { key: 'd4a31047e41627dc9c2cfb63f201e5e7ddc40f15', onSlotchange: () => this.onTabsSlotChange(), name: "wcs-tab" }))));
    }
    /**
     * Observe when a new tab panel is added to the slot to let's handle accessibility properties for tabs panel:
     * - id: to let header tab refers it proper panel
     * - aria-label: take the same name as it's referenced header name
     *
     * @private
     */
    onTabsSlotChange() {
        let tabId = 0;
        this.refreshHeaders();
        this.tabs.forEach(tab => {
            tab.setAttribute("aria-label", this.headers.at(tabId));
            // set an ID to set aria-controls on header tab 
            // (https://www.w3.org/WAI/ARIA/apg/patterns/tabs/examples/tabs-automatic/#:~:text=Refers%20to%20the%20element)
            tab.setAttribute("id", `tabs-id-${this.tabsId}-tab-panel-${tabId}`);
            tabId++;
        });
    }
    static get is() { return "wcs-tabs"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["tabs.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["tabs.css"]
        };
    }
    static get properties() {
        return {
            "align": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsTabsAlignment",
                    "resolved": "\"center\" | \"end\" | \"start\"",
                    "references": {
                        "WcsTabsAlignment": {
                            "location": "import",
                            "path": "./tabs-interface",
                            "id": "src/components/tabs/tabs-interface.ts::WcsTabsAlignment"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Tab headers alignment."
                },
                "attribute": "align",
                "reflect": true,
                "defaultValue": "'start'"
            },
            "selectedIndex": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Current selected tab index.\nStarts at 0."
                },
                "attribute": "selected-index",
                "reflect": false,
                "defaultValue": "0"
            },
            "selectedKey": {
                "type": "any",
                "mutable": false,
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "selected-key",
                "reflect": false
            },
            "headersOnly": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to\nseparately render the tab content."
                },
                "attribute": "headers-only",
                "reflect": true,
                "defaultValue": "false"
            },
            "gutter": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Determines if tabs header should have a border at the bottom"
                },
                "attribute": "gutter",
                "reflect": true
            },
            "description": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Description is used to provide aria-label for the tabs container which has `role=\"tablist\"`."
                },
                "attribute": "description",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "mobileOverlayExpanded": {},
            "mobile": {},
            "headers": {},
            "currentActiveTabIndex": {}
        };
    }
    static get events() {
        return [{
                "method": "tabChange",
                "name": "tabChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "\nEmitted when the selected tab change."
                },
                "complexType": {
                    "original": "WcsTabChangeEvent",
                    "resolved": "WcsTabChangeEvent",
                    "references": {
                        "WcsTabChangeEvent": {
                            "location": "import",
                            "path": "./tabs-interface",
                            "id": "src/components/tabs/tabs-interface.ts::WcsTabChangeEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "selectedIndex",
                "methodName": "selectedIndexChanged"
            }, {
                "propName": "selectedKey",
                "methodName": "selectedTabkeyChanged"
            }, {
                "propName": "mobile",
                "methodName": "onMobileChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "tabLoaded",
                "method": "onTabLoaded",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "click",
                "method": "onWindowClickEvent",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
}
let tabsId = 0;
//# sourceMappingURL=tabs.js.map
