import { forceUpdate, h, Host } from "@stencil/core";
import { getSortOrderInteger, } from "./grid-interface";
import { v4 as uuid } from "uuid";
import { cloneDeep, get, isEqual } from "lodash-es";
import { GridPagination } from "../grid-pagination/grid-pagination";
import { getActionForKeyboardEvent } from "./grid-keyboard-event";
import { GridRadio } from "./grid-radio";
import { inheritAriaAttributes, inheritAttributes, setOrRemoveAttribute } from "../../utils/helpers";
const GRID_INHERITED_ATTRS = ['title'];
/**
 * The grid component is a complex component used as an HTML table to display collections of data.
 *
 * @cssprop --wcs-grid-gap - Gap between grid cells (horizontal, vertical using `border-spacing` property)
 * @cssprop --wcs-grid-vertical-align - Vertical alignment of grid cells
 * @cssprop --wcs-grid-outline-color - Outline color for grid cells
 *
 * @cssprop --wcs-grid-cell-text-color - Text color of all grid cells
 * @cssprop --wcs-grid-cell-padding-horizontal - Horizontal padding of grid cells
 * @cssprop --wcs-grid-cell-padding-vertical - Vertical padding of grid cells
 * @cssprop --wcs-grid-cell-border-bottom - Bottom border of grid cells
 * @cssprop --wcs-grid-cell-separator-border - Separator border between grid cells
 * @cssprop --wcs-grid-first-cell-border-radius - Border radius of the first cell in a row
 * @cssprop --wcs-grid-last-cell-border-radius - Border radius of the last cell in a row
 *
 * @cssprop --wcs-grid-highlight-color - Background color for selected rows
 * @cssprop --wcs-grid-row-background-color - Background color of all rows
 * @cssprop --wcs-grid-row-odd-background-color - Background color of odd rows
 * @cssprop --wcs-grid-row-even-background-color - Background color of even rows
 *
 * @cssprop --wcs-grid-header-background-color-default - Default background color of the header
 * @cssprop --wcs-grid-header-background-color-hover - Background color of the header on hover
 * @cssprop --wcs-grid-header-background-color-press - Background color of the header on press
 * @cssprop --wcs-grid-header-text-color - Text color of the header
 * @cssprop --wcs-grid-header-font-weight - Font weight of the header
 * @cssprop --wcs-grid-header-font-size - Font size of the header
 * @cssprop --wcs-grid-header-line-height - Line height of the header
 * @cssprop --wcs-grid-header-padding-vertical - Vertical padding of the header
 * @cssprop --wcs-grid-header-padding-horizontal - Horizontal padding of the header
 * @cssprop --wcs-grid-header-border-left - Left border between header cells (default is none
 * @cssprop --wcs-grid-header-border-radius - Border radius of the header
 * @cssprop --wcs-grid-header-border-bottom - Bottom border of the header
 * @cssprop --wcs-grid-header-transition-duration - Transition duration of the header
 * @cssprop --wcs-grid-first-header-background-color - Background color of the first header cell
 * @cssprop --wcs-grid-first-header-border-radius - Border radius of the first header cell
 * @cssprop --wcs-grid-last-header-border-radius - Border radius of the last header cell
 * @cssprop --wcs-grid-column-selection-width - Width of the selection column (when selectionConfig is defined)
 * @cssprop --wcs-grid-header-sort-arrow-color-default - Color of the sort arrow in the header
 * @cssprop --wcs-grid-header-sort-arrow-color-hover - Color of the sort arrow in the header when hovered
 *
 * @csspart all-rows-checkbox - CSS part for the checkbox in the selection column that selects all rows
 * @csspart row-checkbox - CSS part for the checkbox of each row in the selection column
 *
 * @slot grid-column - The slot containing the column of the grid in the `<thead>`
 * @slot grid-pagination - The slot containing the pagination of the grid below the `<table>`
 *
 */
export class Grid {
    constructor() {
        this.inheritedAttributes = {};
        this.serverMode = false;
        this.data = undefined;
        this.loading = undefined;
        this.selectionConfig = 'none';
        this.selectedItems = [];
        this.wcsGridPaginationId = undefined;
        this.rowIdPath = undefined;
        this.rowCssPartsFn = (_) => null;
        this.columns = undefined;
        this.paginationEl = undefined;
        this.rows = [];
        this.cursorPosition = { col: 0, row: 1 };
    }
    onCursorPositionChange(newValue) {
        // Notify all grid columns that the cursorPosition has changed
        this.getGridColumnsFromTemplate().forEach(g => g.cursorPosition = newValue);
    }
    onDataChange(newValue) {
        this.updateGridRows(newValue);
        this.refreshSort(false);
    }
    onSelectedItemsPropertyChange(newValue) {
        this.updateSelectionWithValues(newValue);
    }
    onFocus(event) {
        var _a;
        (_a = this.getElementToFocusAtCursorPosition()) === null || _a === void 0 ? void 0 : _a.focus();
        this.wcsFocus.emit(event);
    }
    onBlur(event) {
        this.wcsBlur.emit(event);
    }
    /**
     * Set focus on the first cell of the grid
     */
    async focusFirstCell() {
        var _a;
        this.cursorPosition = { col: this.selectionConfig === 'none' ? 0 : 1, row: 1 };
        (_a = this.getElementToFocusAtCursorPosition()) === null || _a === void 0 ? void 0 : _a.focus();
    }
    /**
     * If selectionConfig is different from `none`, that means that an extra column for radio or checkbox is rendered
     * in the table.
     */
    hasSelectionColumn() {
        return this.selectionConfig !== 'none';
    }
    /**
     * Returns the element to focus at the current cursor position : it can be a cell (td, th) to focus or a nested
     * checkbox / radio element if the selection mode is single or multiple
     */
    getElementToFocusAtCursorPosition() {
        var _a, _b;
        const el = (_a = this.gridElementsWithCoordinates.find(cell => { var _a, _b; return cell.col === ((_a = this.cursorPosition) === null || _a === void 0 ? void 0 : _a.col) && cell.row === ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.row); })) === null || _a === void 0 ? void 0 : _a.el;
        return this.hasSelectionColumn()
            ? (_b = el.querySelector('wcs-checkbox,input[type="radio"]')) !== null && _b !== void 0 ? _b : el
            : el;
    }
    moveCursorPosition(directionX, directionY) {
        var _a;
        this.cursorPosition = {
            col: directionX === 'first' ? 0 :
                directionX === 'last' ? this.totalDisplayedColumnCount() - 1 :
                    Math.min(Math.max(this.cursorPosition.col + directionX, 0), this.totalDisplayedColumnCount() - 1),
            row: directionY === 'first' ? 0 :
                directionY === 'last' ? this.getRowsForCurrentPage().length :
                    Math.min(Math.max(this.cursorPosition.row + directionY, 0), this.getRowsForCurrentPage().length)
        };
        this.handleCursorPositionOnEmptyTh();
        (_a = this.getElementToFocusAtCursorPosition()) === null || _a === void 0 ? void 0 : _a.focus();
    }
    /**
     * When the grid has selectionConfig single, an empty th appears at col=0, row=0.
     * It should not be focusable so the cursor navigates to col=1, row=0 instead.
     */
    handleCursorPositionOnEmptyTh() {
        if (this.selectionConfig === 'single' && this.cursorPosition.col === 0 && this.cursorPosition.row === 0) {
            this.cursorPosition = {
                col: 1,
                row: 0
            };
        }
    }
    onHiddenColumnChange() {
        // We use forceUpdate because the fact of hiding a column or not does not modify the internal structure of the grid (WcsGridRow).
        // Hide a column only impacts the way it is rendered but the grid-column remains in the dom and in our internal model.
        forceUpdate(this);
        this.cursorPosition = { col: 0, row: 1 };
    }
    onKeyDown(_event) {
        var _a;
        if (((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.tagName) === 'WCS-GRID-PAGINATION') {
            return;
        }
        let type;
        switch (this.selectionConfig) {
            case "multiple":
                type = 'grid_selection_multiple';
                break;
            case "single":
                type = 'grid_selection_single';
                break;
            case "none":
                type = 'grid_no_selection';
                break;
        }
        const actionsFromKeyboardEvents = getActionForKeyboardEvent(_event, type);
        // If we have at least one associated actions, we prevent the default behavior of the event. 
        // Except if the action is a focus move (we have to handle the preventDefault behavior ourselves in the action implementation)
        if (actionsFromKeyboardEvents.length != 0) {
            _event.preventDefault();
        }
        for (const actionFromKeyboardEvent of actionsFromKeyboardEvents) {
            this.doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent, _event);
        }
    }
    doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent, event) {
        switch (actionFromKeyboardEvent.kind) {
            case "FocusCell":
                switch (actionFromKeyboardEvent.target) {
                    case "up":
                        this.moveCursorPosition(0, -1);
                        break;
                    case "down":
                        this.moveCursorPosition(0, 1);
                        break;
                    case "left":
                        this.moveCursorPosition(-1, 0);
                        break;
                    case "right":
                        this.moveCursorPosition(1, 0);
                        break;
                    case "first_of_row":
                        this.moveCursorPosition('first', 0);
                        break;
                    case "last_of_row":
                        this.moveCursorPosition('last', 0);
                        break;
                    case "first_of_grid":
                        this.moveCursorPosition('first', 'first');
                        break;
                    case "last_of_grid":
                        this.moveCursorPosition('last', 'last');
                        break;
                    default:
                        break;
                }
            case "SelectRow":
                switch (actionFromKeyboardEvent.target) {
                    case "one":
                        event.preventDefault();
                        if (this.cursorPosition.row > 0) {
                            this.onRowSelection(this.rows[this.cursorPosition.row - 1]);
                        }
                        break;
                    case "all":
                        this.selectAllRows();
                        break;
                    default:
                        break;
                }
                break;
            default:
                throw new Error("Internal error");
        }
    }
    onClick(_event) {
        const clickedGridElement = _event.composedPath()
            .filter(x => ['TD', 'TH']
            .includes(x.nodeName))[0];
        if (!clickedGridElement)
            return; // it can be the grid pagination node, we don't want to handle it
        const clickedGridElementWithCoordinates = this.gridElementsWithCoordinates.find(e => e.el === clickedGridElement);
        this.cursorPosition = {
            col: clickedGridElementWithCoordinates.col,
            row: clickedGridElementWithCoordinates.row,
        };
    }
    updateSelectionWithValues(values) {
        if (this.selectionConfig === 'single') {
            this.rows.map(r => r.selected = false);
            for (const row of this.rows) {
                if (isEqual(row.data, values)) {
                    row.selected = true;
                    break; // only one line can be selected
                }
            }
        }
        else if (this.selectionConfig === 'multiple') {
            this.rows.map(r => r.selected = false);
            for (const row of this.rows) {
                if (values.find(x => isEqual(x, row.data))) {
                    row.selected = true;
                }
            }
        }
        this.rows = cloneDeep(this.rows);
    }
    wcsGridRowToWcsGridRowData(row) {
        return { selected: row.selected, page: row.page, data: row.data };
    }
    updateGridRows(data) {
        const rows = [];
        if (data && this.columns) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (let i = 0; i < data.length; i++) {
                const row = {
                    uuid: uuid(),
                    data: data[i],
                    selected: false,
                    cells: []
                };
                let index = 0;
                for (const column of this.columns) {
                    column.columnPosition = index + (this.hasSelectionColumn() ? 1 : 0);
                    index++;
                    row.cells.push({
                        content: get(data[i], column.path),
                        column,
                        formatter: column.formatter
                    });
                }
                rows.push(row);
            }
            this.rows = rows;
            this.updatePageIndex();
        }
    }
    componentDidLoad() {
        this.columns = this.getGridColumnsFromTemplate();
        this.paginationEl = this.wcsGridPaginationId
            ? document.getElementById(this.wcsGridPaginationId)
            : this.getGridPaginationsFromTemplate()[0];
        this.updateGridRows(this.data);
        if (this.selectedItems) {
            this.updateSelectionWithValues(this.selectedItems);
        }
        this.refreshSort(true);
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, GRID_INHERITED_ATTRS));
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.nativeTable, attr, value);
    }
    /**
     * Handle existing column's filters (defined before the grid is instantiated)
     * @private
     */
    refreshSort(refreshOthersColumnsSortOrderState) {
        //fixme: why the column property can be null or undefined?
        // Explanation: https://stenciljs.com/docs/component-lifecycle
        // The @watch can be called before the componentDidLoad() which sets the columns
        if (this.columns) {
            const [first, ...other] = this.columns.filter(c => c.sortOrder !== 'none');
            if (first && !this.serverMode) {
                this.sortBy(first);
            }
            refreshOthersColumnsSortOrderState && this.disableSortOrderForColumns(other);
        }
    }
    disableSortOrderForColumns(columns) {
        columns === null || columns === void 0 ? void 0 : columns.forEach(c => c.sortOrder = 'none');
    }
    getGridColumnsFromTemplate() {
        const slotted = this.el.shadowRoot.querySelector('slot[name="grid-column"]');
        return slotted.assignedElements();
    }
    getGridPaginationsFromTemplate() {
        const slotted = this.el.shadowRoot.querySelector('slot[name="grid-pagination"]');
        return slotted.assignedElements();
    }
    get gridElementsWithCoordinates() {
        const gridElements = [];
        // If selection multiple, the first cell should be added to the list
        if (this.selectionConfig === 'multiple') {
            gridElements.push({
                el: this.el.shadowRoot.querySelector('th'),
                row: 0,
                col: 0
            });
        }
        this.getGridColumnsFromTemplate()
            .filter(col => !col.hidden)
            .forEach((col, index) => {
            gridElements.push({
                el: col.shadowRoot.querySelector('th'),
                row: 0,
                col: index + (this.hasSelectionColumn() ? 1 : 0),
            });
        });
        this.el.shadowRoot.querySelectorAll('td').forEach((cell, index) => {
            gridElements.push({
                el: cell,
                row: 1 + Math.floor(index / this.totalDisplayedColumnCount()),
                col: index % this.totalDisplayedColumnCount(),
            });
        });
        return gridElements;
    }
    sortChangeEventHandler(event) {
        // fixme: why the column property can be null or undefined?
        // Explanation: https://stenciljs.com/docs/component-lifecycle
        // The @Listen can be called before the componentDidLoad() which sets the columns
        if (event.detail.order === 'none' || !this.columns)
            return;
        // We keep only one active sort column
        this.disableSortOrderForColumns(this.columns.filter(c => c !== event.detail.column));
        if (this.serverMode)
            return;
        this.sortBy(event.detail.column);
        this.updatePageIndex();
    }
    /**
     * Sorts the grid rows according to the given column's configuration
     * @param column Column from which to extract the sorting configuration
     * @private
     */
    sortBy(column) {
        if (column.sortFn) {
            this.rows = cloneDeep(this.rows)
                .sort((a, b) => column.sortFn(a.data, b.data, column) * getSortOrderInteger(column.sortOrder));
        }
        else {
            this.rows = cloneDeep(this.rows)
                .sort((a, b) => {
                const path = column.path;
                return ((get(a.data, path) < get(b.data, path)) ? -1 : (get(a.data, path) > get(b.data, path)) ? 1 : 0) * getSortOrderInteger(column.sortOrder);
            });
        }
    }
    /**
     * Update the page's number of all rows
     */
    updatePageIndex() {
        if (!this.serverMode && this.paginationEl) {
            this.paginationEl.itemsCount = this.data.length;
            this.paginationEl.pageCount = Math.ceil(this.data.length / this.paginationEl.pageSize);
            if (this.paginationEl.pageCount <= 1) {
                this.paginationEl.currentPage = GridPagination.INDEX_FIRST_PAGE;
            }
            else if (this.paginationEl.pageCount > 0 && this.paginationEl.currentPage + 1 > this.paginationEl.pageCount) {
                this.paginationEl.currentPage = this.paginationEl.pageCount - 1;
            }
            const rows = cloneDeep(this.rows);
            rows.forEach((row, index) => row.page = Math.floor(index / this.paginationEl.pageSize));
            this.rows = [...rows];
        }
    }
    paginationChangeEventHandler() {
        this.onPaginationChange();
    }
    paginationChangeEventHandlerOutside(event) {
        if (this.wcsGridPaginationId && this.wcsGridPaginationId === event.target.id) {
            this.onPaginationChange();
        }
    }
    onPaginationChange() {
        if (this.serverMode)
            return;
        this.updatePageIndex();
    }
    onRowSelection(row) {
        if (this.selectionConfig === 'single') {
            this.rows.filter(r => r.uuid !== row.uuid).map(r => r.selected = false);
        }
        row.selected = !row.selected;
        if (this.selectionConfig !== 'single' || row.selected) {
            this.wcsGridSelectionChange.emit({
                selectedRows: this.selectedRows.map(row => this.wcsGridRowToWcsGridRowData(row)),
                changedRow: this.wcsGridRowToWcsGridRowData(row)
            });
        }
        this.rows = cloneDeep(this.rows);
    }
    get selectedRows() {
        return this.rows.filter(r => r.selected);
    }
    selectAllRows() {
        const rows = this.getRowsForCurrentPage();
        const selected = !this.allRowsAreSelected();
        rows.map(r => r.selected = selected);
        this.wcsGridAllSelectionChange.emit({ rows: selected ? rows.map(row => this.wcsGridRowToWcsGridRowData(row)) : [] });
        this.wcsGridSelectionChange.emit({
            selectedRows: this.selectedRows.map(row => this.wcsGridRowToWcsGridRowData(row)),
            changedRow: 'allCheckbox'
        });
        this.rows = cloneDeep(this.rows);
    }
    allRowsAreSelected() {
        const rows = this.getRowsForCurrentPage();
        return rows.length > 0 && rows.filter(row => row.selected).length === rows.length;
    }
    getRowsForCurrentPage() {
        // When in server mode, the state exists outside the internal grid model, so we must rely on the DOM state
        if (!this.serverMode && this.paginationEl) {
            return this.rows.filter(row => row.page === this.paginationEl.currentPage);
        }
        return this.rows;
    }
    renderSelectionColumn(row, rowIndex) {
        var _a, _b, _c, _d;
        switch (this.selectionConfig) {
            case 'none':
                return;
            case 'single':
                return h("td", { "aria-colindex": this.atLeastOneColumnHidden() ? 1 : null, tabIndex: ((_a = this.cursorPosition) === null || _a === void 0 ? void 0 : _a.col) === 0 && rowIndex + 1 === ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.row) ? 0 : -1 }, h(GridRadio, { checked: row.selected, row: row, rowIndex: rowIndex + 1, totalRows: this.rows.length, onClick: (row) => {
                        if (!row.selected) {
                            this.onRowSelection(row);
                        }
                    } }));
            case 'multiple':
                return h("td", { "aria-colindex": this.atLeastOneColumnHidden() ? 1 : null, tabIndex: ((_c = this.cursorPosition) === null || _c === void 0 ? void 0 : _c.col) === 0 && rowIndex + 1 === ((_d = this.cursorPosition) === null || _d === void 0 ? void 0 : _d.row) ? 0 : -1 }, h("wcs-checkbox", { tabIndex: -1, part: "row-checkbox", checked: row.selected, onWcsChange: this.onRowSelection.bind(this, row) }));
        }
    }
    getCellContent(row, cell) {
        if (cell.formatter) {
            return cell.formatter(h, cell.column, this.wcsGridRowToWcsGridRowData(row));
        }
        return cell.content;
    }
    /**
     * Returns the total number of columns
     * @private
     */
    totalColumnCount() {
        if (!this.columns) {
            return 0;
        }
        return this.columns.length + (this.hasSelectionColumn() ? 1 : 0);
    }
    /**
     * Returns the total number of columns that are not hidden
     * @private
     */
    totalDisplayedColumnCount() {
        var _a, _b;
        return (_b = this.totalColumnCount() - ((_a = this.columns) === null || _a === void 0 ? void 0 : _a.filter(col => col.hidden).length)) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Returns true if at least one column is hidden from the table
     * @private
     */
    atLeastOneColumnHidden() {
        return this.totalDisplayedColumnCount() !== this.totalColumnCount();
    }
    render() {
        var _a, _b, _c, _d;
        return (h(Host, { key: '98d13e7497ec9d9ecd3e149b3f6986e16bc5cc2a' }, h("table", Object.assign({ key: 'a44825cf71ff284a5204e9d922c0eba2c2ca23f4', role: "grid", ref: (el) => (this.nativeTable = el), "aria-rowcount": !this.loading && ((_a = this.rows) === null || _a === void 0 ? void 0 : _a.length), "aria-colcount": !this.loading && this.totalDisplayedColumnCount() }, this.inheritedAttributes), h("thead", { key: '336578d350ae8082a19fa6798af35f2fdd015ff9' }, h("tr", { key: 'fdb38402ea5c58dd77dad7df2ef97d54c521123c', "aria-rowindex": "1" }, this.selectionConfig === 'none' ? ''
            : h("th", { class: "wcs-grid-selection-column" }, this.selectionConfig === 'single' ? '' :
                h("wcs-checkbox", { tabIndex: ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.col) === 0
                        && ((_c = this.cursorPosition) === null || _c === void 0 ? void 0 : _c.row) === 0 ? 0 : -1, part: "all-rows-checkbox", checked: this.allRowsAreSelected(), onWcsChange: this.selectAllRows.bind(this) })), h("slot", { key: '2d68b72fac0251dab9f519cf84c25c96262c193b', name: "grid-column" }))), h("tbody", { key: '4156e796ac5a81170b5dba011159f8e6bb7a7e60' }, this.loading
            ? h("tr", { "aria-busy": "true" }, h("td", { colSpan: this.totalColumnCount(), class: "loading" }, h("wcs-spinner", null)))
            : (_d = this.rows) === null || _d === void 0 ? void 0 : _d.filter(row => this.serverMode || !this.paginationEl || row.page === this.paginationEl.currentPage).map((row, index) => this.renderRow(row, index)))), h("slot", { key: 'c683eb883707ffbd1fed22d86ececb595f70c2c0', name: "grid-pagination" })));
    }
    /**
     * Returns the row with all mapped cells inside.
     * The aria-rowindex here starts at 2 because the header row starts at index 1.
     * @private
     */
    renderRow(row, rowIndex) {
        var _a, _b;
        let hiddenColumnCount = 0;
        return h("tr", { class: row.selected ? 'selected' : '', part: (_a = this.rowCssPartsWithoutEmptyList(row)) === null || _a === void 0 ? void 0 : _a.join(' '), "aria-selected": row.selected ? 'true' : null, "aria-rowindex": rowIndex + 2 }, this.renderSelectionColumn(row, rowIndex), (_b = row.cells) === null || _b === void 0 ? void 0 :
            _b.map((cell, cellIndex) => {
                var _a, _b;
                if (cell.column.hidden) {
                    hiddenColumnCount++;
                    return;
                }
                const nonHiddenColumnIndex = cellIndex - hiddenColumnCount + 1 + (this.hasSelectionColumn() ? 1 : 0);
                const cursorIsOnCell = nonHiddenColumnIndex - 1 === ((_a = this.cursorPosition) === null || _a === void 0 ? void 0 : _a.col)
                    && rowIndex + 1 === ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.row);
                return cell.column.customCells
                    ? (h("td", { tabIndex: cursorIsOnCell ? 0 : -1, "aria-colindex": this.atLeastOneColumnHidden() ? nonHiddenColumnIndex : null }, h("slot", { name: cell.column.id + '-' + get(row.data, this.rowIdPath) })))
                    : (h("td", { tabIndex: cursorIsOnCell ? 0 : -1, "aria-colindex": this.atLeastOneColumnHidden() ? nonHiddenColumnIndex : null, part: cell.column.path + '-column' }, this.getCellContent(row, cell)));
            }));
    }
    rowCssPartsWithoutEmptyList(row) {
        const parts = this.rowCssPartsFn(row);
        return (parts === null || parts === void 0 ? void 0 : parts.length) === 0 ? null : parts;
    }
    static get is() { return "wcs-grid"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["grid.scss", "grid-radio.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["grid.css", "grid-radio.css"]
        };
    }
    static get properties() {
        return {
            "serverMode": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Manage sort and pagination with a backend server when set to `true`"
                },
                "attribute": "server-mode",
                "reflect": true,
                "defaultValue": "false"
            },
            "data": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "any[]",
                    "resolved": "any[]",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Contains the data to display in the table from a js object"
                }
            },
            "loading": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Flag to display a spinner during data loading"
                },
                "attribute": "loading",
                "reflect": true
            },
            "selectionConfig": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "WcsGridSelectionConfig",
                    "resolved": "\"multiple\" | \"none\" | \"single\"",
                    "references": {
                        "WcsGridSelectionConfig": {
                            "location": "import",
                            "path": "./grid-interface",
                            "id": "src/components/grid/grid-interface.ts::WcsGridSelectionConfig"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Used to manage grid's row selection.  \n\"none\": no row can be selected.  \n\"multiple\": several rows can be selected.  \n\"single\": one row only can be selected."
                },
                "attribute": "selection-config",
                "reflect": false,
                "defaultValue": "'none'"
            },
            "selectedItems": {
                "type": "any",
                "mutable": false,
                "complexType": {
                    "original": "any | any[]",
                    "resolved": "any",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Set the selected items (rows)"
                },
                "attribute": "selected-items",
                "reflect": false,
                "defaultValue": "[]"
            },
            "wcsGridPaginationId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Automatically set by the component to reference the wcs-grid-pagination HTML element by its id."
                },
                "attribute": "wcs-grid-pagination-id",
                "reflect": false
            },
            "rowIdPath": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Name of the object's key that will be used to display the cells whose `keyValue` attribute matches to the\nobject's value for this key. Useful for custom cells."
                },
                "attribute": "row-id-path",
                "reflect": false
            },
            "rowCssPartsFn": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "RowCssPartsFn",
                    "resolved": "(row: WcsGridRow) => string[]",
                    "references": {
                        "RowCssPartsFn": {
                            "location": "import",
                            "path": "./grid-interface",
                            "id": "src/components/grid/grid-interface.ts::RowCssPartsFn"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Function to add css parts to the grid rows, this allows you to customize the rows with css parts directly\nin you're application stylesheet."
                },
                "defaultValue": "(_) => null"
            }
        };
    }
    static get states() {
        return {
            "columns": {},
            "paginationEl": {},
            "rows": {},
            "cursorPosition": {}
        };
    }
    static get events() {
        return [{
                "method": "wcsGridSelectionChange",
                "name": "wcsGridSelectionChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event emitted when a row is selected or unselected"
                },
                "complexType": {
                    "original": "WcsGridSelectionEventDetails",
                    "resolved": "WcsGridSelectionEventDetails",
                    "references": {
                        "WcsGridSelectionEventDetails": {
                            "location": "import",
                            "path": "./grid-interface",
                            "id": "src/components/grid/grid-interface.ts::WcsGridSelectionEventDetails"
                        }
                    }
                }
            }, {
                "method": "wcsGridAllSelectionChange",
                "name": "wcsGridAllSelectionChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event emitted when all rows are selected or unselected"
                },
                "complexType": {
                    "original": "WcsGridAllRowSelectedEventDetails",
                    "resolved": "WcsGridAllRowSelectedEventDetails",
                    "references": {
                        "WcsGridAllRowSelectedEventDetails": {
                            "location": "import",
                            "path": "./grid-interface",
                            "id": "src/components/grid/grid-interface.ts::WcsGridAllRowSelectedEventDetails"
                        }
                    }
                }
            }, {
                "method": "wcsFocus",
                "name": "wcsFocus",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event emitted when the grid has focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }, {
                "method": "wcsBlur",
                "name": "wcsBlur",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event emitted when the grid loses focus."
                },
                "complexType": {
                    "original": "FocusEvent",
                    "resolved": "FocusEvent",
                    "references": {
                        "FocusEvent": {
                            "location": "global",
                            "id": "global::FocusEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "focusFirstCell": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Set focus on the first cell of the grid",
                    "tags": []
                }
            },
            "setAriaAttribute": {
                "complexType": {
                    "signature": "(attr: AriaAttributeName, value: string | null | undefined) => Promise<void>",
                    "parameters": [{
                            "name": "attr",
                            "type": "\"role\" | `aria-${string}`",
                            "docs": ""
                        }, {
                            "name": "value",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "AriaAttributeName": {
                            "location": "import",
                            "path": "../../utils/mutable-aria-attribute",
                            "id": "src/utils/mutable-aria-attribute.ts::AriaAttributeName"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "cursorPosition",
                "methodName": "onCursorPositionChange"
            }, {
                "propName": "data",
                "methodName": "onDataChange"
            }, {
                "propName": "selectedItems",
                "methodName": "onSelectedItemsPropertyChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "focus",
                "method": "onFocus",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "blur",
                "method": "onBlur",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "wcsHiddenChange",
                "method": "onHiddenColumnChange",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "keydown",
                "method": "onKeyDown",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "mousedown",
                "method": "onClick",
                "target": undefined,
                "capture": false,
                "passive": true
            }, {
                "name": "wcsSortChange",
                "method": "sortChangeEventHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "wcsGridPaginationChange",
                "method": "paginationChangeEventHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "wcsGridPaginationChange",
                "method": "paginationChangeEventHandlerOutside",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
}
/**
 * Pour resize le tableau
 * https://www.brainbell.com/javascript/making-resizable-table-js.htmls
 *
 */
//# sourceMappingURL=grid.js.map
