'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-6f0140d8.js');

const HorizontalStep = ({ step, checkOnComplete, complete, passed, active, first, disable, onClick }) => {
    return (
    /*
    When using list-style: none in CSS, it removes the semantic of the list in Safari.
    So we add role="list" manually to provide semantic to screen readers
    https://www.scottohara.me/blog/2019/01/12/lists-and-safari.html
    https://css-tricks.com/snippets/css/remove-list-markers-without-affecting-semantics/
     */
    index.h("li", { role: "listitem", class: "graphic-step", "data-first": first },
        first ? null : (index.h("wcs-progress-bar", { value: passed ? 100 : 0, "aria-hidden": "true" })),
        index.h("wcs-button", { style: { 'backgroundColor': 'white' }, "aria-label": step.text, onClick: _ => onClick(step), ref: (el) => {
                active ? el.setAriaAttribute('aria-current', 'step') : el.setAriaAttribute('aria-current', null);
            }, shape: "round", mode: (active || complete) && !step.disable ? 'plain' : 'stroked', disabled: disable }, getButtonContent(step.button, checkOnComplete, complete, active))));
};
const getButtonContent = (stepButton, checkOnComplete, complete, active) => {
    if (checkOnComplete && complete && !active) {
        return (index.h("wcs-mat-icon", { size: "m", icon: "done", family: "outlined" }));
    }
    switch (stepButton.kind) {
        case 'Icon':
            return (index.h("wcs-mat-icon", { size: "m", icon: stepButton.iconName, family: stepButton.family ? stepButton.family : 'outlined' }));
        case 'Text':
            return (stepButton.text);
    }
};

const horizontalStepperCss = ":host{--wcs-horizontal-step-text-color-default:var(--wcs-semantic-color-text-secondary);--wcs-horizontal-step-text-color-active:var(--wcs-semantic-color-foreground-brand);--wcs-horizontal-step-text-color-disabled:var(--wcs-semantic-color-text-disabled);display:block}:host .steps{list-style:none;margin:0;padding:0;display:flex;flex-direction:row;flex:1}:host .graphic-step{display:flex;position:relative;flex-direction:row;flex:1;align-items:center}:host .graphic-step wcs-button{z-index:1;mix-blend-mode:darken}:host .graphic-step[data-first]{flex:0}:host wcs-progress-bar{--wcs-progress-bar-border-radius:0;flex:1;margin:0 -1px}:host .label-container{justify-content:space-between;display:flex;flex-direction:row;margin-top:var(--wcs-semantic-spacing-base)}:host .label-container>*{width:100%;text-align:center;flex:1;color:var(--wcs-horizontal-step-text-color-default);font-weight:500}:host .label-container>*[data-disable]{color:var(--wcs-horizontal-step-text-color-disabled)}:host .label-container>*[data-current]{color:var(--wcs-horizontal-step-text-color-active)}:host .label-container>div[data-first]{margin-right:calc(var(--wcs-semantic-size-m, 40px) / 2);text-align:left;flex:0.5}:host .label-container>div[data-last]{margin-left:calc(var(--wcs-semantic-size-m, 40px) / 2);text-align:right;flex:0.5}";
const WcsHorizontalStepperStyle0 = horizontalStepperCss;

const HorizontalStepper = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.wcsHorizontalStepClick = index.createEvent(this, "wcsHorizontalStepClick", 7);
        this.currentStep = 0;
        this.steps = undefined;
        this.mode = 'nonLinear';
        this.checkOnComplete = undefined;
        this.internalCurrentStepIndex = undefined;
    }
    componentWillLoad() {
        this.internalCurrentStepIndex = this.currentStep;
        if (this.steps.length < 1) {
            throw new Error('You must add at least one step');
        }
    }
    onCurrentStepChange(newValue, oldValue) {
        //Check if the function is called before the component has finished its initialization in which case we do nothing
        if (this.internalCurrentStepIndex !== undefined) {
            const stepInterval = Math.abs(oldValue - newValue);
            this.el.style.setProperty('--wcs-progress-bar-animation-duration', 350 / stepInterval + 'ms');
            if (newValue !== oldValue) {
                for (let i = 0; i < stepInterval; i++) {
                    setTimeout(() => {
                        this.internalCurrentStepIndex -= (oldValue - newValue) > 0 ? 1 : -1;
                        if (i === stepInterval - 1) {
                            this.el.style.removeProperty('--wcs-progress-bar-animation-duration');
                        }
                    }, (i * (375 / stepInterval)));
                }
            }
        }
    }
    async previous() {
        this.navigateToIndex(this.internalCurrentStepIndex - 1, 'backward');
    }
    async next() {
        this.navigateToIndex(this.internalCurrentStepIndex + 1, 'forward');
    }
    navigateToIndex(index, direction) {
        var _a, _b;
        if (index >= 0 && index <= this.steps.length - 1) {
            if (((_a = this.steps[index]) === null || _a === void 0 ? void 0 : _a.complete) || ((_b = this.steps[index]) === null || _b === void 0 ? void 0 : _b.disable)) {
                this.navigateToIndex(index + (direction === 'forward' ? 1 : -1), direction);
            }
            else {
                this.currentStep = index;
            }
        }
    }
    render() {
        return (index.h(index.Host, { key: '8f1c81f4e21159bbbd34a6caaaa66ce13e8b7a92' }, index.h("ul", { key: '1a512c67669a402100153db33936a6752d53b6ab', role: "list", class: "steps" }, this.steps.map((step, index$1) => (index.h(HorizontalStep, { step: step, passed: index$1 <= this.internalCurrentStepIndex, checkOnComplete: this.checkOnComplete, complete: this.isComplete(step, index$1), active: index$1 === this.internalCurrentStepIndex, first: index$1 === 0, disable: this.isDisable(step, index$1), onClick: step => this.wcsHorizontalStepClick.emit({ step, index: index$1 }) })))), this.renderLabels()));
    }
    isComplete(step, index) {
        return index <= this.internalCurrentStepIndex || step.complete;
    }
    renderLabels() {
        if (this.steps.map(s => s.text).every(s => !s)) {
            return null;
        }
        else {
            return index.h("div", { class: "label-container", "aria-hidden": "true" }, this.steps.map((step, index$1) => (index.h("div", { "data-first": index$1 === 0, "data-current": index$1 === this.internalCurrentStepIndex && !step.disable, "data-disable": this.isDisable(step, index$1), "data-last": index$1 === this.steps.length - 1 }, index.h("span", null, step.text)))));
        }
    }
    isDisable(step, index) {
        return step.disable || (this.mode === 'linear' && (!this.isNextPossibleStep(index) && this.internalCurrentStepIndex < index));
    }
    isNextPossibleStep(index) {
        var _a;
        if (index === 0)
            return true;
        if (((_a = this.steps[index - 1]) === null || _a === void 0 ? void 0 : _a.disable) || this.previousStepIsCompleteAndNotActive(index))
            return this.isNextPossibleStep(index - 1);
        return this.internalCurrentStepIndex === index - 1;
    }
    previousStepIsCompleteAndNotActive(index) {
        var _a;
        return ((_a = this.steps[index - 1]) === null || _a === void 0 ? void 0 : _a.complete) && index - 1 !== this.internalCurrentStepIndex;
    }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "currentStep": ["onCurrentStepChange"]
    }; }
};
HorizontalStepper.style = WcsHorizontalStepperStyle0;

exports.wcs_horizontal_stepper = HorizontalStepper;

//# sourceMappingURL=wcs-horizontal-stepper.cjs.entry.js.map