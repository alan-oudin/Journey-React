'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-6f0140d8.js');
const selectArrow = require('./select-arrow-a8a47fe4.js');
const helpers = require('./helpers-2f1a8ddc.js');
const keyboardEvent = require('./keyboard-event-40ecdc27.js');
const popper = require('./popper-8d6e7fca.js');

/**
 * We follow this pattern https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/examples/menu-button-actions/
 * @param event
 * @param currentState
 * @param type
 */
function getActionForKeyboardEvent(event, currentState) {
    const keyboardShortcut = keyboardEvent.keyboardShortcutFromKeyboardEvent(event);
    if (keyboardShortcut === 'UNKNOWN') {
        return [];
    }
    switch (currentState) {
        case 'closed':
            // We handle every available shortcut for the closed state
            switch (keyboardShortcut) {
                case 'UP_ARROW':
                    return [{ kind: 'OpenMenu' }, { kind: 'FocusItem', target: 'last' }];
                case 'DOWN_ARROW':
                    return [{ kind: 'OpenMenu' }, { kind: 'FocusItem', target: 'first' }];
                case 'SPACE':
                case 'ENTER':
                    return [{ kind: 'OpenMenu' }, { kind: 'FocusItem', target: 'first' }];
            }
            break;
        case 'opened':
            // We handle every available shortcut for the opened state
            switch (keyboardShortcut) {
                case 'UP_ARROW':
                    return [{ kind: 'FocusItem', target: 'previous' }];
                case 'DOWN_ARROW':
                    return [{ kind: 'FocusItem', target: 'next' }];
                case 'HOME':
                    return [{ kind: 'FocusItem', target: 'first' }];
                case 'END':
                    return [{ kind: 'FocusItem', target: 'last' }];
                case 'ESCAPE':
                case 'MAJ+TAB':
                case 'TAB':
                    return [{ kind: 'CloseMenu' }];
            }
            break;
        default:
            throw Error('Unknown error');
    }
    return [];
}

const dropdownCss = ":host{display:flex;--wcs-dropdown-outline-color-focus:var(--wcs-semantic-color-border-focus-base);--wcs-dropdown-padding-empty:var(--wcs-semantic-spacing-large);--wcs-dropdown-plain-arrow-color:var(--wcs-semantic-color-foreground-action-primary-default);--wcs-dropdown-stroked-arrow-color:var(--wcs-semantic-color-foreground-action-secondary-default);--wcs-dropdown-clear-arrow-color:var(--wcs-semantic-color-foreground-action-tertiary-default);--wcs-dropdown-arrow-color-disabled:var(--wcs-semantic-color-text-disabled);--wcs-dropdown-overlay-max-height:360px;--wcs-dropdown-overlay-padding:var(--wcs-semantic-spacing-base);--wcs-dropdown-overlay-background-color:var(--wcs-semantic-color-background-surface-primary);--wcs-dropdown-overlay-border-width:var(--wcs-semantic-border-width-default);--wcs-dropdown-overlay-border-radius:var(--wcs-semantic-border-radius-base);--wcs-dropdown-overlay-border-color:var(--wcs-semantic-color-border-secondary)}:host wcs-button{height:fit-content}:host svg{margin-right:-0.25rem}button{position:absolute;opacity:0;height:1px;width:1px;overflow:hidden;clip-path:inset(50%);white-space:nowrap;outline:0;outline-offset:0}button:focus-visible+wcs-button{outline:var(--wcs-semantic-border-width-large) dashed var(--wcs-dropdown-outline-color-focus);outline-offset:var(--wcs-semantic-spacing-small);border-radius:var(--wcs-button-border-radius)}@supports not selector(button:focus-visible + wcs-button){button:focus-within+wcs-button{outline:var(--wcs-semantic-border-width-large) dashed var(--wcs-dropdown-outline-color-focus);outline-offset:var(--wcs-semantic-spacing-small);border-radius:var(--wcs-button-border-radius)}}.wcs-button-content-wrapper{display:flex;align-items:center}.popover{display:none;border:var(--wcs-dropdown-overlay-border-width) solid var(--wcs-dropdown-overlay-border-color);border-radius:var(--wcs-dropdown-overlay-border-radius);background-color:var(--wcs-dropdown-overlay-background-color);z-index:9999}.show{display:block}.container{min-width:calc(10 * var(--wcs-semantic-size-base));border-radius:inherit;overflow:hidden;padding:var(--wcs-dropdown-overlay-padding);background-color:var(--wcs-dropdown-overlay-background-color)}:host([mode=clear]) .arrow{fill:var(--wcs-dropdown-clear-arrow-color)}:host([mode=stroked]) .arrow{fill:var(--wcs-dropdown-stroked-arrow-color)}:host([mode=plain]) .arrow{fill:var(--wcs-dropdown-plain-arrow-color)}:host([disabled]) .arrow{fill:var(--wcs-dropdown-arrow-color-disabled)}#arrow,#arrow::before{position:absolute;width:8px;height:8px;background:inherit;border:var(--wcs-dropdown-overlay-border-width) solid var(--wcs-dropdown-overlay-border-color)}#arrow{visibility:hidden;z-index:-1}#arrow::before{visibility:visible;content:\"\";transform:rotate(45deg)}#is-empty{display:block;width:20ch;padding:0 var(--wcs-dropdown-padding-empty)}.popover[data-popper-placement^=top]>#arrow{bottom:-5px}.popover[data-popper-placement^=bottom]>#arrow{top:-6px}.popover[data-popper-placement^=left]>#arrow{right:-4px}.popover[data-popper-placement^=right]>#arrow{left:-6px}";
const WcsDropdownStyle0 = dropdownCss;

const DROPDOWN_INHERITED_ATTRS = ['tabindex'];
const Dropdown = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.inheritedAttributes = {};
        this.noArrow = false;
        this.mode = 'stroked';
        this.shape = 'normal';
        this.size = 'm';
        this.disabled = false;
        this.placement = 'bottom-end';
        this.expanded = false;
    }
    get items() {
        return Array.from(this.el.querySelectorAll('wcs-dropdown-item'));
    }
    placementChange() {
        this.popper.setOptions(Object.assign(Object.assign({}, this.popper.state.options), { placement: this.placement })).then(_ => this.popper.update());
    }
    onBlur() {
        this.clearLastFocusedItem();
        this.expanded = false;
    }
    componentDidLoad() {
        this.popper = popper.createPopper(this.wcsButton, this.popoverDiv, {
            placement: this.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8]
                    }
                }
            ]
        });
        this.fixForFirefoxBelow63();
    }
    fixForFirefoxBelow63() {
        // If the items appear out of the slot we place them back
        const items = this.el.querySelectorAll('wcs-dropdown-item');
        const container = this.el.querySelector('.container');
        if (items.length > 0 && container) {
            items.forEach(i => {
                this.el.removeChild(i);
                container.appendChild(i);
            });
        }
    }
    onButtonClick(_) {
        this.clearLastFocusedItem();
        this.expanded = !this.expanded;
        if (this.expanded) {
            this.focusItem(0);
        }
    }
    onWindowClickEvent(event) {
        const clickedOnDropdownOrChildren = helpers.clickTargetIsElementOrChildren(event, this.el);
        if (this.expanded && !clickedOnDropdownOrChildren) {
            this.expanded = false;
        }
    }
    dropdownItemClick(_) {
        this.expanded = false;
        this.nativeButton.focus();
    }
    onKeyDown(_event) {
        const currentState = this.expanded ? 'opened' : 'closed';
        const actionsFromKeyboardEvents = getActionForKeyboardEvent(_event, currentState);
        // If we have at least one associated actions, we prevent the default behavior of the event. 
        // Except if the action is a focus move (we have to handle the preventDefault behavior ourselves in the action implementation)
        if (actionsFromKeyboardEvents.length != 0) {
            _event.preventDefault();
        }
        for (const actionFromKeyboardEvent of actionsFromKeyboardEvents) {
            this.doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent);
        }
    }
    async setAriaAttribute(attr, value) {
        helpers.setOrRemoveAttribute(this.nativeButton, attr, value);
    }
    doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent) {
        switch (actionFromKeyboardEvent.kind) {
            case 'OpenMenu':
                this.expanded = true;
                this.focusItem(0);
                break;
            case 'CloseMenu':
                this.expanded = false;
                this.nativeButton.focus();
                break;
            case 'ClearFocus':
                this.clearLastFocusedItem();
                break;
            case 'FocusItem':
                switch (actionFromKeyboardEvent.target) {
                    case 'previous':
                        this.focusClosestItem('previous');
                        break;
                    case 'next':
                        this.focusClosestItem('next');
                        break;
                    case 'first':
                        this.focusItem(0);
                        break;
                    case 'last':
                        this.focusItem(this.items.length - 1);
                        break;
                }
                break;
        }
    }
    /**
     * Removes the focus and tabindex 0 of the last focused item if any.
     * @private
     */
    clearLastFocusedItem() {
        if (this.lastFocusedItemElement) {
            this.lastFocusedItemElement.tabIndex = -1;
            this.lastFocusedItemElement = null;
        }
    }
    focusItem(indexToFocus) {
        this.clearLastFocusedItem();
        this.lastFocusedItemElement = this.items[indexToFocus];
        if (this.lastFocusedItemElement) {
            this.lastFocusedItemElement.tabIndex = 0;
            requestAnimationFrame(() => {
                var _a;
                (_a = this.lastFocusedItemElement) === null || _a === void 0 ? void 0 : _a.focus();
            });
        }
    }
    focusClosestItem(direction) {
        const indexToFocus = this.getClosestActiveItemIndexForDirection(direction);
        if (indexToFocus === -1)
            return;
        this.focusItem(indexToFocus);
    }
    getClosestActiveItemIndexForDirection(direction) {
        const items = this.items;
        let currentIndex = Array.from(items).indexOf(this.lastFocusedItemElement);
        const MIN_INDEX = 0;
        const MAX_INDEX = items.length - 1;
        if (direction === 'next' && currentIndex < MAX_INDEX) {
            currentIndex++;
        }
        else if (direction === 'previous' && currentIndex > MIN_INDEX) {
            currentIndex--;
        }
        else {
            // Used to scroll through items infinitely with keyboard
            if (direction === 'next' && currentIndex >= MAX_INDEX) {
                currentIndex = 0;
            }
            if (direction === 'previous' && currentIndex === MIN_INDEX) {
                currentIndex = MAX_INDEX;
            }
        }
        return currentIndex;
    }
    componentDidRender() {
        if (this.popper) {
            this.popper.update();
        }
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, helpers.inheritAriaAttributes(this.el)), helpers.inheritAttributes(this.el, DROPDOWN_INHERITED_ATTRS));
    }
    render() {
        return (index.h(index.Host, { key: '96be2f9df0a80b4d6c88cf15419ff29cb001c695' }, index.h("button", Object.assign({ key: '562456822837e6ff61ed23569335e42ad4e36df9', id: "dropdown-button", "aria-controls": "menu", disabled: this.disabled, "aria-haspopup": "true", role: "button", "aria-expanded": this.expanded ? 'true' : 'false', ref: el => this.nativeButton = el, onClick: ($event) => this.onButtonClick($event), onBlur: ($event) => $event.stopImmediatePropagation() }, this.inheritedAttributes), "Dropdown"), index.h("wcs-button", { key: '66348725409b810219dd1bd4658611c63bbb5eb8', mode: this.mode, shape: this.shape, disabled: this.disabled, size: this.size, ref: el => this.wcsButton = el, "aria-hidden": "true", tabindex: -1, onClick: ($event) => this.onButtonClick($event), onBlur: (e) => e.stopImmediatePropagation() }, index.h("div", { key: '028e06637e35ecc14b66cf74fba32dc59d58121a', class: "wcs-button-content-wrapper" }, index.h("slot", { key: '7f7e2db54f9b5d3a20588c48c1d3fd6750187017', name: "placeholder" }), this.noArrow ? null : (index.h(selectArrow.SelectArrow, { up: this.expanded })))), index.h("div", { key: '7f6f4efe22cab63033b3e7775791856ed8e1b921', class: (this.expanded ? 'show ' : '') + 'popover', id: "menu", role: "menu", "aria-labelledby": "dropdown-button", tabindex: -1, ref: el => this.popoverDiv = el }, index.h("div", { key: 'ca7ce6adea1005d7126d4ae060ada55e9d3b6d70', role: "presentation", id: "arrow", "data-popper-arrow": true }), index.h("div", { key: '0f2a9e15df898550117743f855e7ee0746157ab1', role: "presentation", class: "container" }, index.h("slot", { key: '688fd29a894bae8aee4c848a9b07380c95302ca2', name: "item" }, index.h("span", { key: 'a80c902d26d7afed58e8a17646dac92473042fa4', id: "is-empty" }))))));
    }
    static get delegatesFocus() { return true; }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "placement": ["placementChange"]
    }; }
};
Dropdown.style = WcsDropdownStyle0;

exports.wcs_dropdown = Dropdown;

//# sourceMappingURL=wcs-dropdown.cjs.entry.js.map