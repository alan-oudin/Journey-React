'use strict';

function isElement(element) {
    return 'clientWidth' in element
        && 'clientHeight' in element;
}
function hasShadowDom(el) {
    return !!el.shadowRoot && !!el.attachShadow;
}
const debounceEvent = (event, wait) => {
    const original = event._original || event;
    return {
        _original: event,
        emit: debounce(original.emit.bind(original), wait)
    };
};
const debounce = (func, wait = 0) => {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(func, wait, ...args);
    };
};
/**
 * Elements inside of web components sometimes need to inherit global attributes
 * set on the host. For example, the inner input in `wcs-input` should inherit
 * the `title` attribute that developers set directly on `wcs-input`. This
 * helper function should be called in componentWillLoad and assigned to a variable
 * that is later used in the render function.
 *
 * This does not need to be reactive as changing attributes on the host element
 * does not trigger a re-render.
 */
const inheritAttributes = (el, attributes = []) => {
    const attributeObject = {};
    attributes.forEach(attr => {
        if (el.hasAttribute(attr)) {
            const value = el.getAttribute(attr);
            if (value !== null) {
                attributeObject[attr] = el.getAttribute(attr);
            }
            el.removeAttribute(attr);
        }
    });
    return attributeObject;
};
/**
 * List of available ARIA attributes + `role`.
 * Removed deprecated attributes.
 * https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes
 */
const ariaAttributes = [
    'role',
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-braillelabel',
    'aria-brailleroledescription',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colindextext',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-description',
    'aria-details',
    'aria-disabled',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowindextext',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
];
/**
 * Returns an array of aria attributes that should be copied from
 * the shadow host element to a target within the light DOM.
 * @param el The element that the attributes should be copied from.
 * @param ignoreList The list of aria-attributes to ignore reflecting and removing from the host.
 * Use this in instances where we manually specify aria attributes on the `<Host>` element.
 */
const inheritAriaAttributes = (el, ignoreList) => {
    let attributesToInherit = ariaAttributes;
    if (ignoreList && ignoreList.length > 0) {
        attributesToInherit = attributesToInherit.filter((attr) => !ignoreList.includes(attr));
    }
    return inheritAttributes(el, attributesToInherit);
};
/**
 * Dynamically add or remove an attribute on the element.
 * If the value of the attribute is null or undefined, the attribute is removed.
 *
 * @param el - The HTMLElement
 * @param attr - The attribute to be added or removed
 * @param value - The value of the attribute
 */
function setOrRemoveAttribute(el, attr, value) {
    if (el) {
        if (value === undefined || value === null) {
            el.removeAttribute(attr);
        }
        else {
            el.setAttribute(attr, value);
        }
    }
}
const findItemLabel = (componentEl) => {
    const itemEl = componentEl.closest('wcs-form-field');
    if (itemEl) {
        return itemEl.querySelector('wcs-label');
    }
    return null;
};
/**
 * Given two lists of items, this function will return the items that were removed, kept, and added compared to the source list.
 * @param sourceList - The source list of items
 * @param newList - The target list of items
 * @param compareFn - The function to compare the items
 */
const compareLists = (sourceList, newList, compareFn) => {
    const removed = sourceList.filter(val => !newList.some(newVal => compareFn(val, newVal)));
    const kept = sourceList.filter(val => newList.some(newVal => compareFn(val, newVal)));
    const added = newList.filter(val => !sourceList.some(sourceVal => compareFn(val, sourceVal)));
    return { removed, kept, added };
};
/**
 * Normalizes whitespace by replacing multiple consecutive whitespace characters
 * with a single space and removes leading and trailing whitespace.
 *
 * @param content - String potentially containing multiple whitespace characters to normalize, if the content is null or undefined, it will return an empty string.
 * @returns Normalized string where sequences of whitespace are replaced by a single space.
 *
 * @example
 * normalizeWhitespace("  Text   with    spaces  ") // Returns "Text with spaces"
 */
function normalizeWhitespace(content) {
    var _a, _b;
    return (_b = (_a = content === null || content === void 0 ? void 0 : content.replace(/\s+/g, ' ')) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : '';
}
/**
 * Patched version of requestAnimationFrame that avoids ngzone
 * Use only when you know ngzone should not run
 */
const raf = (h) => {
    if (typeof __zone_symbol__requestAnimationFrame === 'function') {
        return __zone_symbol__requestAnimationFrame(h);
    }
    if (typeof requestAnimationFrame === 'function') {
        return requestAnimationFrame(h);
    }
    return setTimeout(h);
};
/**
 * Return true if the mouseEvent click is inside the given HTML element
 */
const clickInsideElement = (event, element) => {
    return event.x >= element.getBoundingClientRect().x && event.x <= element.getBoundingClientRect().x + element.getBoundingClientRect().width
        && event.y >= element.getBoundingClientRect().y && event.y <= element.getBoundingClientRect().y + element.getBoundingClientRect().height;
};
const clickTargetIsElementOrChildren = (mouseEvent, element) => {
    return mouseEvent.target instanceof Node
        && element.contains(mouseEvent.target);
};
function generateUniqueId(componentName) {
    return componentName + "-" + Math.random().toString(36);
}
/**
 * `clientX` property doesn't exist on KeyboardEvent, we therefore deduce it's a MouseEvent.
 */
function isMouseEvent(event) {
    return 'clientX' in event;
}
function isKeyup(evt) {
    return evt.code === 'ArrowUp';
}
function isKeydown(evt) {
    return evt.code === 'ArrowDown';
}
function isEscapeKey(evt) {
    return evt.code === 'Escape';
}
function isSpaceKey(evt) {
    return evt.code === 'Space';
}
function isEnterKey(evt) {
    return evt.key === 'Enter';
}
function isHomeKey(evt) {
    return evt.code === 'Home';
}
function isEndKey(evt) {
    return evt.code === 'End';
}
function isUpArrowKey(evt) {
    return evt.key === 'ArrowUp';
}
function isDownArrowKey(evt) {
    return evt.key === 'ArrowDown';
}
function isLeftArrowKey(evt) {
    return evt.key === 'ArrowLeft';
}
function isRightArrowKey(evt) {
    return evt.key === 'ArrowRight';
}
function isPageDownKey(evt) {
    return evt.key === 'PageDown';
}
function isPageUpKey(evt) {
    return evt.key === 'PageUp';
}
function isTabKey(evt) {
    return evt.key === 'Tab';
}
function getCssRootPropertyValue(name) {
    return window.getComputedStyle(document.body).getPropertyValue(name) || null;
}
/**
 * Converts a CSS time value string (e.g., '150ms', '1.5s') into milliseconds
 * @param {string} timeValue - The CSS time value string
 * @returns {number} Time in milliseconds
 */
function parseCssTimeValueToMilliseconds(timeValue) {
    if (!timeValue)
        return 0;
    const TIME_REGEX = /^([\d.]+)(?:(ms|s))?$/;
    const trimmedValue = timeValue.trim();
    if (!/^\d/.test(trimmedValue))
        return 0;
    const match = TIME_REGEX.exec(trimmedValue);
    if (!match)
        return 0;
    const value = Number(match[1]);
    if (!Number.isFinite(value))
        return 0;
    return match[2] === 's' ? value * 1000 : value;
}

exports.clickInsideElement = clickInsideElement;
exports.clickTargetIsElementOrChildren = clickTargetIsElementOrChildren;
exports.compareLists = compareLists;
exports.debounceEvent = debounceEvent;
exports.findItemLabel = findItemLabel;
exports.generateUniqueId = generateUniqueId;
exports.getCssRootPropertyValue = getCssRootPropertyValue;
exports.hasShadowDom = hasShadowDom;
exports.inheritAriaAttributes = inheritAriaAttributes;
exports.inheritAttributes = inheritAttributes;
exports.isDownArrowKey = isDownArrowKey;
exports.isElement = isElement;
exports.isEndKey = isEndKey;
exports.isEnterKey = isEnterKey;
exports.isEscapeKey = isEscapeKey;
exports.isHomeKey = isHomeKey;
exports.isKeydown = isKeydown;
exports.isKeyup = isKeyup;
exports.isLeftArrowKey = isLeftArrowKey;
exports.isMouseEvent = isMouseEvent;
exports.isPageDownKey = isPageDownKey;
exports.isPageUpKey = isPageUpKey;
exports.isRightArrowKey = isRightArrowKey;
exports.isSpaceKey = isSpaceKey;
exports.isTabKey = isTabKey;
exports.isUpArrowKey = isUpArrowKey;
exports.normalizeWhitespace = normalizeWhitespace;
exports.parseCssTimeValueToMilliseconds = parseCssTimeValueToMilliseconds;
exports.raf = raf;
exports.setOrRemoveAttribute = setOrRemoveAttribute;

//# sourceMappingURL=helpers-2f1a8ddc.js.map