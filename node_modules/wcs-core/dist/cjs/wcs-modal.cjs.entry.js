'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-6f0140d8.js');
const accessibility = require('./accessibility-5f681a74.js');
const helpers = require('./helpers-2f1a8ddc.js');

const modalCss = "wcs-modal{--wcs-modal-backdrop-color:var(--wcs-semantic-color-background-backdrop);--wcs-modal-max-height:80%;--wcs-modal-background-color:var(--wcs-semantic-color-background-surface-primary);--wcs-modal-border-radius:var(--wcs-semantic-border-radius-base);--wcs-modal-padding:calc(3 * var(--wcs-semantic-spacing-base));--wcs-modal-border-width:var(--wcs-semantic-border-width-default);--wcs-modal-border-color:var(--wcs-semantic-color-border-secondary);--wcs-modal-title-margin-bottom:var(--wcs-semantic-spacing-large);--wcs-modal-title-font-size:var(--wcs-semantic-font-size-heading-4);--wcs-modal-title-font-weight:var(--wcs-semantic-font-weight-heavy);--wcs-modal-title-line-height:var(--wcs-semantic-font-line-height-medium);--wcs-modal-actions-margin-top:var(--wcs-semantic-spacing-large);--wcs-modal-width-s:288px;--wcs-modal-width-m:480px;--wcs-modal-width-l:864px;--wcs-modal-width-xl:1200px;z-index:999;position:fixed;top:0;bottom:0;left:0;right:0;display:none;background:var(--wcs-modal-backdrop-color)}wcs-modal[show]{display:flex;height:100vh;width:100vw;align-items:center;justify-content:center}wcs-modal[without-backdrop]{background-color:unset}wcs-modal[without-backdrop] .wcs-modal-container{border:solid var(--wcs-modal-border-width) var(--wcs-modal-border-color)}.wcs-modal-container{max-height:var(--wcs-modal-max-height, 80%);background-color:var(--wcs-modal-background-color);display:grid;grid-template-columns:100%;grid-template-rows:auto 1fr auto;box-sizing:border-box;pointer-events:auto;background-clip:padding-box;border-radius:var(--wcs-modal-border-radius);z-index:20000;padding:var(--wcs-modal-padding);width:var(--wcs-modal-width-m)}.wcs-modal-container[data-size=s]{width:var(--wcs-modal-width-s)}.wcs-modal-container[data-size=m]{width:var(--wcs-modal-width-m)}.wcs-modal-container[data-size=l]{width:var(--wcs-modal-width-l)}.wcs-modal-container[data-size=xl]{width:var(--wcs-modal-width-xl)}.wcs-modal-header{margin-bottom:var(--wcs-modal-title-margin-bottom);display:flex;align-items:center;justify-content:space-between}.wcs-modal-header h1{font-size:var(--wcs-modal-title-font-size);font-weight:var(--wcs-modal-title-font-weight);line-height:var(--wcs-modal-title-line-height);margin:0}.wcs-modal-content{overflow-y:var(--wcs-modal-overflow-y, auto)}.wcs-modal-actions{margin-top:var(--wcs-modal-actions-margin-top);display:flex;justify-content:flex-end}";
const WcsModalStyle0 = modalCss;

const MODAL_INHERITED_ATTRS = [];
const Modal = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.wcsDialogClosed = index.createEvent(this, "wcsDialogClosed", 7);
        this.inheritedAttributes = {};
        /**
         * Give an unique id
         * @private
         */
        this.modalId = modalIds++;
        /**
         * This attribute is used to determine whether the show attribute has changed since the last rendering.
         * This allows us to call the focus method on the first element of the modal when the show attribute changes to true.
         * This call is made in the componentDidRender method
         * @private
         */
        this.showAttributeChangedMarker = false;
        /**
         * This attribute is used to determine if the modal has been closed for the first time since its last activation.
         * It is set to 'true' when the modal is first closed, and will be reset to 'false' when the modal is shown again.
         * This state is important for accessibility reasons in order to focus the modal trigger element (like the button
         * which controls the modal)
         *
         * @private
         */
        this.hasBeenClosedBefore = false;
        this.withoutBackdrop = false;
        this.show = false;
        this.showCloseButton = false;
        this.closeButtonAriaLabel = 'Fermer';
        this.size = 'm';
        this.hideActions = false;
        this.modalTriggerControlsId = undefined;
        this.initialFocusElementId = undefined;
        this.disableAutoFocus = false;
    }
    componentWillLoad() {
        if (!this.modalTriggerControlsId) {
            console.warn('wcs-modal: You must provide the modal-trigger-controls-id attribute to the modal to make it to work properly');
        }
        this.inheritedAttributes = Object.assign(Object.assign({}, helpers.inheritAriaAttributes(this.el)), helpers.inheritAttributes(this.el, MODAL_INHERITED_ATTRS));
    }
    componentDidLoad() {
        this.updateFocusableElements();
    }
    componentDidRender() {
        var _a;
        this.updateFocusableElements();
        if (this.showAttributeChangedMarker) {
            this.showAttributeChangedMarker = false;
            if (this.disableAutoFocus) {
                return;
            }
            if (!this.initialFocusElementId) {
                (_a = this.firstFocusableElement) === null || _a === void 0 ? void 0 : _a.focus();
            }
            else {
                const modalElementToFocusOnOpening = document.getElementById(this.initialFocusElementId);
                if (!modalElementToFocusOnOpening) {
                    console.warn(`wcs-modal: Unable to focus element - ID '${this.initialFocusElementId}' not found in DOM`);
                }
                modalElementToFocusOnOpening === null || modalElementToFocusOnOpening === void 0 ? void 0 : modalElementToFocusOnOpening.focus();
            }
        }
    }
    async setAriaAttribute(attr, value) {
        helpers.setOrRemoveAttribute(this.nativeDivDialog, attr, value);
    }
    onShowChange() {
        if (this.show) {
            this.hasBeenClosedBefore = false;
            this.showAttributeChangedMarker = true;
        }
        else {
            // if we already made actions when the modal was firstly closed, we do nothing
            if (this.hasBeenClosedBefore) {
                return;
            }
            this.hasBeenClosedBefore = true;
            if (this.modalTriggerControlsId) {
                const modalTriggerControlsHtmlElement = document.getElementById(this.modalTriggerControlsId);
                if (!modalTriggerControlsHtmlElement) {
                    console.warn(`wcs-modal: Element with id '${this.modalTriggerControlsId}' could not be found`);
                }
                modalTriggerControlsHtmlElement === null || modalTriggerControlsHtmlElement === void 0 ? void 0 : modalTriggerControlsHtmlElement.focus();
            }
        }
    }
    updateFocusableElements() {
        const focusableElements = Array.from(this.el.querySelectorAll('*'))
            .filter(element => accessibility.isFocusable(element));
        this.firstFocusableElement = focusableElements.length > 0 && focusableElements[0];
        this.lastFocusableElement = focusableElements.length > 0 && focusableElements[focusableElements.length - 1];
    }
    close() {
        // If the modal isn't shown, we don't do anything
        if (this.show) {
            this.show = false;
            this.wcsDialogClosed.emit();
        }
    }
    onKeyDown(event) {
        if (this.show && this.showCloseButton && event.key === 'Escape') {
            this.close();
        }
        if (this.show) {
            if (helpers.isTabKey(event)) {
                this.updateFocusableElements(); // XXX: maybe a performance issue
                const firstElement = this.firstFocusableElement;
                const lastElement = this.lastFocusableElement;
                if (event.shiftKey && accessibility.isElementFocused(firstElement)) {
                    event.preventDefault();
                    lastElement.focus();
                }
                else if (!event.shiftKey && accessibility.isElementFocused(lastElement)) {
                    event.preventDefault();
                    firstElement.focus();
                }
            }
        }
    }
    onCloseButtonClick(_) {
        this.close();
    }
    handleSlotContentChange() {
        this.updateFocusableElements();
    }
    render() {
        const modalTitleId = `wcs-modal-title-${this.modalId}`;
        return (index.h(index.Host, { key: 'e609fe2024b73cab0bed97c0d3b7012d8deba893' }, index.h("div", Object.assign({ key: '23007c4ad4971263f7fd99d0e594216cd112f6ea', class: "wcs-modal-container", "data-size": this.size, "aria-modal": "true", role: "dialog", "aria-labelledby": modalTitleId, ref: (el) => (this.nativeDivDialog = el) }, this.inheritedAttributes), index.h("div", { key: 'bc3e2ead8e3e73da31882c5e87cde2780d9ef2f9', class: "wcs-modal-header" }, index.h("h1", { key: '87561fc92b0990d00e06463afc111e9bdeab6f20', id: modalTitleId }, index.h("slot", { key: 'dbf6d932257e7a264206ddf7caea8a80e4b2b069', name: "header" })), this.showCloseButton && (index.h("wcs-button", { key: '97036ea40d111c5ac737b1e3f789571cd524cb2d', shape: "round", mode: "clear", id: "wcs-modal-close-button", "aria-label": this.closeButtonAriaLabel, onClick: ($event) => this.onCloseButtonClick($event) }, index.h("wcs-mat-icon", { key: '24d6b531e788c2760c66804df96037714c9f854b', icon: "close" })))), index.h("div", { key: '34d9ddf3c4527395864a238f329d7b499eb9791b', class: "wcs-modal-content" }, index.h("slot", { key: '5bbd76fc7de9bc6f5aaec7257e7c73995d3e1447', onSlotchange: () => this.handleSlotContentChange() })), !this.hideActions && (index.h("div", { key: '0c082f533dd77e73721b3bcf29a6f3d3baac65b3', class: "wcs-modal-actions" }, index.h("slot", { key: '56bfb65b4784492747eda2f5eb87b29dc7704db3', name: "actions" }))))));
    }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "show": ["onShowChange"]
    }; }
};
let modalIds = 0;
Modal.style = WcsModalStyle0;

exports.wcs_modal = Modal;

//# sourceMappingURL=wcs-modal.cjs.entry.js.map