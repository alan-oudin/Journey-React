'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-6f0140d8.js');
const helpers = require('./helpers-2f1a8ddc.js');
const breadcrumbConstants = require('./breadcrumb-constants-6677b4e8.js');

const breadcrumbCss = ":host{--wcs-breadcrumb-icon-color:var(--wcs-semantic-color-foreground-brand);--wcs-breadcrumb-icon-font-size:0.5rem;--wcs-breadcrumb-gap:var(--wcs-semantic-spacing-base)}nav.wcs-breadcrumb-container slot[name=hidden-items]{display:none}nav.wcs-breadcrumb-container.show-hidden-items slot[name=hidden-items]{display:contents}nav.wcs-breadcrumb-container div[role=list]{display:flex;flex-wrap:wrap;align-items:center;margin:0;padding:0;list-style:none}nav.wcs-breadcrumb-container div[role=list] ::slotted(wcs-breadcrumb-item){margin-right:var(--wcs-breadcrumb-gap)}nav.wcs-breadcrumb-container div[role=list] ::slotted(wcs-breadcrumb-item:last-child){margin-right:0}nav.wcs-breadcrumb-container div[role=list] .item-not-slotted{display:flex;align-items:center;margin-right:var(--wcs-breadcrumb-gap)}nav.wcs-breadcrumb-container div[role=list] .item-not-slotted wcs-button[size=s]{--wcs-button-min-width:24px;--wcs-button-height:20px;--wcs-button-border-radius:2px;transform:translateY(2px)}nav.wcs-breadcrumb-container div[role=list] .item-not-slotted .item-icon{margin-left:calc(var(--wcs-breadcrumb-gap) - 1px);font-family:\"icons\";font-size:var(--wcs-breadcrumb-icon-font-size);color:var(--wcs-breadcrumb-icon-color);transform:translateY(1px)}";
const WcsBreadcrumbStyle0 = breadcrumbCss;

const BREADCRUMB_INHERITED_ATTRS = [];
const Breadcrumb = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.inheritedAttributes = {};
        this.maxItems = undefined;
        this.itemsBeforeCollapse = 1;
        this.itemsAfterCollapse = 2;
        this.ariaLabelExpandButton = breadcrumbConstants.EXPAND_BTN_ARIA_LABEL_DEFAULT;
        this.showHiddenItems = false;
    }
    handleCollapsePropsChange() {
        this.updateCollapsedViewMode();
    }
    handleAriaLabelExpandBtnChange(newValue) {
        var _a;
        (_a = this.expandBtnEl) === null || _a === void 0 ? void 0 : _a.setAriaAttribute('aria-label', newValue);
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, helpers.inheritAriaAttributes(this.el)), helpers.inheritAttributes(this.el, BREADCRUMB_INHERITED_ATTRS));
        this.updateCollapsedViewMode();
    }
    componentDidLoad() {
        var _a;
        (_a = this.expandBtnEl) === null || _a === void 0 ? void 0 : _a.setAriaAttribute('aria-label', this.ariaLabelExpandButton);
    }
    async setAriaAttribute(attr, value) {
        helpers.setOrRemoveAttribute(this.navEl, attr, value);
    }
    getBreadcrumbItems() {
        return Array.from(this.el.querySelectorAll('wcs-breadcrumb-item'));
    }
    shouldCollapseItems() {
        return (!!this.maxItems &&
            this.getBreadcrumbItems().length > this.maxItems &&
            this.itemsBeforeCollapse + this.itemsAfterCollapse <= this.maxItems);
    }
    updateCollapsedViewMode() {
        if (this.shouldCollapseItems()) {
            this.assignSlotNamesForCollapsedViewMode();
        }
        else {
            this.assignSlotNamesForNonCollapsedViewMode();
        }
    }
    /**
     * Setting slot names on breadcrumb items allows to leverage JSX in the render method.
     */
    assignSlotNamesForCollapsedViewMode() {
        const breadcrumbItems = this.getBreadcrumbItems();
        const itemBeforeExpandBtnIndex = this.itemsBeforeCollapse - 1;
        const itemAfterExpandBtnIndex = breadcrumbItems.length - this.itemsAfterCollapse;
        breadcrumbItems.forEach((breadcrumbItem, index) => {
            if (index <= itemBeforeExpandBtnIndex) {
                breadcrumbItem.slot = 'items-before-expand-btn';
                breadcrumbItem.last = false;
            }
            else if (index > itemBeforeExpandBtnIndex && index < itemAfterExpandBtnIndex) {
                breadcrumbItem.slot = 'hidden-items';
                breadcrumbItem.last = false;
            }
            else {
                breadcrumbItem.slot = 'items-after-expand-btn';
                breadcrumbItem.last = index === breadcrumbItems.length - 1;
            }
        });
    }
    assignSlotNamesForNonCollapsedViewMode() {
        const breadcrumbItems = this.getBreadcrumbItems();
        breadcrumbItems.forEach((breadcrumbItem, index) => {
            breadcrumbItem.slot = 'non-collapsed';
            breadcrumbItem.last = index === breadcrumbItems.length - 1;
        });
    }
    handleSlotChange() {
        this.updateCollapsedViewMode();
        this.showHiddenItems = false;
        index.forceUpdate(this);
    }
    handleOnExpandBtnClick() {
        // We leave the breadcrumb items in the hidden-items slot, without passing them to
        // the non-collapsed slot, so that we know which items to hide again later if needed.
        // For future implementations, the expand button could show or hide hidden items on click,
        // with a wcs-dropdown for example.
        this.showHiddenItems = true;
        // We wait for the first hidden item to be visible in the DOM again
        // to be able to focus it.
        requestAnimationFrame(() => this.setFocusToFirstHiddenItem());
    }
    /**
     * Avoid losing focus after clicking the expand button.
     * We need to give focus back to the first breadcrumb item link that was hidden before.
     */
    setFocusToFirstHiddenItem() {
        const breadcrumbItems = this.getBreadcrumbItems();
        const firstHiddenItemIndex = this.itemsBeforeCollapse;
        const firstHiddenItem = breadcrumbItems[firstHiddenItemIndex];
        const firstHiddenItemSlot = firstHiddenItem.shadowRoot.querySelector('slot');
        const breadcrumbItemLinkToFocus = firstHiddenItemSlot.assignedElements()[0];
        breadcrumbItemLinkToFocus === null || breadcrumbItemLinkToFocus === void 0 ? void 0 : breadcrumbItemLinkToFocus.focus();
    }
    renderExpandAllButton() {
        const expandBtnIsLastItem = this.itemsAfterCollapse === 0;
        return (index.h("div", { role: "listitem", class: "item-not-slotted" }, index.h("wcs-button", { mode: "clear", shape: "square", size: "s", onClick: this.handleOnExpandBtnClick.bind(this), ref: (el) => this.expandBtnEl = el }, index.h("wcs-mat-icon", { icon: "more_horiz" })), !expandBtnIsLastItem && (index.h("span", { class: "item-icon", "aria-hidden": "true" }, breadcrumbConstants.ICONS_FONT_CHEVRON_UNICODE))));
    }
    render() {
        const showExpandBtn = this.shouldCollapseItems() && !this.showHiddenItems;
        return (index.h(index.Host, { key: 'f1c0ed14b8806df5c1ba717f6354d2e4c201dcd1' }, index.h("nav", Object.assign({ key: 'ae39ce6d5af6868105c1cb349d70d04da9931274', class: `wcs-breadcrumb-container${this.showHiddenItems ? ' show-hidden-items' : ''}`, "aria-label": breadcrumbConstants.NAV_ARIA_LABEL_DEFAULT }, this.inheritedAttributes, { ref: (el) => this.navEl = el }), index.h("div", { key: '82f4a76da057076e5d7299df7972bb918220b6ac', role: "list" }, index.h("slot", { key: 'e3180e059e1467c9821e5d10b0694f39194ce4f4', onSlotchange: this.handleSlotChange.bind(this) }), index.h("slot", { key: 'e865695a1082a503321d519193f47c54f2d86ba5', name: "non-collapsed" }), index.h("slot", { key: '53a846e67fe320236a8f0b80216c72fa676304bb', name: "items-before-expand-btn" }), index.h("slot", { key: 'a6f9243e94d5f4e05e6e3ca89a574ac37128689a', name: "hidden-items" }), showExpandBtn && this.renderExpandAllButton(), index.h("slot", { key: '0ca62fc184565b82a12d1314bdfb51161934775b', name: "items-after-expand-btn" })))));
    }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "maxItems": ["handleCollapsePropsChange"],
        "itemsBeforeCollapse": ["handleCollapsePropsChange"],
        "itemsAfterCollapse": ["handleCollapsePropsChange"],
        "ariaLabelExpandButton": ["handleAriaLabelExpandBtnChange"]
    }; }
};
Breadcrumb.style = WcsBreadcrumbStyle0;

exports.wcs_breadcrumb = Breadcrumb;

//# sourceMappingURL=wcs-breadcrumb.cjs.entry.js.map