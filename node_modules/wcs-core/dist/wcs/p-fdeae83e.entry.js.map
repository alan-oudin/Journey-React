{"version":3,"names":["radioGroupCss","WcsRadioGroupStyle0","RadioGroup","onValueChangeHandler","value","this","updateRadioTabIndex","updateAllRadioState","setAriaAttribute","attr","setOrRemoveAttribute","el","componentDidLoad","updateAllRadioModeAndName","onSlotChange","getSlottedRadios","forEach","r","updateState","mode","name","radios","first","find","radio","disabled","checked","focusable","tabindex","setTabIndex","Array","from","querySelectorAll","getSlottedRadiosNotDisabled","filter","handleRadioClick","event","detail","wcsChange","emit","handleKeyDown","ev","radiosNotDisabled","previousSelected","findIndex","target","indexToSelect","isSpaceKey","isEnterKey","preventDefault","isDownArrowKey","isRightArrowKey","length","isUpArrowKey","isLeftArrowKey","isTabKey","radioToSelect","focus","render","h","Host","key","role","onSlotchange","bind"],"sources":["src/components/radio-group/radio-group.scss?tag=wcs-radio-group&encapsulation=shadow","src/components/radio-group/radio-group.tsx"],"sourcesContent":[":host {\n    display: flex;\n\n    // region Radio\n    --wcs-radio-group-gap: var(--wcs-semantic-spacing-base);\n    // endregion\n\n    // region Option\n    --wcs-radio-group-option-height: var(--wcs-semantic-size-m);\n    --wcs-radio-group-option-gap: var(--wcs-semantic-spacing-small);\n    --wcs-radio-group-option-padding: var(--wcs-semantic-spacing-small) var(--wcs-semantic-spacing-small);\n    --wcs-radio-group-option-border-radius: var(--wcs-semantic-border-radius-base);\n    --wcs-radio-group-option-background-color: var(--wcs-semantic-color-background-surface-accent-lightest);\n    // endregion\n}\n\n:host([mode=radio]) {\n    flex-direction: column;\n    gap: var(--wcs-radio-group-gap);\n}\n\n:host([mode=option]) {\n    box-sizing: border-box;\n    height: var(--wcs-radio-group-option-height);\n    display: inline-flex;\n    flex-direction: row;\n    align-items: center;\n    gap: var(--wcs-radio-group-option-gap);\n    padding: var(--wcs-radio-group-option-padding);\n    background-color: var(--wcs-radio-group-option-background-color);\n    border-radius: var(--wcs-radio-group-option-border-radius);\n}\n\n:host([mode=horizontal]) {\n    justify-content: space-between;\n}\n","import {\n    Component,\n    ComponentInterface,\n    Element,\n    Event,\n    EventEmitter,\n    h,\n    Host,\n    Listen,\n    Method,\n    Prop,\n    Watch\n} from '@stencil/core';\nimport { RadioGroupChangeEventDetail, RadioGroupMode } from './radio-group-interface';\nimport { RadioChosedEvent } from '../radio/radio-interface';\nimport {\n    isDownArrowKey, isEnterKey,\n    isLeftArrowKey,\n    isRightArrowKey,\n    isSpaceKey,\n    isTabKey,\n    isUpArrowKey,\n    setOrRemoveAttribute\n} from \"../../utils/helpers\";\nimport { AriaAttributeName, MutableAriaAttribute } from '../../utils/mutable-aria-attribute';\n\n/**\n * @cssprop --wcs-radio-group-gap - Gap between each radio (checkmark + label) in horizontal mode\n * \n *\n * @cssprop --wcs-radio-group-option-background-color - Background color of the radio group option\n * \n * @cssprop --wcs-radio-group-option-height - Height of the radio group option\n * @cssprop --wcs-radio-group-option-padding - Padding of the radio group option\n *  \n * @cssprop --wcs-radio-group-option-border-radius - Border radius of the radio group option\n * \n * @cssprop --wcs-radio-group-option-gap - Gap between each radio option\n */\n@Component({\n    tag: 'wcs-radio-group',\n    styleUrl: 'radio-group.scss',\n    shadow: true\n})\nexport class RadioGroup implements ComponentInterface, MutableAriaAttribute {\n    @Element() private el!: HTMLWcsRadioGroupElement;\n    \n    /**\n     * The value of the radio-group. Automatically reflects which radio button is selected.\n     */\n    @Prop({ mutable: true }) value: any | any[] | undefined | null;\n\n    /**\n     * The name of the control to be set on all radio button children\n     */\n    @Prop({ reflect: true }) name;\n\n    /**\n     * The display mode of the control to be set on all radio button children\n     */\n    @Prop({ reflect: true }) mode: RadioGroupMode = 'radio';\n\n    /** Emitted when the value has changed. */\n    @Event() wcsChange!: EventEmitter<RadioGroupChangeEventDetail>;\n\n    @Watch('value')\n    onValueChangeHandler(value: any | undefined) {\n        this.updateRadioTabIndex(value);\n        this.updateAllRadioState();\n    }\n\n    @Method()\n    async setAriaAttribute(attr: AriaAttributeName, value: string | null | undefined) {\n        setOrRemoveAttribute(this.el, attr, value);\n    }\n\n    componentDidLoad() {\n       this.onValueChangeHandler(this.value);\n       this.updateAllRadioModeAndName();\n    }\n    \n    onSlotChange() {\n        this.updateRadioTabIndex(this.value);\n        this.updateAllRadioModeAndName();\n    }\n    \n    updateAllRadioState() {\n        this.getSlottedRadios().forEach(r => r.updateState());\n    }\n    \n    @Watch('name')\n    @Watch('mode')\n    updateAllRadioModeAndName() {\n        this.getSlottedRadios().forEach(r => {\n            r.mode = this.mode;\n            r.name = this.name;\n        });\n    }\n    \n    updateRadioTabIndex(value: any | undefined) {\n        const radios = this.getSlottedRadios();\n\n        // Get the first radio that is not disabled and the checked one\n        const first = radios.find((radio) => !radio.disabled);\n        const checked = radios.find((radio) => radio.value === value && !radio.disabled);\n\n        if (!first && !checked) {\n            return;\n        }\n\n        // If an enabled checked radio exists, set it to be the focusable radio\n        // otherwise we default to focus the first radio\n        const focusable = checked || first;\n\n        for (const radio of radios) {\n            const tabindex = radio === focusable ? 0 : -1;\n            radio.setTabIndex(tabindex);\n        }\n    }\n\n    private getSlottedRadios(): HTMLWcsRadioElement[] {\n        return Array.from(this.el.querySelectorAll('wcs-radio'));\n    }\n\n    private getSlottedRadiosNotDisabled(): HTMLWcsRadioElement[] {\n        return Array.from(this.getSlottedRadios().filter(radio => !radio.disabled));\n    }\n\n    @Listen('wcsRadioClick')\n    handleRadioClick(event: CustomEvent<RadioChosedEvent>) {\n        this.value = event.detail.value;\n        this.wcsChange.emit({\n            value: event.detail.value\n        });\n    }\n\n    @Listen('keydown')\n    async handleKeyDown(ev: KeyboardEvent) {\n        const radiosNotDisabled = this.getSlottedRadiosNotDisabled();\n        const previousSelected = radiosNotDisabled.findIndex(r => r === ev.target);\n        let indexToSelect: number;\n\n        if ((isSpaceKey(ev) || isEnterKey(ev))) {\n            ev.preventDefault();\n            indexToSelect = previousSelected;\n        } else if (isDownArrowKey(ev) || isRightArrowKey(ev)) {\n            ev.preventDefault();\n            // Check the next wcs-radio from the previous selected\n            indexToSelect = (previousSelected + 1) % radiosNotDisabled.length;  // to return at the beginning on the list when we are on the last index\n        } else if (isUpArrowKey(ev) || isLeftArrowKey(ev)) {\n            ev.preventDefault();\n            // Check the previous wcs-radio from the previous selected\n            indexToSelect = (previousSelected - 1 + radiosNotDisabled.length) % radiosNotDisabled.length; // To return at the end of the list when we are on index=0\n        } else if (isTabKey(ev)) {\n            return;\n        }\n        \n        const radioToSelect = radiosNotDisabled[indexToSelect]\n        if (radioToSelect) {\n            radioToSelect.focus();\n            \n            if (this.value !== radioToSelect.value) {\n                this.wcsChange.emit({\n                    value: radioToSelect.value\n                })\n            }\n            \n            this.value = radioToSelect.value;\n        }\n    }\n\n    render() {\n        return (\n            <Host role=\"radiogroup\">\n                <slot name=\"option\" onSlotchange={this.onSlotChange.bind(this)}/>\n            </Host>\n        );\n    }\n\n}\n"],"mappings":"qJAAA,MAAMA,EAAgB,g8BACtB,MAAAC,EAAeD,E,MC2CFE,EAAU,M,iHAgB6B,O,CAMhD,oBAAAC,CAAqBC,GACjBC,KAAKC,oBAAoBF,GACzBC,KAAKE,qB,CAIT,sBAAMC,CAAiBC,EAAyBL,GAC5CM,EAAqBL,KAAKM,GAAIF,EAAML,E,CAGxC,gBAAAQ,GACGP,KAAKF,qBAAqBE,KAAKD,OAC/BC,KAAKQ,2B,CAGR,YAAAC,GACIT,KAAKC,oBAAoBD,KAAKD,OAC9BC,KAAKQ,2B,CAGT,mBAAAN,GACIF,KAAKU,mBAAmBC,SAAQC,GAAKA,EAAEC,e,CAK3C,yBAAAL,GACIR,KAAKU,mBAAmBC,SAAQC,IAC5BA,EAAEE,KAAOd,KAAKc,KACdF,EAAEG,KAAOf,KAAKe,IAAI,G,CAI1B,mBAAAd,CAAoBF,GAChB,MAAMiB,EAAShB,KAAKU,mBAGpB,MAAMO,EAAQD,EAAOE,MAAMC,IAAWA,EAAMC,WAC5C,MAAMC,EAAUL,EAAOE,MAAMC,GAAUA,EAAMpB,QAAUA,IAAUoB,EAAMC,WAEvE,IAAKH,IAAUI,EAAS,CACpB,M,CAKJ,MAAMC,EAAYD,GAAWJ,EAE7B,IAAK,MAAME,KAASH,EAAQ,CACxB,MAAMO,EAAWJ,IAAUG,EAAY,GAAK,EAC5CH,EAAMK,YAAYD,E,EAIlB,gBAAAb,GACJ,OAAOe,MAAMC,KAAK1B,KAAKM,GAAGqB,iBAAiB,a,CAGvC,2BAAAC,GACJ,OAAOH,MAAMC,KAAK1B,KAAKU,mBAAmBmB,QAAOV,IAAUA,EAAMC,W,CAIrE,gBAAAU,CAAiBC,GACb/B,KAAKD,MAAQgC,EAAMC,OAAOjC,MAC1BC,KAAKiC,UAAUC,KAAK,CAChBnC,MAAOgC,EAAMC,OAAOjC,O,CAK5B,mBAAMoC,CAAcC,GAChB,MAAMC,EAAoBrC,KAAK4B,8BAC/B,MAAMU,EAAmBD,EAAkBE,WAAU3B,GAAKA,IAAMwB,EAAGI,SACnE,IAAIC,EAEJ,GAAKC,EAAWN,IAAOO,EAAWP,GAAM,CACpCA,EAAGQ,iBACHH,EAAgBH,C,MACb,GAAIO,EAAeT,IAAOU,EAAgBV,GAAK,CAClDA,EAAGQ,iBAEHH,GAAiBH,EAAmB,GAAKD,EAAkBU,M,MACxD,GAAIC,EAAaZ,IAAOa,EAAeb,GAAK,CAC/CA,EAAGQ,iBAEHH,GAAiBH,EAAmB,EAAID,EAAkBU,QAAUV,EAAkBU,M,MACnF,GAAIG,EAASd,GAAK,CACrB,M,CAGJ,MAAMe,EAAgBd,EAAkBI,GACxC,GAAIU,EAAe,CACfA,EAAcC,QAEd,GAAIpD,KAAKD,QAAUoD,EAAcpD,MAAO,CACpCC,KAAKiC,UAAUC,KAAK,CAChBnC,MAAOoD,EAAcpD,O,CAI7BC,KAAKD,MAAQoD,EAAcpD,K,EAInC,MAAAsD,GACI,OACIC,EAACC,EAAI,CAAAC,IAAA,2CAACC,KAAK,cACPH,EAAA,QAAAE,IAAA,2CAAMzC,KAAK,SAAS2C,aAAc1D,KAAKS,aAAakD,KAAK3D,Q"}