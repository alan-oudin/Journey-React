{"version":3,"names":["registerCloseHandlerForFocusOutEventOn","navigableItems","nodeNameToClose","forEach","navigableItem","addEventListener","evt","relatedTargetElement","relatedTarget","isElementChildOfNavigableItem","eventComposedPath","composedPath","isEventThrownFromChildOfNodeNameToClose","filter","eventTargetNodeNameEquals","close","element","contains","nodeName","x","map","indexOf","comNavDidLoadWithResizeObserver","comNavElement","smallBreakpoint","getCssRootPropertyValue","smallBreakpointValue","parseInt","ResizeObserver","entry","cr","contentRect","paddingRight","right","width","paddingLeft","left","currentActiveSizing"],"sources":["src/components/com-nav/com-nav-utils.ts"],"sourcesContent":["import { getCssRootPropertyValue } from \"../../utils/helpers\";\nimport { ComNav } from \"./com-nav\";\nimport { ComNavSubmenu } from \"../com-nav-submenu/com-nav-submenu\";\nimport { ComNavCategory } from \"../com-nav-category/com-nav-category\";\n\n/**\n * This function add event handlers on the navigableItems list. The handlers call the function close() on the nodeName.\n *\n * T: type class of the nodeNameToClose param (must have a close function)\n *\n * @param navigableItems items on which focusout event listeners must be added\n * @param nodeNameToClose nodeName of the element we want to close in the event path\n */\nexport function registerCloseHandlerForFocusOutEventOn<T extends {close: () => any}>(navigableItems: NodeListOf<Element>, nodeNameToClose: string): void {\n    navigableItems.forEach(navigableItem => {\n        navigableItem.addEventListener(\"focusout\", (evt: FocusEvent) => {\n            const relatedTargetElement = evt.relatedTarget as HTMLElement;\n            if (!isElementChildOfNavigableItem(navigableItem, relatedTargetElement)) {\n                const eventComposedPath = (evt as Event).composedPath();\n                if (isEventThrownFromChildOfNodeNameToClose(eventComposedPath, nodeNameToClose)) {\n                    (eventComposedPath.filter(eventTargetNodeNameEquals(nodeNameToClose))[0] as unknown as T).close();\n                }\n            }\n        })\n    });\n}\n\nfunction isElementChildOfNavigableItem(navigableItem: Element, element: Element) {\n    return navigableItem.contains(element);\n}\n\nfunction eventTargetNodeNameEquals(nodeName: string) {\n    return x => (x as HTMLElement).nodeName === nodeName;\n}\n\nfunction isEventThrownFromChildOfNodeNameToClose(eventComposedPath: EventTarget[], nodeName: string) {\n    return eventComposedPath.map(x => (x as HTMLElement).nodeName).indexOf(nodeName) !== -1;\n}\n\nexport function comNavDidLoadWithResizeObserver(comNavElement: ComNav | ComNavSubmenu | ComNavCategory): ResizeObserver {\n    const smallBreakpoint = getCssRootPropertyValue('--wcs-phone-breakpoint-max-width') || '575px';\n    const smallBreakpointValue = parseInt(smallBreakpoint, 10);\n\n    return new ResizeObserver(entry => {\n        const cr = entry[0].contentRect;\n        const paddingRight = cr.right - cr.width;\n        const paddingLeft = cr.left;\n        if (cr.width <= smallBreakpointValue - (paddingLeft + paddingRight)) {\n            comNavElement.currentActiveSizing = 'mobile';\n        } else {\n            comNavElement.currentActiveSizing = 'desktop';\n        }\n    });\n}\n"],"mappings":"6CAagBA,EAAqEC,EAAqCC,GACtHD,EAAeE,SAAQC,IACnBA,EAAcC,iBAAiB,YAAaC,IACxC,MAAMC,EAAuBD,EAAIE,cACjC,IAAKC,EAA8BL,EAAeG,GAAuB,CACrE,MAAMG,EAAqBJ,EAAcK,eACzC,GAAIC,EAAwCF,EAAmBR,GAAkB,CAC5EQ,EAAkBG,OAAOC,EAA0BZ,IAAkB,GAAoBa,O,KAGpG,GAEV,CAEA,SAASN,EAA8BL,EAAwBY,GAC3D,OAAOZ,EAAca,SAASD,EAClC,CAEA,SAASF,EAA0BI,GAC/B,OAAOC,GAAMA,EAAkBD,WAAaA,CAChD,CAEA,SAASN,EAAwCF,EAAkCQ,GAC/E,OAAOR,EAAkBU,KAAID,GAAMA,EAAkBD,WAAUG,QAAQH,MAAe,CAC1F,C,SAEgBI,EAAgCC,GAC5C,MAAMC,EAAkBC,EAAwB,qCAAuC,QACvF,MAAMC,EAAuBC,SAASH,EAAiB,IAEvD,OAAO,IAAII,gBAAeC,IACtB,MAAMC,EAAKD,EAAM,GAAGE,YACpB,MAAMC,EAAeF,EAAGG,MAAQH,EAAGI,MACnC,MAAMC,EAAcL,EAAGM,KACvB,GAAIN,EAAGI,OAASR,GAAwBS,EAAcH,GAAe,CACjET,EAAcc,oBAAsB,Q,KACjC,CACHd,EAAcc,oBAAsB,S,IAGhD,Q"}