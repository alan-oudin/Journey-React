import { h, r as registerInstance, c as createEvent, f as forceUpdate, H as Host, g as getElement } from './index-d9de61ce.js';
import { G as GridPagination } from './grid-pagination-731726a6.js';
import { k as keyboardShortcutFromKeyboardEvent } from './keyboard-event-26b65ae5.js';
import { i as inheritAriaAttributes, a as inheritAttributes, s as setOrRemoveAttribute } from './helpers-ece6a2d3.js';
import { i as isObjectLike, b as baseGetTag, a as isArray, S as Symbol, c as isObject, g as getNative, e as eq, d as isPrototype, f as isArrayLike, h as arrayLikeKeys, M as MapCache, o as overArg, k as keys, r as root, j as getSymbols, s as stubArray, l as arrayPush, m as baseGetAllKeys, U as Uint8Array$1, n as getTag, p as baseUnary, q as nodeUtil, t as isBuffer, u as Stack, v as getAllKeys, w as isEqual } from './isEqual-f2a07f4c.js';

function getSortOrderInteger(sortOrder) {
    switch (sortOrder) {
        case 'asc':
            return 1;
        case 'desc':
            return -1;
    }
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

/** `Object#toString` result references. */
var symbolTag$2 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$2);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

const baseCreate$1 = baseCreate;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

const defineProperty$1 = defineProperty;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

const stringToPath$1 = stringToPath;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

const getPrototype$1 = getPrototype;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype$1(object);
  }
  return result;
};

const getSymbolsIn$1 = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$1:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag$1:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate$1(getPrototype$1(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag$1;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

const isMap$1 = isMap;

/** `Object#toString` result references. */
var setTag$1 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag$1;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

const isSet$1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

/**
 * We follow this https://www.w3.org/WAI/ARIA/apg/patterns/grid/
 * @param event
 * @param type
 */
function getActionForKeyboardEvent(event, type) {
    const keyboardShortcut = keyboardShortcutFromKeyboardEvent(event);
    if (keyboardShortcut === 'UNKNOWN') {
        return [];
    }
    switch (keyboardShortcut) {
        case "UP_ARROW":
            return [{ kind: 'FocusCell', target: 'up' }];
        case "DOWN_ARROW":
            return [{ kind: 'FocusCell', target: 'down' }];
        case "LEFT_ARROW":
            return [{ kind: 'FocusCell', target: 'left' }];
        case "RIGHT_ARROW":
            return [{ kind: 'FocusCell', target: 'right' }];
        case "HOME":
            return [{ kind: 'FocusCell', target: 'first_of_row' }];
        case "END":
            return [{ kind: 'FocusCell', target: 'last_of_row' }];
        case "MAJ+SPACE":
            switch (type) {
                case "grid_selection_single":
                case "grid_selection_multiple":
                    return [{ kind: 'SelectRow', target: 'one' }];
            }
            break;
        case "CTRL+A":
            switch (type) {
                case "grid_selection_multiple":
                    return [{ kind: 'SelectRow', target: 'all' }];
            }
            break;
        case "CTRL+HOME":
            return [{ kind: 'FocusCell', target: 'first_of_grid' }];
        case "CTRL+END":
            return [{ kind: 'FocusCell', target: 'last_of_grid' }];
    }
    return [];
}

const GridRadio = ({ checked, row, rowIndex, totalRows, onClick }) => {
    let input;
    return (h("div", { class: `grid-radio ${checked ? 'checked' : ''}`, onClick: _ => input.click() },
        h("input", { type: "radio", name: "selection", "aria-setsize": totalRows, "aria-posinset": rowIndex, tabindex: "-1", checked: checked, "aria-checked": `${checked}`, ref: (el) => (input = el), onClick: _ => onClick(row) })));
};

const gridCss = ":host{--wcs-grid-gap:0;--wcs-grid-vertical-align:middle;--wcs-grid-outline-color:var(--wcs-semantic-color-border-focus-base);--wcs-grid-cell-text-color:var(--wcs-semantic-color-text-secondary);--wcs-grid-cell-padding-horizontal:var(--wcs-semantic-spacing-large);--wcs-grid-cell-padding-vertical:var(--wcs-semantic-spacing-base);--wcs-grid-cell-border-bottom:none;--wcs-grid-cell-separator-border:none;--wcs-grid-first-cell-border-radius:0;--wcs-grid-last-cell-border-radius:0;--wcs-grid-highlight-color:var(--wcs-semantic-color-background-surface-accent-lighter);--wcs-grid-row-background-color:var(--wcs-semantic-color-background-surface-primary);--wcs-grid-row-odd-background-color:var(--wcs-grid-row-background-color);--wcs-grid-row-even-background-color:var(--wcs-semantic-color-background-surface-accent-lightest);--wcs-grid-header-background-color-default:var(--wcs-semantic-color-background-action-secondary-default);--wcs-grid-header-background-color-hover:var(--wcs-semantic-color-background-action-secondary-hover);--wcs-grid-header-background-color-press:var(--wcs-semantic-color-background-action-secondary-press);--wcs-grid-header-text-color:var(--wcs-semantic-color-text-primary);--wcs-grid-header-font-weight:var(--wcs-semantic-font-weight-heavy);--wcs-grid-header-font-size:var(--wcs-semantic-font-size-label-1);--wcs-grid-header-line-height:var(--wcs-primitive-font-line-height-140);--wcs-grid-header-padding-vertical:var(--wcs-semantic-spacing-base);--wcs-grid-header-padding-horizontal:var(--wcs-semantic-spacing-large);--wcs-grid-header-border-left:none;--wcs-grid-header-border-radius:0;--wcs-grid-header-border-bottom:solid var(--wcs-semantic-border-width-default) var(--wcs-semantic-color-border-secondary);--wcs-grid-header-transition-duration:var(--wcs-semantic-motion-duration-feedback-fast);--wcs-grid-first-header-background-color:var(--wcs-semantic-color-background-action-secondary-default);--wcs-grid-first-header-border-radius:0;--wcs-grid-last-header-border-radius:0;--wcs-grid-column-selection-width:calc(5 * var(--wcs-semantic-spacing-base));--wcs-grid-header-sort-arrow-color-default:var(--wcs-semantic-color-foreground-action-neutral-default);--wcs-grid-header-sort-arrow-color-hover:var(--wcs-semantic-color-foreground-action-neutral-hover);display:block}:host th{border-radius:var(--wcs-grid-first-header-border-radius);background-color:var(--wcs-grid-first-header-background-color)}:host ::slotted([slot=grid-column]:first-child){--wcs-grid-header-border-left:none}:host :host([selection]) ::slotted([slot=grid-column]:first-child){--wcs-component-grid-header-border-radius-first:0;--wcs-grid-header-border-left:var(--wcs-grid-header-border-left)}:host table{width:100%;border-collapse:collapse;border-spacing:var(--wcs-grid-gap)}:host table thead{border-bottom:var(--wcs-grid-header-border-bottom)}:host table tbody{vertical-align:var(--wcs-grid-vertical-align)}:host td{color:var(--wcs-grid-cell-text-color);margin:0;padding:var(--wcs-grid-cell-padding-vertical) var(--wcs-grid-cell-padding-horizontal)}:host td:focus-visible{outline:var(--wcs-semantic-border-width-large) dashed var(--wcs-grid-outline-color);outline-offset:0;border-radius:0.1rem}:host td:first-child{border-radius:var(--wcs-grid-first-cell-border-radius)}:host td:last-child{border-radius:var(--wcs-grid-last-cell-border-radius)}:host td:not(:first-child){border-left:var(--wcs-grid-cell-separator-border)}:host tr{background-color:var(--wcs-grid-row-background-color)}:host tr:nth-child(odd){background-color:var(--wcs-grid-row-odd-background-color, var(--wcs-grid-row-background-color))}:host tr:nth-child(even){background-color:var(--wcs-grid-row-even-background-color, var(--wcs-grid-row-background-color))}:host tr:not(:last-child) td{border-bottom:var(--wcs-grid-cell-border-bottom)}:host .wcs-grid-selection-column{padding:var(--wcs-grid-cell-padding-vertical) var(--wcs-grid-cell-padding-horizontal);width:var(--wcs-grid-column-selection-width);text-align:start}:host tr.selected{background-color:var(--wcs-grid-highlight-color)}:host .loading{text-align:center}";
const WcsGridStyle0 = gridCss;

const gridRadioCss = ".grid-radio{--wcs-grid-radio-outline-color:var(--wcs-semantic-color-border-focus-base);--wcs-grid-radio-padding:calc(var(--wcs-semantic-size-base) / 4);--wcs-grid-radio-transition:var(--wcs-semantic-motion-duration-feedback-base);--wcs-grid-radio-border-color-default:var(--wcs-semantic-color-border-control-indicator-default);--wcs-grid-radio-border-color-selected:var(--wcs-semantic-color-border-control-indicator-selected);--wcs-grid-radio-border-color-hover:var(--wcs-semantic-color-border-control-indicator-hover);--wcs-grid-radio-border-color-disabled:var(--wcs-semantic-color-border-control-indicator-disabled);--wcs-grid-radio-background-color-default:transparent;--wcs-grid-radio-background-color-selected:var(--wcs-semantic-color-background-control-indicator-selected);--wcs-grid-radio-background-color-disabled:var(--wcs-semantic-color-background-control-indicator-disabled);--wcs-grid-radio-inner-border-color:white;width:fit-content;cursor:pointer;padding:var(--wcs-grid-radio-padding, 0.125rem);}.grid-radio:has(input:focus-visible){outline:var(--wcs-semantic-border-width-large) dashed var(--wcs-grid-radio-outline-color);outline-offset:var(--wcs-semantic-spacing-small);border-radius:0.1rem}@supports not selector(:has(input:focus-visible)){.grid-radio:focus-within{outline:var(--wcs-semantic-border-width-large) dashed var(--wcs-grid-radio-outline-color);outline-offset:var(--wcs-semantic-spacing-small);border-radius:0.1rem}}.grid-radio input{position:absolute;opacity:0;height:1px;width:1px;overflow:hidden;clip-path:inset(50%);white-space:nowrap}.grid-radio::before{content:\"\";display:flex;border-radius:50%;border:2px solid var(--wcs-grid-radio-border-color-default);position:relative;width:1.125rem;height:1.125rem;box-sizing:border-box;background-color:var(--wcs-grid-radio-background-color-default);transition:var(--wcs-grid-radio-transition, 0.175s) ease-in-out}.grid-radio:hover::before{border-color:var(--wcs-grid-radio-border-color-hover)}.grid-radio.checked::before{border-color:var(--wcs-grid-radio-border-color-selected);background-color:var(--wcs-grid-radio-background-color-selected);outline:solid 2px var(--wcs-grid-radio-inner-border-color);outline-offset:-4px}";
const WcsGridStyle1 = gridRadioCss;

const GRID_INHERITED_ATTRS = ['title'];
const Grid = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.wcsGridSelectionChange = createEvent(this, "wcsGridSelectionChange", 7);
        this.wcsGridAllSelectionChange = createEvent(this, "wcsGridAllSelectionChange", 7);
        this.wcsFocus = createEvent(this, "wcsFocus", 7);
        this.wcsBlur = createEvent(this, "wcsBlur", 7);
        this.inheritedAttributes = {};
        this.serverMode = false;
        this.data = undefined;
        this.loading = undefined;
        this.selectionConfig = 'none';
        this.selectedItems = [];
        this.wcsGridPaginationId = undefined;
        this.rowIdPath = undefined;
        this.rowCssPartsFn = (_) => null;
        this.columns = undefined;
        this.paginationEl = undefined;
        this.rows = [];
        this.cursorPosition = { col: 0, row: 1 };
    }
    onCursorPositionChange(newValue) {
        // Notify all grid columns that the cursorPosition has changed
        this.getGridColumnsFromTemplate().forEach(g => g.cursorPosition = newValue);
    }
    onDataChange(newValue) {
        this.updateGridRows(newValue);
        this.refreshSort(false);
    }
    onSelectedItemsPropertyChange(newValue) {
        this.updateSelectionWithValues(newValue);
    }
    onFocus(event) {
        var _a;
        (_a = this.getElementToFocusAtCursorPosition()) === null || _a === void 0 ? void 0 : _a.focus();
        this.wcsFocus.emit(event);
    }
    onBlur(event) {
        this.wcsBlur.emit(event);
    }
    /**
     * Set focus on the first cell of the grid
     */
    async focusFirstCell() {
        var _a;
        this.cursorPosition = { col: this.selectionConfig === 'none' ? 0 : 1, row: 1 };
        (_a = this.getElementToFocusAtCursorPosition()) === null || _a === void 0 ? void 0 : _a.focus();
    }
    /**
     * If selectionConfig is different from `none`, that means that an extra column for radio or checkbox is rendered
     * in the table.
     */
    hasSelectionColumn() {
        return this.selectionConfig !== 'none';
    }
    /**
     * Returns the element to focus at the current cursor position : it can be a cell (td, th) to focus or a nested
     * checkbox / radio element if the selection mode is single or multiple
     */
    getElementToFocusAtCursorPosition() {
        var _a, _b;
        const el = (_a = this.gridElementsWithCoordinates.find(cell => { var _a, _b; return cell.col === ((_a = this.cursorPosition) === null || _a === void 0 ? void 0 : _a.col) && cell.row === ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.row); })) === null || _a === void 0 ? void 0 : _a.el;
        return this.hasSelectionColumn()
            ? (_b = el.querySelector('wcs-checkbox,input[type="radio"]')) !== null && _b !== void 0 ? _b : el
            : el;
    }
    moveCursorPosition(directionX, directionY) {
        var _a;
        this.cursorPosition = {
            col: directionX === 'first' ? 0 :
                directionX === 'last' ? this.totalDisplayedColumnCount() - 1 :
                    Math.min(Math.max(this.cursorPosition.col + directionX, 0), this.totalDisplayedColumnCount() - 1),
            row: directionY === 'first' ? 0 :
                directionY === 'last' ? this.getRowsForCurrentPage().length :
                    Math.min(Math.max(this.cursorPosition.row + directionY, 0), this.getRowsForCurrentPage().length)
        };
        this.handleCursorPositionOnEmptyTh();
        (_a = this.getElementToFocusAtCursorPosition()) === null || _a === void 0 ? void 0 : _a.focus();
    }
    /**
     * When the grid has selectionConfig single, an empty th appears at col=0, row=0.
     * It should not be focusable so the cursor navigates to col=1, row=0 instead.
     */
    handleCursorPositionOnEmptyTh() {
        if (this.selectionConfig === 'single' && this.cursorPosition.col === 0 && this.cursorPosition.row === 0) {
            this.cursorPosition = {
                col: 1,
                row: 0
            };
        }
    }
    onHiddenColumnChange() {
        // We use forceUpdate because the fact of hiding a column or not does not modify the internal structure of the grid (WcsGridRow).
        // Hide a column only impacts the way it is rendered but the grid-column remains in the dom and in our internal model.
        forceUpdate(this);
        this.cursorPosition = { col: 0, row: 1 };
    }
    onKeyDown(_event) {
        var _a;
        if (((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.tagName) === 'WCS-GRID-PAGINATION') {
            return;
        }
        let type;
        switch (this.selectionConfig) {
            case "multiple":
                type = 'grid_selection_multiple';
                break;
            case "single":
                type = 'grid_selection_single';
                break;
            case "none":
                type = 'grid_no_selection';
                break;
        }
        const actionsFromKeyboardEvents = getActionForKeyboardEvent(_event, type);
        // If we have at least one associated actions, we prevent the default behavior of the event. 
        // Except if the action is a focus move (we have to handle the preventDefault behavior ourselves in the action implementation)
        if (actionsFromKeyboardEvents.length != 0) {
            _event.preventDefault();
        }
        for (const actionFromKeyboardEvent of actionsFromKeyboardEvents) {
            this.doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent, _event);
        }
    }
    doActionFromKeyboardEventAssociatedAction(actionFromKeyboardEvent, event) {
        switch (actionFromKeyboardEvent.kind) {
            case "FocusCell":
                switch (actionFromKeyboardEvent.target) {
                    case "up":
                        this.moveCursorPosition(0, -1);
                        break;
                    case "down":
                        this.moveCursorPosition(0, 1);
                        break;
                    case "left":
                        this.moveCursorPosition(-1, 0);
                        break;
                    case "right":
                        this.moveCursorPosition(1, 0);
                        break;
                    case "first_of_row":
                        this.moveCursorPosition('first', 0);
                        break;
                    case "last_of_row":
                        this.moveCursorPosition('last', 0);
                        break;
                    case "first_of_grid":
                        this.moveCursorPosition('first', 'first');
                        break;
                    case "last_of_grid":
                        this.moveCursorPosition('last', 'last');
                        break;
                }
            case "SelectRow":
                switch (actionFromKeyboardEvent.target) {
                    case "one":
                        event.preventDefault();
                        if (this.cursorPosition.row > 0) {
                            this.onRowSelection(this.rows[this.cursorPosition.row - 1]);
                        }
                        break;
                    case "all":
                        this.selectAllRows();
                        break;
                }
                break;
            default:
                throw new Error("Internal error");
        }
    }
    onClick(_event) {
        const clickedGridElement = _event.composedPath()
            .filter(x => ['TD', 'TH']
            .includes(x.nodeName))[0];
        if (!clickedGridElement)
            return; // it can be the grid pagination node, we don't want to handle it
        const clickedGridElementWithCoordinates = this.gridElementsWithCoordinates.find(e => e.el === clickedGridElement);
        this.cursorPosition = {
            col: clickedGridElementWithCoordinates.col,
            row: clickedGridElementWithCoordinates.row,
        };
    }
    updateSelectionWithValues(values) {
        if (this.selectionConfig === 'single') {
            this.rows.map(r => r.selected = false);
            for (const row of this.rows) {
                if (isEqual(row.data, values)) {
                    row.selected = true;
                    break; // only one line can be selected
                }
            }
        }
        else if (this.selectionConfig === 'multiple') {
            this.rows.map(r => r.selected = false);
            for (const row of this.rows) {
                if (values.find(x => isEqual(x, row.data))) {
                    row.selected = true;
                }
            }
        }
        this.rows = cloneDeep(this.rows);
    }
    wcsGridRowToWcsGridRowData(row) {
        return { selected: row.selected, page: row.page, data: row.data };
    }
    updateGridRows(data) {
        const rows = [];
        if (data && this.columns) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (let i = 0; i < data.length; i++) {
                const row = {
                    uuid: v4(),
                    data: data[i],
                    selected: false,
                    cells: []
                };
                let index = 0;
                for (const column of this.columns) {
                    column.columnPosition = index + (this.hasSelectionColumn() ? 1 : 0);
                    index++;
                    row.cells.push({
                        content: get(data[i], column.path),
                        column,
                        formatter: column.formatter
                    });
                }
                rows.push(row);
            }
            this.rows = rows;
            this.updatePageIndex();
        }
    }
    componentDidLoad() {
        this.columns = this.getGridColumnsFromTemplate();
        this.paginationEl = this.wcsGridPaginationId
            ? document.getElementById(this.wcsGridPaginationId)
            : this.getGridPaginationsFromTemplate()[0];
        this.updateGridRows(this.data);
        if (this.selectedItems) {
            this.updateSelectionWithValues(this.selectedItems);
        }
        this.refreshSort(true);
    }
    componentWillLoad() {
        this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes(this.el, GRID_INHERITED_ATTRS));
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.nativeTable, attr, value);
    }
    /**
     * Handle existing column's filters (defined before the grid is instantiated)
     * @private
     */
    refreshSort(refreshOthersColumnsSortOrderState) {
        //fixme: why the column property can be null or undefined?
        // Explanation: https://stenciljs.com/docs/component-lifecycle
        // The @watch can be called before the componentDidLoad() which sets the columns
        if (this.columns) {
            const [first, ...other] = this.columns.filter(c => c.sortOrder !== 'none');
            if (first && !this.serverMode) {
                this.sortBy(first);
            }
            refreshOthersColumnsSortOrderState && this.disableSortOrderForColumns(other);
        }
    }
    disableSortOrderForColumns(columns) {
        columns === null || columns === void 0 ? void 0 : columns.forEach(c => c.sortOrder = 'none');
    }
    getGridColumnsFromTemplate() {
        const slotted = this.el.shadowRoot.querySelector('slot[name="grid-column"]');
        return slotted.assignedElements();
    }
    getGridPaginationsFromTemplate() {
        const slotted = this.el.shadowRoot.querySelector('slot[name="grid-pagination"]');
        return slotted.assignedElements();
    }
    get gridElementsWithCoordinates() {
        const gridElements = [];
        // If selection multiple, the first cell should be added to the list
        if (this.selectionConfig === 'multiple') {
            gridElements.push({
                el: this.el.shadowRoot.querySelector('th'),
                row: 0,
                col: 0
            });
        }
        this.getGridColumnsFromTemplate()
            .filter(col => !col.hidden)
            .forEach((col, index) => {
            gridElements.push({
                el: col.shadowRoot.querySelector('th'),
                row: 0,
                col: index + (this.hasSelectionColumn() ? 1 : 0),
            });
        });
        this.el.shadowRoot.querySelectorAll('td').forEach((cell, index) => {
            gridElements.push({
                el: cell,
                row: 1 + Math.floor(index / this.totalDisplayedColumnCount()),
                col: index % this.totalDisplayedColumnCount(),
            });
        });
        return gridElements;
    }
    sortChangeEventHandler(event) {
        // fixme: why the column property can be null or undefined?
        // Explanation: https://stenciljs.com/docs/component-lifecycle
        // The @Listen can be called before the componentDidLoad() which sets the columns
        if (event.detail.order === 'none' || !this.columns)
            return;
        // We keep only one active sort column
        this.disableSortOrderForColumns(this.columns.filter(c => c !== event.detail.column));
        if (this.serverMode)
            return;
        this.sortBy(event.detail.column);
        this.updatePageIndex();
    }
    /**
     * Sorts the grid rows according to the given column's configuration
     * @param column Column from which to extract the sorting configuration
     * @private
     */
    sortBy(column) {
        if (column.sortFn) {
            this.rows = cloneDeep(this.rows)
                .sort((a, b) => column.sortFn(a.data, b.data, column) * getSortOrderInteger(column.sortOrder));
        }
        else {
            this.rows = cloneDeep(this.rows)
                .sort((a, b) => {
                const path = column.path;
                return ((get(a.data, path) < get(b.data, path)) ? -1 : (get(a.data, path) > get(b.data, path)) ? 1 : 0) * getSortOrderInteger(column.sortOrder);
            });
        }
    }
    /**
     * Update the page's number of all rows
     */
    updatePageIndex() {
        if (!this.serverMode && this.paginationEl) {
            this.paginationEl.itemsCount = this.data.length;
            this.paginationEl.pageCount = Math.ceil(this.data.length / this.paginationEl.pageSize);
            if (this.paginationEl.pageCount <= 1) {
                this.paginationEl.currentPage = GridPagination.INDEX_FIRST_PAGE;
            }
            else if (this.paginationEl.pageCount > 0 && this.paginationEl.currentPage + 1 > this.paginationEl.pageCount) {
                this.paginationEl.currentPage = this.paginationEl.pageCount - 1;
            }
            const rows = cloneDeep(this.rows);
            rows.forEach((row, index) => row.page = Math.floor(index / this.paginationEl.pageSize));
            this.rows = [...rows];
        }
    }
    paginationChangeEventHandler() {
        this.onPaginationChange();
    }
    paginationChangeEventHandlerOutside(event) {
        if (this.wcsGridPaginationId && this.wcsGridPaginationId === event.target.id) {
            this.onPaginationChange();
        }
    }
    onPaginationChange() {
        if (this.serverMode)
            return;
        this.updatePageIndex();
    }
    onRowSelection(row) {
        if (this.selectionConfig === 'single') {
            this.rows.filter(r => r.uuid !== row.uuid).map(r => r.selected = false);
        }
        row.selected = !row.selected;
        if (this.selectionConfig !== 'single' || row.selected) {
            this.wcsGridSelectionChange.emit({
                selectedRows: this.selectedRows.map(row => this.wcsGridRowToWcsGridRowData(row)),
                changedRow: this.wcsGridRowToWcsGridRowData(row)
            });
        }
        this.rows = cloneDeep(this.rows);
    }
    get selectedRows() {
        return this.rows.filter(r => r.selected);
    }
    selectAllRows() {
        const rows = this.getRowsForCurrentPage();
        const selected = !this.allRowsAreSelected();
        rows.map(r => r.selected = selected);
        this.wcsGridAllSelectionChange.emit({ rows: selected ? rows.map(row => this.wcsGridRowToWcsGridRowData(row)) : [] });
        this.wcsGridSelectionChange.emit({
            selectedRows: this.selectedRows.map(row => this.wcsGridRowToWcsGridRowData(row)),
            changedRow: 'allCheckbox'
        });
        this.rows = cloneDeep(this.rows);
    }
    allRowsAreSelected() {
        const rows = this.getRowsForCurrentPage();
        return rows.length > 0 && rows.filter(row => row.selected).length === rows.length;
    }
    getRowsForCurrentPage() {
        // When in server mode, the state exists outside the internal grid model, so we must rely on the DOM state
        if (!this.serverMode && this.paginationEl) {
            return this.rows.filter(row => row.page === this.paginationEl.currentPage);
        }
        return this.rows;
    }
    renderSelectionColumn(row, rowIndex) {
        var _a, _b, _c, _d;
        switch (this.selectionConfig) {
            case 'none':
                return;
            case 'single':
                return h("td", { "aria-colindex": this.atLeastOneColumnHidden() ? 1 : null, tabIndex: ((_a = this.cursorPosition) === null || _a === void 0 ? void 0 : _a.col) === 0 && rowIndex + 1 === ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.row) ? 0 : -1 }, h(GridRadio, { checked: row.selected, row: row, rowIndex: rowIndex + 1, totalRows: this.rows.length, onClick: (row) => {
                        if (!row.selected) {
                            this.onRowSelection(row);
                        }
                    } }));
            case 'multiple':
                return h("td", { "aria-colindex": this.atLeastOneColumnHidden() ? 1 : null, tabIndex: ((_c = this.cursorPosition) === null || _c === void 0 ? void 0 : _c.col) === 0 && rowIndex + 1 === ((_d = this.cursorPosition) === null || _d === void 0 ? void 0 : _d.row) ? 0 : -1 }, h("wcs-checkbox", { tabIndex: -1, part: "row-checkbox", checked: row.selected, onWcsChange: this.onRowSelection.bind(this, row) }));
        }
    }
    getCellContent(row, cell) {
        if (cell.formatter) {
            return cell.formatter(h, cell.column, this.wcsGridRowToWcsGridRowData(row));
        }
        return cell.content;
    }
    /**
     * Returns the total number of columns
     * @private
     */
    totalColumnCount() {
        if (!this.columns) {
            return 0;
        }
        return this.columns.length + (this.hasSelectionColumn() ? 1 : 0);
    }
    /**
     * Returns the total number of columns that are not hidden
     * @private
     */
    totalDisplayedColumnCount() {
        var _a, _b;
        return (_b = this.totalColumnCount() - ((_a = this.columns) === null || _a === void 0 ? void 0 : _a.filter(col => col.hidden).length)) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Returns true if at least one column is hidden from the table
     * @private
     */
    atLeastOneColumnHidden() {
        return this.totalDisplayedColumnCount() !== this.totalColumnCount();
    }
    render() {
        var _a, _b, _c, _d;
        return (h(Host, { key: '98d13e7497ec9d9ecd3e149b3f6986e16bc5cc2a' }, h("table", Object.assign({ key: 'a44825cf71ff284a5204e9d922c0eba2c2ca23f4', role: "grid", ref: (el) => (this.nativeTable = el), "aria-rowcount": !this.loading && ((_a = this.rows) === null || _a === void 0 ? void 0 : _a.length), "aria-colcount": !this.loading && this.totalDisplayedColumnCount() }, this.inheritedAttributes), h("thead", { key: '336578d350ae8082a19fa6798af35f2fdd015ff9' }, h("tr", { key: 'fdb38402ea5c58dd77dad7df2ef97d54c521123c', "aria-rowindex": "1" }, this.selectionConfig === 'none' ? ''
            : h("th", { class: "wcs-grid-selection-column" }, this.selectionConfig === 'single' ? '' :
                h("wcs-checkbox", { tabIndex: ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.col) === 0
                        && ((_c = this.cursorPosition) === null || _c === void 0 ? void 0 : _c.row) === 0 ? 0 : -1, part: "all-rows-checkbox", checked: this.allRowsAreSelected(), onWcsChange: this.selectAllRows.bind(this) })), h("slot", { key: '2d68b72fac0251dab9f519cf84c25c96262c193b', name: "grid-column" }))), h("tbody", { key: '4156e796ac5a81170b5dba011159f8e6bb7a7e60' }, this.loading
            ? h("tr", { "aria-busy": "true" }, h("td", { colSpan: this.totalColumnCount(), class: "loading" }, h("wcs-spinner", null)))
            : (_d = this.rows) === null || _d === void 0 ? void 0 : _d.filter(row => this.serverMode || !this.paginationEl || row.page === this.paginationEl.currentPage).map((row, index) => this.renderRow(row, index)))), h("slot", { key: 'c683eb883707ffbd1fed22d86ececb595f70c2c0', name: "grid-pagination" })));
    }
    /**
     * Returns the row with all mapped cells inside.
     * The aria-rowindex here starts at 2 because the header row starts at index 1.
     * @private
     */
    renderRow(row, rowIndex) {
        var _a, _b;
        let hiddenColumnCount = 0;
        return h("tr", { class: row.selected ? 'selected' : '', part: (_a = this.rowCssPartsWithoutEmptyList(row)) === null || _a === void 0 ? void 0 : _a.join(' '), "aria-selected": row.selected ? 'true' : null, "aria-rowindex": rowIndex + 2 }, this.renderSelectionColumn(row, rowIndex), (_b = row.cells) === null || _b === void 0 ? void 0 :
            _b.map((cell, cellIndex) => {
                var _a, _b;
                if (cell.column.hidden) {
                    hiddenColumnCount++;
                    return;
                }
                const nonHiddenColumnIndex = cellIndex - hiddenColumnCount + 1 + (this.hasSelectionColumn() ? 1 : 0);
                const cursorIsOnCell = nonHiddenColumnIndex - 1 === ((_a = this.cursorPosition) === null || _a === void 0 ? void 0 : _a.col)
                    && rowIndex + 1 === ((_b = this.cursorPosition) === null || _b === void 0 ? void 0 : _b.row);
                return cell.column.customCells
                    ? (h("td", { tabIndex: cursorIsOnCell ? 0 : -1, "aria-colindex": this.atLeastOneColumnHidden() ? nonHiddenColumnIndex : null }, h("slot", { name: cell.column.id + '-' + get(row.data, this.rowIdPath) })))
                    : (h("td", { tabIndex: cursorIsOnCell ? 0 : -1, "aria-colindex": this.atLeastOneColumnHidden() ? nonHiddenColumnIndex : null, part: cell.column.path + '-column' }, this.getCellContent(row, cell)));
            }));
    }
    rowCssPartsWithoutEmptyList(row) {
        const parts = this.rowCssPartsFn(row);
        return (parts === null || parts === void 0 ? void 0 : parts.length) === 0 ? null : parts;
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "cursorPosition": ["onCursorPositionChange"],
        "data": ["onDataChange"],
        "selectedItems": ["onSelectedItemsPropertyChange"]
    }; }
};
Grid.style = WcsGridStyle0 + WcsGridStyle1;

export { Grid as wcs_grid };

//# sourceMappingURL=wcs-grid.entry.js.map