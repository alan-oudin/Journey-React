import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-d9de61ce.js';
import { s as setOrRemoveAttribute, c as isSpaceKey, d as isEnterKey, u as isDownArrowKey, v as isRightArrowKey, w as isUpArrowKey, x as isLeftArrowKey, n as isTabKey } from './helpers-ece6a2d3.js';

const radioGroupCss = ":host{display:flex;--wcs-radio-group-gap:var(--wcs-semantic-spacing-base);--wcs-radio-group-option-height:var(--wcs-semantic-size-m);--wcs-radio-group-option-gap:var(--wcs-semantic-spacing-small);--wcs-radio-group-option-padding:var(--wcs-semantic-spacing-small) var(--wcs-semantic-spacing-small);--wcs-radio-group-option-border-radius:var(--wcs-semantic-border-radius-base);--wcs-radio-group-option-background-color:var(--wcs-semantic-color-background-surface-accent-lightest)}:host([mode=radio]){flex-direction:column;gap:var(--wcs-radio-group-gap)}:host([mode=option]){box-sizing:border-box;height:var(--wcs-radio-group-option-height);display:inline-flex;flex-direction:row;align-items:center;gap:var(--wcs-radio-group-option-gap);padding:var(--wcs-radio-group-option-padding);background-color:var(--wcs-radio-group-option-background-color);border-radius:var(--wcs-radio-group-option-border-radius)}:host([mode=horizontal]){justify-content:space-between}";
const WcsRadioGroupStyle0 = radioGroupCss;

const RadioGroup = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.wcsChange = createEvent(this, "wcsChange", 7);
        this.value = undefined;
        this.name = undefined;
        this.mode = 'radio';
    }
    onValueChangeHandler(value) {
        this.updateRadioTabIndex(value);
        this.updateAllRadioState();
    }
    async setAriaAttribute(attr, value) {
        setOrRemoveAttribute(this.el, attr, value);
    }
    componentDidLoad() {
        this.onValueChangeHandler(this.value);
        this.updateAllRadioModeAndName();
    }
    onSlotChange() {
        this.updateRadioTabIndex(this.value);
        this.updateAllRadioModeAndName();
    }
    updateAllRadioState() {
        this.getSlottedRadios().forEach(r => r.updateState());
    }
    updateAllRadioModeAndName() {
        this.getSlottedRadios().forEach(r => {
            r.mode = this.mode;
            r.name = this.name;
        });
    }
    updateRadioTabIndex(value) {
        const radios = this.getSlottedRadios();
        // Get the first radio that is not disabled and the checked one
        const first = radios.find((radio) => !radio.disabled);
        const checked = radios.find((radio) => radio.value === value && !radio.disabled);
        if (!first && !checked) {
            return;
        }
        // If an enabled checked radio exists, set it to be the focusable radio
        // otherwise we default to focus the first radio
        const focusable = checked || first;
        for (const radio of radios) {
            const tabindex = radio === focusable ? 0 : -1;
            radio.setTabIndex(tabindex);
        }
    }
    getSlottedRadios() {
        return Array.from(this.el.querySelectorAll('wcs-radio'));
    }
    getSlottedRadiosNotDisabled() {
        return Array.from(this.getSlottedRadios().filter(radio => !radio.disabled));
    }
    handleRadioClick(event) {
        this.value = event.detail.value;
        this.wcsChange.emit({
            value: event.detail.value
        });
    }
    async handleKeyDown(ev) {
        const radiosNotDisabled = this.getSlottedRadiosNotDisabled();
        const previousSelected = radiosNotDisabled.findIndex(r => r === ev.target);
        let indexToSelect;
        if ((isSpaceKey(ev) || isEnterKey(ev))) {
            ev.preventDefault();
            indexToSelect = previousSelected;
        }
        else if (isDownArrowKey(ev) || isRightArrowKey(ev)) {
            ev.preventDefault();
            // Check the next wcs-radio from the previous selected
            indexToSelect = (previousSelected + 1) % radiosNotDisabled.length; // to return at the beginning on the list when we are on the last index
        }
        else if (isUpArrowKey(ev) || isLeftArrowKey(ev)) {
            ev.preventDefault();
            // Check the previous wcs-radio from the previous selected
            indexToSelect = (previousSelected - 1 + radiosNotDisabled.length) % radiosNotDisabled.length; // To return at the end of the list when we are on index=0
        }
        else if (isTabKey(ev)) {
            return;
        }
        const radioToSelect = radiosNotDisabled[indexToSelect];
        if (radioToSelect) {
            radioToSelect.focus();
            if (this.value !== radioToSelect.value) {
                this.wcsChange.emit({
                    value: radioToSelect.value
                });
            }
            this.value = radioToSelect.value;
        }
    }
    render() {
        return (h(Host, { key: '3179704d2f1ed56f940941c1777b90a49ecd0ffa', role: "radiogroup" }, h("slot", { key: 'f01213b0c89bc04622601447005e24df07fea376', name: "option", onSlotchange: this.onSlotChange.bind(this) })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["onValueChangeHandler"],
        "name": ["updateAllRadioModeAndName"],
        "mode": ["updateAllRadioModeAndName"]
    }; }
};
RadioGroup.style = WcsRadioGroupStyle0;

export { RadioGroup as wcs_radio_group };

//# sourceMappingURL=wcs-radio-group.entry.js.map