import { r as registerInstance, h, H as Host, g as getElement } from './index-d9de61ce.js';
import { S as SelectArrow } from './select-arrow-e62de386.js';

const nativeSelectCss = ":host{--wcs-native-select-line-height:var(--wcs-semantic-font-line-height-large);--wcs-native-select-size-m:var(--wcs-semantic-size-m);--wcs-native-select-font-size-m:var(--wcs-semantic-font-size-m);--wcs-native-select-size-l:var(--wcs-semantic-size-l);--wcs-native-select-font-size-l:var(--wcs-semantic-font-size-l);--wcs-native-select-border-radius:var(--wcs-semantic-border-radius-base);--wcs-native-select-background-color:var(--wcs-semantic-color-background-control-default);--wcs-native-select-border-color-default:var(--wcs-semantic-color-border-primary);--wcs-native-select-border-color-disabled:var(--wcs-semantic-color-border-disabled);--wcs-native-select-border-color-focus:var(--wcs-semantic-color-border-control-focus);--wcs-native-select-border-color-error:var(--wcs-semantic-color-border-critical);--wcs-native-select-border-style-default:solid;--wcs-native-select-border-style-focus:var(--wcs-semantic-border-style-focus-control);--wcs-native-select-border-width:var(--wcs-semantic-border-width-default);--wcs-native-select-border-width-focus:var(--wcs-semantic-border-width-large);--wcs-native-select-value-color:var(--wcs-semantic-color-text-primary);--wcs-native-select-value-font-weight:var(--wcs-semantic-font-weight-medium);--wcs-native-select-value-font-style:normal;--wcs-native-select-internal-padding-horizontal:var(--wcs-native-select-padding-horizontal-m);--wcs-native-select-padding-horizontal-m:var(--wcs-semantic-spacing-large);--wcs-native-select-padding-horizontal-l:var(--wcs-semantic-spacing-large);--wcs-native-select-arrow-color:var(--wcs-semantic-color-foreground-brand);--wcs-native-select-arrow-color-disabled:var(--wcs-semantic-color-foreground-disabled);--wcs-native-select-text-color-disabled:var(--wcs-semantic-color-text-disabled);--wcs-native-select-placeholder-color:var(--wcs-semantic-color-text-tertiary);--wcs-native-select-placeholder-font-weight:var(--wcs-semantic-font-weight-roman);--wcs-native-select-placeholder-font-style:var(--wcs-semantic-font-style-control-placeholder);--wcs-native-select-option-color:var(--wcs-semantic-color-text-primary);--wcs-native-select-option-font-style:normal;--wcs-native-select-option-selected-color:var(--wcs-semantic-color-text-primary)}::slotted(select){box-sizing:border-box;-moz-appearance:none !important;-webkit-appearance:none !important;appearance:none !important;background-color:var(--wcs-native-select-background-color);color:var(--wcs-native-select-value-color);border-radius:var(--wcs-native-select-border-radius);border:none;outline:var(--wcs-native-select-border-style-default) var(--wcs-native-select-border-width) var(--wcs-native-select-border-color-default);outline-offset:calc(var(--wcs-native-select-border-width) * -1);user-select:none;cursor:pointer;line-height:var(--wcs-native-select-line-height);font-size:inherit;opacity:1;max-width:100%;flex-grow:1;padding-right:calc(var(--wcs-native-select-internal-padding-horizontal) + 24px);padding-left:var(--wcs-native-select-internal-padding-horizontal)}::slotted(select:disabled){cursor:not-allowed;color:var(--wcs-native-select-text-color-disabled);outline:var(--wcs-native-select-border-style-default) var(--wcs-native-select-border-width) var(--wcs-native-select-border-color-disabled);--wcs-native-select-background-color:var(--wcs-semantic-color-background-control-disabled);--wcs-native-select-value-color:var(--wcs-native-select-text-color-disabled)}::slotted(select[aria-invalid=true]){outline-style:var(--wcs-native-select-border-style-default);outline-color:var(--wcs-native-select-border-color-error) !important;outline-offset:calc(var(--wcs-native-select-border-width) * -1)}:host([data-disabled]) .select-wrapper .arrow-container .arrow{fill:var(--wcs-native-select-arrow-color-disabled)}:host,:host([data-size=m]){font-size:var(--wcs-native-select-font-size-m);--wcs-native-select-internal-padding-horizontal:var(--wcs-native-select-padding-horizontal-m)}:host ::slotted(select),:host([data-size=m]) ::slotted(select){height:var(--wcs-native-select-size-m)}:host([data-size=l]){font-size:var(--wcs-native-select-font-size-l);--wcs-native-select-internal-padding-horizontal:var(--wcs-native-select-padding-horizontal-l)}:host([data-size=l]) ::slotted(select){height:var(--wcs-native-select-size-l)}::slotted(select:focus-visible){outline:var(--wcs-native-select-border-style-focus) var(--wcs-native-select-border-width-focus) var(--wcs-native-select-border-color-focus);outline-offset:calc(var(--wcs-native-select-border-width-focus) * -1)}.select-wrapper{position:relative;display:flex;flex-wrap:nowrap}svg{flex-shrink:0}.arrow{fill:var(--wcs-native-select-arrow-color)}.arrow-container{pointer-events:none;display:flex;align-items:center;vertical-align:center;position:absolute;top:0;bottom:0;right:calc(var(--wcs-native-select-internal-padding-horizontal) - 4px);margin:auto 0}";
const WcsNativeSelectStyle0 = nativeSelectCss;

const NativeSelect = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.SLOTTED_SELECT_TRACKED_ATTRIBUTES_LIST = ['disabled'];
        this.size = 'm';
        this.required = false;
        this.expanded = false;
        this.disabled = undefined;
    }
    requiredChanged(newValue, oldValue) {
        if (newValue !== oldValue) {
            if (!this.selectElement)
                return;
            this.selectElement.required = this.required;
        }
    }
    componentWillLoad() {
        this.selectElement = this.el.querySelector('select');
        if (!this.selectElement)
            throw new Error("wcs-native-select must be used with a native slotted select, please refer to the documentation.");
        this.onSelectedOptionChange();
        /**
         * We use an event listener to apply the default style to the select when user chose an active option
         */
        this.selectElement.addEventListener('change', () => {
            this.onSelectedOptionChange();
        });
        this.observer = new MutationObserver(mutations => {
            const hasSpiedAttrMutation = mutations.filter(m => this.SLOTTED_SELECT_TRACKED_ATTRIBUTES_LIST.includes(m.attributeName)).length > 0;
            if (hasSpiedAttrMutation) {
                this.updateHostAttributeWithSlottedSelect();
            }
            // A workaround to detect when the select is reset by using a class change on the select element. For example
            // angular add/remove ng-pristine and ng-dirty classes on the form controls when the form is reset.
            // Not the best solution but it works since we cannot detect the reset event on the native select element.
            if (mutations.filter(m => m.attributeName === 'class').length > 0) {
                this._updateStyles();
            }
        });
        this.updateHostAttributeWithSlottedSelect();
        this.observer.observe(this.selectElement, { attributes: true });
    }
    async setAriaAttribute(attr, value) {
        if (!this.selectElement)
            return;
        this.selectElement.setAttribute(attr, value);
    }
    onSelectedOptionChange() {
        this._updateStyles();
    }
    _updateStyles() {
        if (this.isPlaceholderOptionSelected()) {
            this.applyPlaceholderStylesOnNativeSlottedSelectElement();
        }
        else {
            this.applySelectedOptionStylesOnNativeSlottedSelectElement();
        }
    }
    isPlaceholderOptionSelected() {
        var _a;
        return ((_a = Array.from(this.selectElement.options).filter(o => o.selected)[0]) === null || _a === void 0 ? void 0 : _a.disabled) == true;
    }
    /**
     * This method should always unset all styles modified by the `applyPlaceholderStylesOnNativeSlottedSelectElement()`
     * @private
     */
    applySelectedOptionStylesOnNativeSlottedSelectElement() {
        this.selectElement.style.color = "var(--wcs-native-select-value-color)";
        this.selectElement.style.fontStyle = "var(--wcs-native-select-value-font-style)";
        this.selectElement.style.fontWeight = "var(--wcs-native-select-value-font-weight)";
        Array.from(this.selectElement.options).forEach(option => {
            option.style.fontStyle = "var(--wcs-native-select-option-font-style)";
            if (!option.disabled) {
                option.style.color = "var(--wcs-native-select-option-color)";
            }
        });
    }
    /**
     * This method apply styles when the placeholder is shown.
     *
     * We use javascript because we cannot achieve that behaviour in pure css when the native select is not required
     * @private
     */
    applyPlaceholderStylesOnNativeSlottedSelectElement() {
        this.selectElement.style.color = "var(--wcs-native-select-placeholder-color)";
        this.selectElement.style.fontWeight = "var(--wcs-native-select-placeholder-font-weight)";
        this.selectElement.style.fontStyle = "var(--wcs-native-select-placeholder-font-style)";
        Array.from(this.selectElement.options).forEach(option => {
            option.style.fontStyle = "var(--wcs-native-select-option-font-style)";
            if (!option.disabled) {
                option.style.color = "var(--wcs-native-select-option-color)";
            }
        });
    }
    updateHostAttributeWithSlottedSelect() {
        var _a;
        this.disabled = (_a = this.selectElement) === null || _a === void 0 ? void 0 : _a.hasAttribute('disabled');
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.selectElement) === null || _b === void 0 ? void 0 : _b.removeEventListener("change", () => {
            this.onSelectedOptionChange();
        });
    }
    /**
     * Use this method to force the component to update its styles. It can be useful when the select is reset (with a placeholder).
     */
    async updateStyles() {
        // Note : we try to automatically detect if the select is reset with the onreset event and with a mutation
        // observer on the select element. But it seems that the onreset event is not fired when the select is reset.
        // and the mutation observer is not fired when the select is reset with the reset() method on the form.
        // So we have to let the user call this method manually when he reset the select.
        this._updateStyles();
    }
    render() {
        return (h(Host, { key: 'dedd08d93118cc5323b6d2062577275504972b12', class: `${this.expanded ? 'expanded' : ''}`, "data-disabled": this.disabled, "data-size": this.size }, h("div", { key: 'bd211e20d0ab314767729ab54611c3d28fb8cca7', class: "select-wrapper" }, h("slot", { key: 'b0e58a954d0212c19a05395065ad5ed76efa9f39' }), h("div", { key: '5f70166ee1756180982a43151b9762e1cfec51d4', class: "arrow-container" }, h(SelectArrow, { key: 'ed256e18a87ab7cf17af6b5226ee6f10779d5bb1', up: this.expanded })))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "required": ["requiredChanged"]
    }; }
};
NativeSelect.style = WcsNativeSelectStyle0;

export { NativeSelect as wcs_native_select };

//# sourceMappingURL=wcs-native-select.entry.js.map