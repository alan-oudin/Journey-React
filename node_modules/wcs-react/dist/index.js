import React, { createElement } from 'react';
import 'react-dom';
export { defineCustomElements } from 'wcs-core/loader';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const dashToPascalCase = (str) => str
    .toLowerCase()
    .split('-')
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join('');
const camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);

const attachProps = (node, newProps, oldProps = {}) => {
    if (node instanceof Element) {
        const className = getClassName(node.classList, newProps, oldProps);
        if (className !== '') {
            node.className = className;
        }
        Object.keys(newProps).forEach((name) => {
            if (name === 'children' ||
                name === 'style' ||
                name === 'ref' ||
                name === 'class' ||
                name === 'className' ||
                name === 'forwardedRef') {
                return;
            }
            if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
                const eventName = name.substring(2);
                const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
                if (!isCoveredByReact(eventNameLc)) {
                    syncEvent(node, eventNameLc, newProps[name]);
                }
            }
            else {
                node[name] = newProps[name];
                const propType = typeof newProps[name];
                if (propType === 'string') {
                    node.setAttribute(camelToDashCase(name), newProps[name]);
                }
            }
        });
    }
};
const getClassName = (classList, newProps, oldProps) => {
    const newClassProp = newProps.className || newProps.class;
    const oldClassProp = oldProps.className || oldProps.class;
    const currentClasses = arrayToMap(classList);
    const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);
    const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);
    const finalClassNames = [];
    currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
            finalClassNames.push(currentClass);
            incomingPropClasses.delete(currentClass);
        }
        else if (!oldPropClasses.has(currentClass)) {
            finalClassNames.push(currentClass);
        }
    });
    incomingPropClasses.forEach((s) => finalClassNames.push(s));
    return finalClassNames.join(' ');
};
const transformReactEventName = (eventNameSuffix) => {
    switch (eventNameSuffix) {
        case 'doubleclick':
            return 'dblclick';
    }
    return eventNameSuffix;
};
const isCoveredByReact = (eventNameSuffix) => {
    if (typeof document === 'undefined') {
        return true;
    }
    else {
        const eventName = 'on' + transformReactEventName(eventNameSuffix);
        let isSupported = eventName in document;
        if (!isSupported) {
            const element = document.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }
        return isSupported;
    }
};
const syncEvent = (node, eventName, newEventHandler) => {
    const eventStore = node.__events || (node.__events = {});
    const oldEventHandler = eventStore[eventName];
    if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
    }
    node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {
        if (newEventHandler) {
            newEventHandler.call(this, e);
        }
    }));
};
const arrayToMap = (arr) => {
    const map = new Map();
    arr.forEach((s) => map.set(s, s));
    return map;
};

const setRef = (ref, value) => {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref != null) {
        ref.current = value;
    }
};
const mergeRefs = (...refs) => {
    return (value) => {
        refs.forEach((ref) => {
            setRef(ref, value);
        });
    };
};
const createForwardRef = (ReactComponent, displayName) => {
    const forwardRef = (props, ref) => {
        return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    };
    forwardRef.displayName = displayName;
    return React.forwardRef(forwardRef);
};

const createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement) => {
    if (defineCustomElement !== undefined) {
        defineCustomElement();
    }
    const displayName = dashToPascalCase(tagName);
    const ReactComponent = class extends React.Component {
        constructor(props) {
            super(props);
            this.setComponentElRef = (element) => {
                this.componentEl = element;
            };
        }
        componentDidMount() {
            this.componentDidUpdate(this.props);
        }
        componentDidUpdate(prevProps) {
            attachProps(this.componentEl, this.props, prevProps);
        }
        render() {
            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
            let propsToPass = Object.keys(cProps).reduce((acc, name) => {
                const value = cProps[name];
                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
                    const eventName = name.substring(2).toLowerCase();
                    if (typeof document !== 'undefined' && isCoveredByReact(eventName)) {
                        acc[name] = value;
                    }
                }
                else {
                    const type = typeof value;
                    if (type === 'string' || type === 'boolean' || type === 'number') {
                        acc[camelToDashCase(name)] = value;
                    }
                }
                return acc;
            }, {});
            if (manipulatePropsFunction) {
                propsToPass = manipulatePropsFunction(this.props, propsToPass);
            }
            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });
            return createElement(tagName, newProps, children);
        }
        static get displayName() {
            return displayName;
        }
    };
    if (ReactComponentContext) {
        ReactComponent.contextType = ReactComponentContext;
    }
    return createForwardRef(ReactComponent, displayName);
};

const WcsAccordion = createReactComponent('wcs-accordion');
const WcsAccordionContent = createReactComponent('wcs-accordion-content');
const WcsAccordionHeader = createReactComponent('wcs-accordion-header');
const WcsAccordionPanel = createReactComponent('wcs-accordion-panel');
const WcsActionBar = createReactComponent('wcs-action-bar');
const WcsAlert = createReactComponent('wcs-alert');
const WcsAlertDrawer = createReactComponent('wcs-alert-drawer');
const WcsApp = createReactComponent('wcs-app');
const WcsBadge = createReactComponent('wcs-badge');
const WcsBreadcrumb = createReactComponent('wcs-breadcrumb');
const WcsBreadcrumbItem = createReactComponent('wcs-breadcrumb-item');
const WcsButton = createReactComponent('wcs-button');
const WcsCard = createReactComponent('wcs-card');
const WcsCardBody = createReactComponent('wcs-card-body');
const WcsCardContent = createReactComponent('wcs-card-content');
const WcsCardFooter = createReactComponent('wcs-card-footer');
const WcsCardHeader = createReactComponent('wcs-card-header');
const WcsCardMedia = createReactComponent('wcs-card-media');
const WcsCheckbox = createReactComponent('wcs-checkbox');
const WcsComNav = createReactComponent('wcs-com-nav');
const WcsComNavCategory = createReactComponent('wcs-com-nav-category');
const WcsComNavItem = createReactComponent('wcs-com-nav-item');
const WcsComNavSubmenu = createReactComponent('wcs-com-nav-submenu');
const WcsCounter = createReactComponent('wcs-counter');
const WcsDivider = createReactComponent('wcs-divider');
const WcsDropdown = createReactComponent('wcs-dropdown');
const WcsDropdownDivider = createReactComponent('wcs-dropdown-divider');
const WcsDropdownHeader = createReactComponent('wcs-dropdown-header');
const WcsDropdownItem = createReactComponent('wcs-dropdown-item');
const WcsEditableField = createReactComponent('wcs-editable-field');
const WcsError = createReactComponent('wcs-error');
const WcsField = createReactComponent('wcs-field');
const WcsFieldContent = createReactComponent('wcs-field-content');
const WcsFieldLabel = createReactComponent('wcs-field-label');
const WcsFooter = createReactComponent('wcs-footer');
const WcsFormField = createReactComponent('wcs-form-field');
const WcsGalactic = createReactComponent('wcs-galactic');
const WcsGalacticMenu = createReactComponent('wcs-galactic-menu');
const WcsGrid = createReactComponent('wcs-grid');
const WcsGridColumn = createReactComponent('wcs-grid-column');
const WcsGridCustomCell = createReactComponent('wcs-grid-custom-cell');
const WcsGridPagination = createReactComponent('wcs-grid-pagination');
const WcsHeader = createReactComponent('wcs-header');
const WcsHint = createReactComponent('wcs-hint');
const WcsHorizontalStepper = createReactComponent('wcs-horizontal-stepper');
const WcsIcon = createReactComponent('wcs-icon');
const WcsInput = createReactComponent('wcs-input');
const WcsLabel = createReactComponent('wcs-label');
const WcsListItem = createReactComponent('wcs-list-item');
const WcsListItemProperties = createReactComponent('wcs-list-item-properties');
const WcsListItemProperty = createReactComponent('wcs-list-item-property');
const WcsMatIcon = createReactComponent('wcs-mat-icon');
const WcsModal = createReactComponent('wcs-modal');
const WcsNativeSelect = createReactComponent('wcs-native-select');
const WcsNav = createReactComponent('wcs-nav');
const WcsNavItem = createReactComponent('wcs-nav-item');
const WcsProgressBar = createReactComponent('wcs-progress-bar');
const WcsProgressRadial = createReactComponent('wcs-progress-radial');
const WcsRadio = createReactComponent('wcs-radio');
const WcsRadioGroup = createReactComponent('wcs-radio-group');
const WcsSelect = createReactComponent('wcs-select');
const WcsSelectOption = createReactComponent('wcs-select-option');
const WcsSkeletonCircle = createReactComponent('wcs-skeleton-circle');
const WcsSkeletonRectangle = createReactComponent('wcs-skeleton-rectangle');
const WcsSkeletonText = createReactComponent('wcs-skeleton-text');
const WcsSpinner = createReactComponent('wcs-spinner');
const WcsSwitch = createReactComponent('wcs-switch');
const WcsTab = createReactComponent('wcs-tab');
const WcsTabs = createReactComponent('wcs-tabs');
const WcsTextarea = createReactComponent('wcs-textarea');
const WcsTooltip = createReactComponent('wcs-tooltip');

export { WcsAccordion, WcsAccordionContent, WcsAccordionHeader, WcsAccordionPanel, WcsActionBar, WcsAlert, WcsAlertDrawer, WcsApp, WcsBadge, WcsBreadcrumb, WcsBreadcrumbItem, WcsButton, WcsCard, WcsCardBody, WcsCardContent, WcsCardFooter, WcsCardHeader, WcsCardMedia, WcsCheckbox, WcsComNav, WcsComNavCategory, WcsComNavItem, WcsComNavSubmenu, WcsCounter, WcsDivider, WcsDropdown, WcsDropdownDivider, WcsDropdownHeader, WcsDropdownItem, WcsEditableField, WcsError, WcsField, WcsFieldContent, WcsFieldLabel, WcsFooter, WcsFormField, WcsGalactic, WcsGalacticMenu, WcsGrid, WcsGridColumn, WcsGridCustomCell, WcsGridPagination, WcsHeader, WcsHint, WcsHorizontalStepper, WcsIcon, WcsInput, WcsLabel, WcsListItem, WcsListItemProperties, WcsListItemProperty, WcsMatIcon, WcsModal, WcsNativeSelect, WcsNav, WcsNavItem, WcsProgressBar, WcsProgressRadial, WcsRadio, WcsRadioGroup, WcsSelect, WcsSelectOption, WcsSkeletonCircle, WcsSkeletonRectangle, WcsSkeletonText, WcsSpinner, WcsSwitch, WcsTab, WcsTabs, WcsTextarea, WcsTooltip };
//# sourceMappingURL=index.js.map
